
@inproceedings{10.1145/2568088.2568097,
  title = {On the Limits of Modeling Generational Garbage Collector Performance},
  booktitle = {Proceedings of the 5th {{ACM}}/{{SPEC}} International Conference on Performance Engineering},
  author = {Libi{\v c}, Peter and Bulej, Lubom{\'i}r and Horky, Vojt{\v e}ch and T{\r{u}}ma, Petr},
  year = {2014},
  series = {{{ICPE}} '14},
  pages = {15--26},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2568088.2568097},
  abstract = {Garbage collection is an element of many contemporary software platforms whose performance is determined by complex interactions and is therefore difficult to quantify and model. We investigate the difference between the behavior of a real garbage collector implementation and a simplified model on a selection of workloads, focusing on the accuracy achievable with particular input information (sizes, references, lifetimes). Our work highlights the limits of performance modeling of garbage collection and points out issues of existing evaluation tools that may lead to incorrect experimental conclusions.},
  isbn = {978-1-4503-2733-6},
  keywords = {garbage collector,java,performance modeling}
}

@inproceedings{10.1145/2989081.2989088,
  title = {A Validation of {{DRAM RAPL}} Power Measurements},
  booktitle = {Proceedings of the Second International Symposium on Memory Systems},
  author = {Desrochers, Spencer and Paradis, Chad and Weaver, Vincent M.},
  year = {2016},
  series = {{{MEMSYS}} '16},
  pages = {455--470},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2989081.2989088},
  abstract = {Recent Intel processors support the Running Average Power Level (RAPL) interface, which among other things provides estimated energy measurements for the CPUs, integrated GPU, and DRAM. These measurements are easily accessible by the user, and can be gathered by a wide variety of tools, including the Linux perf\textsubscript{e}vent interface. This allows unprecedented easy access to energy information when designing and optimizing energy-aware code.While greatly useful, on most systems these RAPL measurements are estimated values, generated on the fly by an on-chip energy model. The values are not documented well, and the results (especially the DRAM results) have undergone only limited validation.We validate the DRAM RAPL results on both desktop and server Haswell machines, with multiple types of DDR3 and DDR4 memory. We instrument the hardware to gather actual power measurements and compare them to the RAPL values returned via Linux perf\textsubscript{e}vent. We describe the many challenges encountered when instrumenting systems for detailed power measurement.We find that the RAPL results match overall energy and power trends, usually by a constant power offset. The results match best when the DRAM is being heavily utilized, but do not match as well in cases where the system is idle, or when an integrated GPU is using the memory.We also verify that Haswell server machines produce more accurate results, as they include actual power measurements gathered through the integrated voltage regulator.},
  isbn = {978-1-4503-4305-3},
  keywords = {DRAM Energy,DRAM Power,RAPL}
}

@book{10.5555/311424,
  title = {Refactoring: {{Improving}} the Design of Existing Code},
  year = {1999},
  publisher = {{Addison-Wesley Longman Publishing Co., Inc.}},
  address = {{USA}},
  abstract = {As the application of object technology\textendash particularly the Java programming language\textendash has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, "non-optimal" applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as "refactoring," these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Code, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process.With proper training a skilled system designer can take a bad design and rework it into well-designed, robust code. In this book, Martin Fowler shows you where opportunities for refactoring typically can be found, and how to go about reworking a bad design into a good one. Each refactoring step is simple\textendash seemingly too simple to be worth doing. Refactoring may involve moving a field from one class to another, or pulling some code out of a method to turn it into its own method, or even pushing some code up or down a hierarchy. While these individual steps may seem elementary, the cumulative effect of such small changes can radically improve the design. Refactoring is a proven way to prevent software decay.In addition to discussing the various techniques of refactoring, the author provides a detailed catalog of more than seventy proven refactorings with helpful pointers that teach you when to apply them; step-by-step instructions for applying each refactoring; and an example illustrating how the refactoring works. The illustrative examples are written in Java, but the ideas are applicable to any object-oriented programming language. 0201485672B04062001},
  isbn = {0-201-48567-2}
}

@inproceedings{6122743,
  ids = {oi2011power},
  title = {Power-Performance Analysis of {{JVM}} Implementations},
  booktitle = {{{ICIMU}} 2011 : {{Proceedings}} of the 5th International Conference on Information Technology Multimedia},
  author = {Oi, H.},
  year = {2011},
  pages = {1--7},
  doi = {10.1109/ICIMU.2011.6122743},
  organization = {{IEEE}}
}

@inproceedings{8457806,
  ids = {chiba2018towards},
  title = {Towards Selecting Best Combination of {{SQL-on-Hadoop}} Systems and {{JVMs}}},
  booktitle = {2018 {{IEEE}} 11th International Conference on Cloud Computing ({{CLOUD}})},
  author = {Chiba, T. and Yoshimura, T. and Horie, M. and Horii, H.},
  year = {2018},
  pages = {245--252},
  doi = {10.1109/CLOUD.2018.00038},
  organization = {{IEEE}}
}

@inproceedings{abtahizadeh_how_2015-1,
  title = {How Green Are Cloud Patterns?},
  author = {Abtahizadeh, S. Amirhossein and Khomh, Foutse and Gueheneuc, Yann-Gael},
  year = {2015},
  month = dec,
  pages = {1--8},
  publisher = {{IEEE}},
  doi = {10.1109/PCCC.2015.7410295},
  abstract = {Cloud Patterns are abstract solutions to recurrent design problems in the cloud. Previous work has shown that these patterns can improve the Quality of Service (QoS) of cloud applications but their impact on energy consumption is still unknown. Yet, energy consumption is the biggest challenge that cloud computing systems (the backbone of today's high-tech economy) face today. In fact, 10\% of the world's electricity is now being consumed by servers, laptops, tablets and smartphones. Energy consumption has complex dependencies on the hardware platform, and the multiple software layers. The hardware, its firmware, the operating system, and the various software components used by a cloud application, all contribute to determining the energy footprint. Hence, even though increasing a data center efficiency will eventually improve energy efficiency, the internal design of cloud-based applications can be improved to lower energy consumption. In this paper, we conduct an empirical study on a RESTful multi-threaded application deployed in the cloud, to investigate the individual and the combined impact of three cloud patterns (e.g., Local Database proxy, Local Sharding Based Router and Priority Queue) on the energy consumption of cloud based applications. We measure the energy consumption using Power-API; an application programming interface (API) written in Java to monitor the energy consumed at the processlevel. Results show that cloud patterns can effectively reduce the energy consumption of a cloud application, but not in all cases. In general, there appear to be a trade-off between an improved response time of the application and the energy consumption. Developers and software architects can make use of these results to guide their design decisions.},
  isbn = {978-1-4673-8590-9},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/QCXHHGZ5/Abtahizadeh et al. - 2015 - How green are cloud patterns.pdf}
}

@inproceedings{abuabdo_virtualization_2019-1,
  title = {Virtualization vs. {{Containerization}}: {{Towards}} a {{Multithreaded Performance Evaluation Approach}}},
  shorttitle = {Virtualization vs. {{Containerization}}},
  booktitle = {2019 {{IEEE}}/{{ACS}} 16th {{International Conference}} on {{Computer Systems}} and {{Applications}} ({{AICCSA}})},
  author = {Abuabdo, Amro and {Al-Sharif}, Ziad A.},
  year = {2019},
  month = nov,
  pages = {1--6},
  issn = {2161-5330},
  doi = {10.1109/AICCSA47632.2019.9035233},
  abstract = {Increasingly, hardware visualizations are becoming the norm. This opened the door for new possibilities but placed a new set of challenges that are to be faced by software developers, mainly when it comes to developing different applications in different programming languages and deploying them on various environments; often virtually hosted environments. The performance expectations and requirements might be easily affected by the settings of these virtual machines. This paper aims at evaluating the performance of these virtual environments and measure their impacts on the performance of multithreaded applications. In particular, we evaluate the performance of multithreaded applications and assess how it is influenced by the various virtualization technologies. A multithreaded application is developed in both C and Java and the performance is measured on different platforms; each of which is supported by either a virtualized system or a containerized environment. Certainly, C will keep outperforming Java in its execution speed; however, simple variations in the virtualization technique easily affects the performance of these multithreaded applications; a situation that should be taken into consideration by the software developers when deploying into such environments.},
  keywords = {Containerization,Containers,Docker,Docker Engine,Hardware,Hypervisor,Instruction sets,Java,Multithreading,performance evaluation,Virtualization},
  file = {/Users/chakibbelgaid/Zotero/storage/HGN34VRQ/Abuabdo and Al-Sharif - 2019 - Virtualization vs. Containerization Towards a Mul.pdf}
}

@article{acar_software_nodate-1,
  title = {Software Development Methodology in a {{Green IT}} Environment},
  author = {Acar, Hayri},
  pages = {121},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/ESBSFBNB/Acar - Software development methodology in a Green IT env.pdf}
}

@inproceedings{acun2016variation,
  title = {Variation among Processors under Turbo Boost in Hpc Systems},
  booktitle = {Proceedings of the 2016 International Conference on Supercomputing},
  author = {Acun, Bilge and Miller, Phil and Kale, Laxmikant V},
  year = {2016},
  pages = {1--12}
}

@inproceedings{afridi_empirical_2017-1,
  title = {Empirical Investigation of Correlation between Rewards and Crowdsource-Based Software Developers},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Afridi, H. G.},
  year = {2017},
  month = may,
  pages = {80--81},
  doi = {10.1109/ICSE-C.2017.149},
  abstract = {Numerous reward system practices are adopted in software development companies in order to motivate their developers to perform at best level and align the management and developer's interest. However, due to lack of a central mechanism for team formation on crowdsourcing-based software development platform, it is difficult for managers to adopt effective reward system strategies in order to align the developer's interest. In order to address this issue, we exploit an approach, to empirically investigate the existing reward system practices, adopted on the crowdsourcing-based software development platforms, to motivate their developers and their perception. Subsequently, we implement a crawler to mine the characteristics of completed tasks and related reward information from the TopCoder platform of Tech Platform Inc (TPI). The promising results suggest the applicability of the proposed approach in order, 1) to investigate the reward system practices across the crowdsourcing-based platforms and, 2) to help the managers in formulating and implementing an effective reward system to incentivize their developers.},
  keywords = {Companies,Context,Correlation,crawler,crowdsourcing,Crowdsourcing,crowdsourcing-based software development platform,data mining,Developers,Open source software,Regression,Reward System,reward system strategies,software development companies,software engineering,TopCoder},
  file = {/Users/chakibbelgaid/Zotero/storage/T5K4ZNRC/Afridi - 2017 - Empirical investigation of correlation between rew.pdf;/Users/chakibbelgaid/Zotero/storage/52IGP44H/7965262.html;/Users/chakibbelgaid/Zotero/storage/QL7W66Q7/7965262.html}
}

@article{akeret_hope_2015-1,
  title = {{{HOPE}}: {{A Python}} Just-in-Time Compiler for Astrophysical Computations},
  shorttitle = {{{HOPE}}},
  author = {Akeret, J. and Gamper, L. and Amara, A. and Refregier, A.},
  year = {2015},
  month = apr,
  journal = {Astronomy and Computing},
  volume = {10},
  pages = {1--8},
  issn = {22131337},
  doi = {10.1016/j.ascom.2014.12.001},
  abstract = {The Python programming language is becoming increasingly popular for scientific applications due to its simplicity, versatility, and the broad range of its libraries. A drawback of this dynamic language, however, is its low runtime performance which limits its applicability for large simulations and for the analysis of large data sets, as is common in astrophysics and cosmology. While various frameworks have been developed to address this limitation, most focus on covering the complete language set, and either force the user to alter the code or are not able to reach the full speed of an optimised native compiled language. In order to combine the ease of Python and the speed of C++, we developed HOPE, a specialised Python just-in-time (JIT) compiler designed for numerical astrophysical applications. HOPE focuses on a subset of the language and is able to translate Python code into C++ while performing numerical optimisation on mathematical expressions at runtime. To enable the JIT compilation, the user only needs to add a decorator to the function definition. We assess the performance of HOPE by performing a series of benchmarks and compare its execution speed with that of plain Python, C++ and the other existing frameworks. We find that HOPE improves the performance compared to plain Python by a factor of 2 to 120, achieves speeds comparable to that of C++, and often exceeds the speed of the existing solutions. We discuss the differences between HOPE and the other frameworks, as well as future extensions of its capabilities. The fully documented HOPE package is available at http://hope.phys.ethz.ch and is published under the GPLv3 license on PyPI and GitHub.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/NNDPH7QC/Akeret et al. - 2015 - HOPE A Python just-in-time compiler for astrophys.pdf}
}

@inproceedings{almeida_enabling_2013-1,
  title = {Enabling {{LTE}}/{{WiFi}} Coexistence by {{LTE}} Blank Subframe Allocation},
  author = {Almeida, Erika and Cavalcante, Andre M. and Paiva, Rafael C. D. and Chaves, Fabiano S. and Abinader, Fuad M. and Vieira, Robson D. and Choudhury, Sayantan and Tuomaala, Esa and Doppler, Klaus},
  year = {2013},
  month = jun,
  pages = {5083--5088},
  publisher = {{IEEE}},
  doi = {10.1109/ICC.2013.6655388},
  abstract = {The recent development of regulatory policies that permit the use of TV bands spectrum on a secondary basis has motivated discussion about coexistence of primary (e.g. TV broadcasts) and secondary users (e.g. WiFi users in TV spectrum). However, much less attention has been given to coexistence of different secondary wireless technologies in the TV white spaces. Lack of coordination between secondary networks may create severe interference situations, resulting in less efficient usage of the spectrum. In this paper, we consider two of the most prominent wireless technologies available today, namely Long Term Evolution (LTE), and WiFi, and address some problems that arise from their coexistence in the same band. We perform exhaustive system simulations and observe that WiFi is hampered much more significantly than LTE in coexistence scenarios. A simple coexistence scheme that reuses the concept of almost blank subframes in LTE is proposed, and it is observed that it can improve the WiFi throughput per user up to 50 times in the studied scenarios.},
  isbn = {978-1-4673-3122-7},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/UIGCADH8/Almeida et al. - 2013 - Enabling LTEWiFi coexistence by LTE blank subfram.pdf}
}

@article{alves_experiments_2020,
  title = {Experiments on {{Model-Based Software Energy Consumption Analysis}}},
  author = {Alves, Danilo S and Duarte, Lucio M and Silva, Davi and Maia, Paulo H M},
  year = {2020},
  pages = {8},
  abstract = {Although energy has become a concern in software development, little support exists for creating energy-efficient programs. We present the results of some experiments involving collecting energy information, modelling energy consumption, and analysing the costs of executing certain parts of the code. We combine and/or extend some existing free and open-source tools to carry out the experiments. Our experiments consider a comparison of energy consumption of a Java implementation of the Selection Sort algorithm using different data structures, and show how to combine an energy measurement tool and a model analysis tool. Based on this support and on our experiments, we believe developers could take a first step to creating more energy-efficient software.},
  langid = {english}
}

@inproceedings{anwar_evaluating_2019,
  title = {Evaluating the {{Impact}} of {{Code Smell Refactoring}} on the {{Energy Consumption}} of {{Android Applications}}},
  booktitle = {2019 45th {{Euromicro Conference}} on {{Software Engineering}} and {{Advanced Applications}} ({{SEAA}})},
  author = {Anwar, Hina and Pfahl, Dietmar and Srirama, Satish N.},
  year = {2019},
  month = aug,
  pages = {82--86},
  publisher = {{IEEE}},
  address = {{Kallithea-Chalkidiki, Greece}},
  doi = {10.1109/SEAA.2019.00021},
  abstract = {Energy consumption of mobile apps is receiving a lot of attention from researchers. Recent studies indicate that energy consumption of mobile devices could be lowered by improving the quality of mobile apps. Frequent refactoring is one way of achieving this goal. We explore the performance and energy impact of several common code refactorings in Android apps. Experimental results indicate that some code smell refactorings positively impact the energy consumption of Android apps. Refactoring of the code smells `Duplicated code' and `Type checking' reduce energy consumption by up to 10.8\%. Significant reduction in energy consumption, however, does not seem to be directly related to the increase or decrease of execution time. In addition, the energy impact over permutations of code smell refactorings in the selected Android apps was small. When analyzing the order in which refactorings were made across code smell types, it turned out that some permutations resulted in a reduction and some in an increase of energy consumption for the analyzed apps.},
  isbn = {978-1-72813-421-5},
  langid = {english}
}

@inproceedings{arcuri_practical_2011-1,
  title = {A Practical Guide for Using Statistical Tests to Assess Randomized Algorithms in Software Engineering},
  booktitle = {Proceeding of the 33rd International Conference on {{Software}} Engineering - {{ICSE}} '11},
  author = {Arcuri, Andrea and Briand, Lionel},
  year = {2011},
  pages = {1},
  publisher = {{ACM Press}},
  address = {{Waikiki, Honolulu, HI, USA}},
  doi = {10.1145/1985793.1985795},
  abstract = {Randomized algorithms have been used to successfully address many different types of software engineering problems. This type of algorithms employ a degree of randomness as part of their logic. Randomized algorithms are useful for difficult problems where a precise solution cannot be derived in a deterministic way within reasonable time. However, randomized algorithms produce different results on every run when applied to the same problem instance. It is hence important to assess the effectiveness of randomized algorithms by collecting data from a large enough number of runs. The use of rigorous statistical tests is then essential to provide support to the conclusions derived by analyzing such data. In this paper, we provide a systematic review of the use of randomized algorithms in selected software engineering venues in 2009. Its goal is not to perform a complete survey but to get a representative snapshot of current practice in software engineering research. We show that randomized algorithms are used in a significant percentage of papers but that, in most cases, randomness is not properly accounted for. This casts doubts on the validity of most empirical results assessing randomized algorithms. There are numerous statistical tests, based on different assumptions, and it is not always clear when and how to use these tests. We hence provide practical guidelines to support empirical research on randomized algorithms in software engineering.},
  isbn = {978-1-4503-0445-0},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/HFAYTVZK/Arcuri and Briand - 2011 - A practical guide for using statistical tests to a.pdf}
}

@inproceedings{ardito_energy_2013-1,
  title = {Energy Aware Self-Adaptation in Mobile Systems},
  booktitle = {2013 35th {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Ardito, L.},
  year = {2013},
  month = may,
  pages = {1435--1437},
  doi = {10.1109/ICSE.2013.6606736},
  abstract = {The increasing proliferation of mobile handsets, and the migration of the information access paradigm to mobile platforms, leads researchers to study the energy consumption of this class of devices. The literature still lacks metrics and tools that allow software developers to easily measure and optimize the energy efficiency of their code. Energy efficiency can definitely improve user experience increasing battery life. This paper aims to describe a technique to adapt the execution of a mobile application, based on the actual energy consumption of the device, without using external equipment.},
  keywords = {Android,Batteries,battery life,Context-Awareness,energy aware self-adaptation,Energy Aware Software,Energy Awareness,Energy consumption,Energy efficiency,energy efficiency optimization,information access paradigm,mobile application,Mobile communication,mobile computing,mobile handsets,mobile platforms,mobile systems,optimisation,power aware computing,Self-Adaptation,Smart phones,Software},
  file = {/Users/chakibbelgaid/Zotero/storage/FVGF2GA7/Ardito - 2013 - Energy aware self-adaptation in mobile systems.pdf;/Users/chakibbelgaid/Zotero/storage/9G3FDPR7/6606736.html;/Users/chakibbelgaid/Zotero/storage/9KP2PMR6/6606736.html}
}

@article{arnold_survey_2005-1,
  title = {A {{Survey}} of {{Adaptive Optimization}} in {{Virtual Machines}}},
  author = {Arnold, M. and Fink, S. J. and Grove, D. and Hind, M. and Sweeney, P. F.},
  year = {2005},
  month = feb,
  journal = {Proceedings of the IEEE},
  volume = {93},
  number = {2},
  pages = {449--466},
  issn = {0018-9219},
  doi = {10.1109/JPROC.2004.840305},
  abstract = {Virtual machines face significant performance challenges beyond those confronted by traditional static optimizers. First, portable program representations and dynamic language features, such as dynamic class loading, force the deferral of most optimizations until runtime, inducing runtime optimization overhead. Second, modular program representations preclude many forms of whole-program interprocedural optimization. Third, virtual machines incur additional costs for runtime services such as security guarantees and automatic memory management. To address these challenges, vendors have invested considerable resources into adaptive optimization systems in production virtual machines. Today, mainstream virtual machine implementations include substantial infrastructure for online monitoring and profiling, runtime compilation, and feedback-directed optimization. As a result, adaptive optimization has begun to mature as a widespread production-level technology. This paper surveys the evolution and current state of adaptive optimization technology in virtual machines.},
  keywords = {Adaptive optimization,adaptive optimization systems,Adaptive systems,automatic memory management,Condition monitoring,Costs,dynamic optimization,feedback directed optimization,feedback-directed optimization (FDO),Memory management,modular program representations,online monitoring,online profiling,optimisation,optimising compilers,Optimized production technology,production level technology,Production systems,Runtime,runtime compilation,Security,software performance evaluation,static optimizers,Virtual machine monitors,virtual machines,Virtual machining},
  file = {/Users/chakibbelgaid/Zotero/storage/K6UKJ9X8/Arnold et al. - 2005 - A Survey of Adaptive Optimization in Virtual Machi.pdf;/Users/chakibbelgaid/Zotero/storage/XJ7XEFUK/1386662.html;/Users/chakibbelgaid/Zotero/storage/YKJGZ6WH/1386662.html}
}

@article{avgerinou_trends_2017-1,
  title = {Trends in {{Data Centre Energy Consumption}} under the {{European Code}} of {{Conduct}} for {{Data Centre Energy Efficiency}}},
  author = {Avgerinou, Maria and Bertoldi, Paolo and Castellazzi, Luca},
  year = {2017},
  month = sep,
  journal = {Energies},
  volume = {10},
  number = {10},
  pages = {1470},
  doi = {10.3390/en10101470},
  abstract = {Climate change is recognised as one of the key challenges humankind is facing. The Information and Communication Technology (ICT) sector including data centres generates up to 2\% of the global CO2 emissions, a number on par to the aviation sector contribution, and data centres are estimated to have the fastest growing carbon footprint from across the whole ICT sector, mainly due to technological advances such as the cloud computing and the rapid growth of the use of Internet services. There are no recent estimations of the total energy consumption of the European data centre and of their energy efficiency. The aim of this paper is to evaluate, analyse and present the current trends in energy consumption and efficiency in data centres in the European Union using the data submitted by companies participating in the European Code of Conduct for Data Centre Energy Efficiency programme, a voluntary initiative created in 2008 in response to the increasing energy consumption in data centres and the need to reduce the related environmental, economic and energy supply security impacts. The analysis shows that the average Power Usage Effectiveness (PUE) of the facilities participating in the programme is declining year after year. This confirms that voluntary approaches could be effective in addressing climate and energy issue.},
  copyright = {http://creativecommons.org/licenses/by/3.0/},
  langid = {english},
  keywords = {Data Centre Energy Efficiency,energy efficiency policies,PUE,voluntary agreements},
  file = {/Users/chakibbelgaid/Zotero/storage/9DNAALQ5/Avgerinou et al. - 2017 - Trends in Data Centre Energy Consumption under the.pdf;/Users/chakibbelgaid/Zotero/storage/WG5T4QTG/1470.html;/Users/chakibbelgaid/Zotero/storage/XV5UKX3J/1470.html}
}

@article{bailey_nas_nodate-1,
  title = {The {{NAS Parallel Benchmarks}}},
  author = {Bailey, D and Barszcz, E and Barton, J and Browning, D and Carter, R and Dagum, L and Fineberg, S and Frederickson, P and Lasinski, T and Schreiber, R and Simon, H and Venkatakrishnan, V and Weeratunga, S},
  pages = {79},
  abstract = {A new set of benchmarks has been developed for the performance evaluation of highly parallel supercomputers. These benchmarks consist of ve parallel kernels and three simulated application benchmarks. Together they mimic the computation and data movement characteristics of large scale computational uid dynamics (CFD) applications.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/HKRAEIFE/Bailey et al. - The NAS Parallel Benchmarks.pdf}
}

@inproceedings{balasubramanian2009energy,
  title = {Energy Consumption in Mobile Phones: A Measurement Study and Implications for Network Applications},
  booktitle = {Proceedings of the 9th {{ACM SIGCOMM}} Conference on Internet Measurement},
  author = {Balasubramanian, Niranjan and Balasubramanian, Aruna and Venkataramani, Arun},
  year = {2009},
  pages = {280--293}
}

@inproceedings{banerjee2016automated,
  title = {Automated Re-Factoring of Android Apps to Enhance Energy-Efficiency},
  booktitle = {Proceedings of the International Conference on Mobile Software Engineering and Systems},
  author = {Banerjee, Abhijeet and Roychoudhury, Abhik},
  year = {2016},
  pages = {139--150}
}

@inproceedings{baskar2013experimental,
  title = {Experimental Investigation of Oxygen Enrichment on Performance of Twin Cylinder Diesel Engine with Variation of Injection Pressure},
  booktitle = {2013 International Conference on Energy Efficient Technologies for Sustainability},
  author = {Baskar, P and Joseph, Midhun Antony and Narayanan, Nijesh and Loya, Rajesh Babu},
  year = {2013},
  pages = {682--687},
  organization = {{IEEE}}
}

@inproceedings{bedard2010powermon,
  title = {Powermon: {{Fine-grained}} and Integrated Power Monitoring for Commodity Computer Systems},
  booktitle = {Proceedings of the {{IEEE SoutheastCon}} 2010 ({{SoutheastCon}})},
  author = {Bedard, Daniel and Lim, Min Yeol and Fowler, Robert and Porterfield, Allan},
  year = {2010},
  pages = {479--484},
  organization = {{IEEE}}
}

@article{behnel_cython_2011-1,
  title = {Cython: {{The Best}} of {{Both Worlds}}},
  shorttitle = {Cython},
  author = {Behnel, Stefan and Bradshaw, Robert and Citro, Craig and Dalcin, Lisandro and Seljebotn, Dag Sverre and Smith, Kurt},
  year = {2011},
  month = mar,
  journal = {Computing in Science \& Engineering},
  volume = {13},
  number = {2},
  pages = {31--39},
  issn = {1521-9615},
  doi = {10.1109/MCSE.2010.118},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/9DT728BX/Behnel et al. - 2011 - Cython The Best of Both Worlds.pdf}
}

@inproceedings{ben_asher_effect_2009-1,
  title = {The Effect of Unrolling and Inlining for {{Python}} Bytecode Optimizations},
  booktitle = {Proceedings of {{SYSTOR}} 2009: {{The Israeli Experimental Systems Conference}} on - {{SYSTOR}} '09},
  author = {Ben Asher, Yosi and Rotem, Nadav},
  year = {2009},
  pages = {1},
  publisher = {{ACM Press}},
  address = {{Haifa, Israel}},
  doi = {10.1145/1534530.1534550},
  isbn = {978-1-60558-623-6},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/W5SV2B9G/Ben Asher and Rotem - 2009 - The effect of unrolling and inlining for Python by.pdf}
}

@article{benmoussa_new_2019-1,
  title = {A New Model for the Selection of Web Development Frameworks: Application to {{PHP}} Frameworks},
  shorttitle = {A New Model for the Selection of Web Development Frameworks},
  author = {Benmoussa, Khaoula and Laaziri, Majida and Khoulji, Samira and Larbi, Kerkeb Mohamed and Yamami, Abir El},
  year = {2019},
  month = feb,
  journal = {International Journal of Electrical and Computer Engineering (IJECE)},
  volume = {9},
  number = {1},
  pages = {695--703},
  issn = {2722-2578},
  doi = {10.11591/ijece.v9i1.pp695-703},
  abstract = {The use of a framework is often essential for medium and large scale developments, but is also of interest for small developments. PHP has evolved as the scripting language the most chosen by developers, which has generated an explosion of PHP frameworks. There is a big debate about what the best PHP frameworks are, because the simple fact is that not all frameworks are built for everyone. Indeed, not all frameworks meet the same needs, and several frameworks can be used together in certain situations. Choosing the right framework, however, can sometimes be difficult. In order to make the selection process easier, we propose a pragmatic and complete model to compare and evaluate the main PHP frameworks. This model is based on a set of comparison criteria based on the Intrinsic durability, industrialized solution, technical adaptability, strategy, technical architecture and Speed criteria. Results show that the values of these criteria allow developers to easily and properly choose the framwork that best meets their needs},
  copyright = {Copyright (c) 2019 Institute of Advanced Engineering and Science},
  langid = {english},
  keywords = {codeIgniter,laravel,PHP frameworks,PHP frameworks evaluation,symphony,zend},
  file = {/Users/chakibbelgaid/Zotero/storage/CWLAD2Y8/Benmoussa et al. - 2019 - A new model for the selection of web development f.pdf;/Users/chakibbelgaid/Zotero/storage/GNHGX6DV/11586.html;/Users/chakibbelgaid/Zotero/storage/S9JKHQM8/11586.html}
}

@article{boettiger_introduction_2015-3,
  ids = {boettiger_introduction_2015,boettiger_introduction_2015-2},
  title = {An {{Introduction}} to {{Docker}} for {{Reproducible Research}}},
  author = {Boettiger, Carl},
  year = {2015},
  month = jan,
  journal = {SIGOPS Oper. Syst. Rev.},
  volume = {49},
  number = {1},
  pages = {71--79},
  issn = {0163-5980},
  doi = {10.1145/2723872.2723882},
  abstract = {As computational work becomes more and more integral to many aspects of scientific research, computational reproducibility has become an issue of increasing importance to computer systems researchers and domain scientists alike. Though computational reproducibility seems more straight forward than replicating physical experiments, the complex and rapidly changing nature of computer environments makes being able to reproduce and extend such work a serious challenge. In this paper, I explore common reasons that code developed for one research project cannot be successfully executed or extended by subsequent researchers. I review current approaches to these issues, including virtual machines and workflow systems, and their limitations. I then examine how the popular emerging technology Docker combines several areas from systems research - such as operating system virtualization, cross-platform portability, modular re-usable elements, versioning, and a 'DevOps' philosophy, to address these challenges. I illustrate this with several examples of Docker use with a focus on the R statistical environment.},
  file = {/Users/chakibbelgaid/Zotero/storage/8K6333JJ/Boettiger - 2015 - An Introduction to Docker for Reproducible Researc.pdf}
}

@inproceedings{bolz_tracing_2009-1,
  title = {Tracing the {{Meta-level}}: {{PyPy}}'s {{Tracing JIT Compiler}}},
  shorttitle = {Tracing the {{Meta-level}}},
  booktitle = {Proceedings of the 4th {{Workshop}} on the {{Implementation}}, {{Compilation}}, {{Optimization}} of {{Object-Oriented Languages}} and {{Programming Systems}}},
  author = {Bolz, Carl Friedrich and Cuni, Antonio and Fijalkowski, Maciej and Rigo, Armin},
  year = {2009},
  series = {{{ICOOOLPS}} '09},
  pages = {18--25},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1565824.1565827},
  abstract = {We attempt to apply the technique of Tracing JIT Compilers in the context of the PyPy project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing JIT compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing JIT to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing JIT compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two PyPy interpreters: one is a small example, and the other one is the full Python interpreter.},
  isbn = {978-1-60558-541-3},
  file = {/Users/chakibbelgaid/Zotero/storage/P7QBGTBN/Bolz et al. - 2009 - Tracing the Meta-level PyPy's Tracing JIT Compile.pdf}
}

@article{borkar_designing_2005,
  title = {Designing {{Reliable Systems}} from {{Unreliable Components}}: {{The Challenges}} of {{Transistor Variability}} and {{Degradation}}},
  shorttitle = {Designing {{Reliable Systems}} from {{Unreliable Components}}},
  author = {Borkar, S.},
  year = {2005},
  month = nov,
  journal = {IEEE Micro},
  volume = {25},
  number = {6},
  issn = {0272-1732},
  langid = {english},
  optdoi = {10.1109/MM.2005.110},
  optpages = {10-16}
}

@article{boulet_construire_nodate-1,
  title = {{Construire une argumentation}},
  author = {Boulet, Pierre},
  pages = {4},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/GJJEESVX/Boulet - Construire une argumentation.pdf}
}

@article{boulet_illustrations_nodate-1,
  title = {{Illustrations graphiques}},
  author = {Boulet, Pierre},
  pages = {4},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/4AE8UJS4/Boulet - Illustrations graphiques.pdf}
}

@article{boulet_presentations_nodate-1,
  title = {{Pr\'esentations orales : pr\'eparation}},
  author = {Boulet, Pierre},
  pages = {2},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/P8BZQ76Z/Boulet - Présentations orales  préparation.pdf}
}

@article{boulet_principes_nodate-1,
  title = {{Principes et outils informatiques}},
  author = {Boulet, Pierre},
  pages = {4},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/8IN2UFPQ/Boulet - Principes et outils informatiques.pdf}
}

@article{boulet_structuration_nodate-1,
  title = {{Structuration des documents}},
  author = {Boulet, Pierre},
  pages = {4},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/C7Z854AX/Boulet - Structuration des documents.pdf}
}

@article{boulet_typographie_nodate,
  title = {{Typographie g\'en\'erale}},
  author = {Boulet, Pierre},
  pages = {4},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/MKZBSR3J/Boulet - Typographie générale.pdf}
}

@article{boulet_typographie_nodate-2,
  title = {{Typographie scientifique}},
  author = {Boulet, Pierre},
  pages = {4},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/GYPHLZIM/Boulet - Typographie scientifique.pdf}
}

@article{bourdon:hal-00772454,
  title = {{{PowerAPI}}: {{A}} Software Library to Monitor the Energy Consumed at the Process-Level},
  author = {Bourdon, Aur{\'e}lien and Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
  year = {2013},
  month = jan,
  journal = {ERCIM News},
  series = {Special Theme: {{Smart}} Energy Systems},
  volume = {92},
  publisher = {{ERCIM}},
  hal_id = {hal-00772454},
  hal_version = {v1},
  opteditor = {ERCIM},
  optpages = {43-44},
  opturl = {https://hal.inria.fr/hal-00772454}
}

@phdthesis{boussaa_automatic_2017,
  title = {Automatic Non-Functional Testing and Tuning of Configurable Generators},
  author = {Boussaa, Mohamed},
  year = {2017},
  month = sep,
  abstract = {Generative software development has paved the way for the creation of multiple generators (code generators and compilers) that serve as a basis for automatically producing code to a broad range of software and hardware platforms. With full automatic code generation, users are able to rapidly synthesize software artifacts for various software platforms. In addition, they can easily customize the generated code for the target hardware platform since modern generators (i.e., C compilers) become highly configurable, offering numerous configuration options that the user can apply. Consequently, the quality of generated software becomes highly correlated to the configuration settings as well as to the generator itself. In this context, it is crucial to verify the correct behavior of generators. Numerous approaches have been proposed to verify the functional outcome of generated code but few of them evaluate the non-functional properties of automatically generated code, namely the performance and resource usage properties. This thesis addresses three problems : (1) Non-functional testing of generators: We benefit from the existence of multiple code generators with comparable functionality (i.e., code generator families) to automatically test the generated code. We leverage the metamorphic testing approach to detect non-functional inconsistencies in code generator families by defining metamorphic relations as test oracles. We define the metamorphic relation as a comparison between the variations of performance and resource usage of code, generated from the same code generator family. We evaluate our approach by analyzing the performance of HAXE, a popular code generator family. Experimental results show that our approach is able to automatically detect several inconsistencies that reveal real issues in this family of code generators. (2) Generators auto-tuning: We exploit the recent advances in search-based software engineering in order to provide an effective approach to tune generators (i.e., through optimizations) according to user's non-functional requirements (i.e., performance and resource usage). We also demonstrate that our approach can be used to automatically construct optimization levels that represent optimal trade-offs between multiple non-functional properties such as execution time and resource usage requirements. We evaluate our approach by verifying the optimizations performed by the GCC compiler. Our experimental results show that our approach is able to auto-tune compilers and construct optimizations that yield to better performance results than standard optimization levels. (3) Handling the diversity of software and hardware platforms in software testing: Running tests and evaluating the resource usage in heterogeneous environments is tedious. To handle this problem, we benefit from the recent advances in lightweight system virtualization, in particular container-based virtualization, in order to offer effective support for automatically deploying, executing, and monitoring code in heterogeneous environment, and collect non-functional metrics (e.g., memory and CPU consumptions). This testing infrastructure serves as a basis for evaluating the experiments conducted in the two first contributions.},
  langid = {english},
  school = {Universit\'e Rennes 1},
  file = {/Users/chakibbelgaid/Zotero/storage/3CNKK37G/Boussaa - 2017 - Automatic non-functional testing and tuning of con.pdf;/Users/chakibbelgaid/Zotero/storage/2WAMCY43/tel-01619139.html}
}

@phdthesis{boussaa_automatic_2017,
  title = {Automatic Non-Functional Testing and Tuning of Configurable Generators},
  author = {Boussaa, Mohamed},
  year = {2017},
  month = sep,
  abstract = {Generative software development has paved the way for the creation of multiple generators (code generators and compilers) that serve as a basis for automatically producing code to a broad range of software and hardware platforms. With full automatic code generation, users are able to rapidly synthesize software artifacts for various software platforms. In addition, they can easily customize the generated code for the target hardware platform since modern generators (i.e., C compilers) become highly configurable, offering numerous configuration options that the user can apply. Consequently, the quality of generated software becomes highly correlated to the configuration settings as well as to the generator itself. In this context, it is crucial to verify the correct behavior of generators. Numerous approaches have been proposed to verify the functional outcome of generated code but few of them evaluate the non-functional properties of automatically generated code, namely the performance and resource usage properties. This thesis addresses three problems : (1) Non-functional testing of generators: We benefit from the existence of multiple code generators with comparable functionality (i.e., code generator families) to automatically test the generated code. We leverage the metamorphic testing approach to detect non-functional inconsistencies in code generator families by defining metamorphic relations as test oracles. We define the metamorphic relation as a comparison between the variations of performance and resource usage of code, generated from the same code generator family. We evaluate our approach by analyzing the performance of HAXE, a popular code generator family. Experimental results show that our approach is able to automatically detect several inconsistencies that reveal real issues in this family of code generators. (2) Generators auto-tuning: We exploit the recent advances in search-based software engineering in order to provide an effective approach to tune generators (i.e., through optimizations) according to user's non-functional requirements (i.e., performance and resource usage). We also demonstrate that our approach can be used to automatically construct optimization levels that represent optimal trade-offs between multiple non-functional properties such as execution time and resource usage requirements. We evaluate our approach by verifying the optimizations performed by the GCC compiler. Our experimental results show that our approach is able to auto-tune compilers and construct optimizations that yield to better performance results than standard optimization levels. (3) Handling the diversity of software and hardware platforms in software testing: Running tests and evaluating the resource usage in heterogeneous environments is tedious. To handle this problem, we benefit from the recent advances in lightweight system virtualization, in particular container-based virtualization, in order to offer effective support for automatically deploying, executing, and monitoring code in heterogeneous environment, and collect non-functional metrics (e.g., memory and CPU consumptions). This testing infrastructure serves as a basis for evaluating the experiments conducted in the two first contributions.},
  langid = {english},
  school = {Universit\'e Rennes 1},
  file = {/Users/chakibbelgaid/Zotero/storage/PLH37HA5/Boussaa - 2017 - Automatic non-functional testing and tuning of con.pdf;/Users/chakibbelgaid/Zotero/storage/9WGI3FTK/tel-01619139.html}
}

@misc{bradberry_emotional_2019,
  title = {Emotional {{Intelligence}} - {{EQ}}},
  author = {Bradberry, Travis},
  year = {2019},
  month = feb,
  journal = {Forbes},
  abstract = {As the bestselling coauthor of Emotional Intelligence 2.0, I'm often asked to break down what emotional intelligence is and why it's so important. Here goes... Emotional Intelligence Is the Other Kind of Smart. When emotional intelligence first appeared to the masses in 1995, it served as the missing link in a peculiar [...]},
  howpublished = {https://www.forbes.com/sites/travisbradberry/2014/01/09/emotional-intelligence/},
  langid = {english},
  note = {\begin{quotation}
havoc stress

\end{quotation}},
  file = {/Users/chakibbelgaid/Zotero/storage/AVDSZJE7/emotional-intelligence.html}
}

@misc{bradberry_emotional_2019,
  title = {Emotional {{Intelligence}} - {{EQ}}},
  author = {Bradberry, Travis},
  year = {2019},
  month = feb,
  abstract = {As the bestselling coauthor of Emotional Intelligence 2.0, I'm often asked to break down what emotional intelligence is and why it's so important. Here goes... Emotional Intelligence Is the Other Kind of Smart. When emotional intelligence first appeared to the masses in 1995, it served as the missing link in a peculiar [...]},
  langid = {english},
  note = {\begin{quotation}
 havoc stress 

\end{quotation}},
  file = {/Users/chakibbelgaid/Zotero/storage/WMII6VUD/emotional-intelligence.html}
}

@misc{bradberry_how_2019,
  title = {How {{Successful People Stay Calm}}},
  author = {Bradberry, Travis},
  year = {2019},
  month = feb,
  journal = {Forbes},
  abstract = {The ability to manage your emotions and remain calm under pressure has a direct link to your performance. TalentSmart has conducted research with more than a million people, and we've found that 90\% of top performers are skilled at managing their emotions in times of stress in order to remain [...]},
  howpublished = {https://www.forbes.com/sites/travisbradberry/2014/02/06/how-successful-people-stay-calm/},
  langid = {english},
  note = {\begin{quotation}
havoc stress

\end{quotation}},
  file = {/Users/chakibbelgaid/Zotero/storage/NXRZ5ZQB/how-successful-people-stay-calm.html}
}

@misc{bradberry_how_2019,
  title = {How {{Successful People Stay Calm}}},
  author = {Bradberry, Travis},
  year = {2019},
  month = feb,
  abstract = {The ability to manage your emotions and remain calm under pressure has a direct link to your performance. TalentSmart has conducted research with more than a million people, and we've found that 90\% of top performers are skilled at managing their emotions in times of stress in order to remain [...]},
  langid = {english},
  note = {\begin{quotation}
 havoc stress 

\end{quotation}},
  file = {/Users/chakibbelgaid/Zotero/storage/9MQ3W72A/how-successful-people-stay-calm.html}
}

@article{brownlee_search_based_2017,
  title = {Search-{{Based Energy Optimization}} of {{Some Ubiquitous Algorithms}}},
  author = {Brownlee, Alexander Edward Ian and Burles, Nathan and Swan, Jerry},
  year = {2017},
  month = jun,
  journal = {IEEE Transactions on Emerging Topics in Computational Intelligence},
  volume = {1},
  number = {3},
  pages = {188--201},
  issn = {2471-285X},
  doi = {10.1109/TETCI.2017.2699193},
  abstract = {Reducing computational energy consumption is of growing importance, particularly at the extremes (i.e., mobile devices and datacentres). Despite the ubiquity of the Java virtual machine (JVM), very little work has been done to apply search-based software engineering (SBSE) to minimize the energy consumption of programs that run on it. We describe OPACITOR, a tool for measuring the energy consumption of JVM programs using a bytecode level model of energy cost. This has several advantages over timebased energy approximations or hardware measurements. It is 1) deterministic, 2) unaffected by the rest of the computational environment, 3) able to detect small changes in execution profile, making it highly amenable to metaheuristic search, which requires locality of representation. We show how generic SBSE approaches coupled with OPACITOR achieve substantial energy savings for three widely used software components. Multilayer perceptron implementations minimizing both energy and error were found, and energy reductions of up to 70\% and 39.85\% were obtained over the original code for Quicksort and object-oriented container classes, respectively. These highlight three important considerations for automatically reducing computational energy: tuning software to particular distributions of data; trading off energy use against functional properties; and handling internal dependencies that can exist within software that render simple sweeps over program variants sub-optimal. Against these, global search greatly simplifies the developer's job, freeing development time for other tasks.},
  langid = {english}
}

@article{bujnowski2020java,
  title = {Java and {{Kotlin}} Code Performance in Selected Web Frameworks},
  author = {Bujnowski, Grzegorz and Smo{\l}ka, Jakub},
  year = {2020},
  journal = {Journal of Computer Sciences Institute},
  volume = {16},
  pages = {219--226}
}

@misc{bukh1992art,
  title = {The Art of Computer Systems Performance Analysis, Techniques for Experimental Design, Measurement, Simulation and Modeling},
  author = {Bukh, Per Nikolaj D},
  year = {1992},
  publisher = {{JSTOR}}
}

@inproceedings{burtscher2014measuring,
  title = {Measuring {{GPU}} Power with the {{K20}} Built-in Sensor},
  booktitle = {Proceedings of Workshop on General Purpose Processing Using {{GPUs}}},
  author = {Burtscher, Martin and Zecena, Ivan and Zong, Ziliang},
  year = {2014},
  pages = {28--36}
}

@article{buytaert_statistically_nodate-1,
  title = {Statistically {{Rigorous Java Performance Evaluation}}},
  author = {Buytaert, Andy Georges Dries and Eeckhout, Lieven},
  pages = {20},
  abstract = {Java performance is far from being trivial to benchmark because it is affected by various factors such as the Java application, its input, the virtual machine, the garbage collector, the heap size, etc. In addition, non-determinism at run-time causes the execution time of a Java program to differ from run to run. There are a number of sources of non-determinism such as Just-In-Time (JIT) compilation and optimization in the virtual machine (VM) driven by timerbased method sampling, thread scheduling, garbage collection, and various system effects.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/8YJX97JJ/Buytaert and Eeckhout - Statistically Rigorous Java Performance Evaluation.pdf}
}

@article{calero2021does,
  title = {Does Maintainability Relate to the Energy Consumption of Software?},
  author = {Calero, Coral and Mancebo Pav{\'o}n, Javier and Garc{\'i}a, F{\'e}lix},
  year = {2021},
  publisher = {{Springer}}
}

@article{callau_how_2013-1,
  title = {How (and Why) Developers Use the Dynamic Features of Programming Languages: The Case of Smalltalk},
  shorttitle = {How (and Why) Developers Use the Dynamic Features of Programming Languages},
  author = {Calla{\'u}, Oscar and Robbes, Romain and Tanter, {\'E}ric and R{\"o}thlisberger, David},
  year = {2013},
  month = dec,
  journal = {Empirical Software Engineering},
  volume = {18},
  number = {6},
  pages = {1156--1194},
  issn = {1382-3256, 1573-7616},
  doi = {10.1007/s10664-012-9203-2},
  abstract = {The dynamic and reflective features of programming languages are powerful constructs that programmers often mention as extremely useful. However, the ability to modify a program at runtime can be both a boon\textemdash in terms of flexibility\textemdash, and a curse\textemdash in terms of tool support. For instance, usage of these features hampers the design of type systems, the accuracy of static analysis techniques, or the introduction of optimizations by compilers. In this paper, we perform an empirical study of a large Smalltalk codebase\textemdash often regarded as the poster-child in terms of availability of these features\textemdash, in order to assess how much these features are actually used in practice, whether some are used more than others, and in which kinds of projects. In addition, we performed a qualitative analysis of a representative sample of usages of dynamic features in order to uncover (1) the principal reasons that drive people to use dynamic features, and (2) whether and how these dynamic feature usages can be removed or converted to safer usages. These results are useful to make informed decisions about which features to consider when designing language extensions or tool support.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/APA6RJUF/Callaú et al. - 2013 - How (and why) developers use the dynamic features .pdf}
}

@inproceedings{cardenas_performance_2005-1,
  title = {Performance Comparison of a {{Web}} Cache Simulation Framework},
  booktitle = {19th {{International Conference}} on {{Advanced Information Networking}} and {{Applications}} ({{AINA}}'05) {{Volume}} 1 ({{AINA}} Papers)},
  author = {Cardenas, L. G. and Gil, J. A. and Domenech, J. and Sahuquillo, J. and Pont, A.},
  year = {2005},
  month = mar,
  volume = {2},
  pages = {281-284 vol.2},
  issn = {2332-5658},
  doi = {10.1109/AINA.2005.275},
  abstract = {Performance comparison studies are primarily carried out through real systems or simulation environments. Simulation is the most commonly used method to explore new proposals due to both its flexibility and the relatively reduced time taken to obtain performance results. This paper presents a powerful framework to simulate Web proxy cache systems. Our tool provides a comfortable environment to simulate and explore cache management techniques. In order to validate our framework and show how accurate it executes, a performance comparison has been done. We analyzed the details of a commercial proxy cache system and compare its results with those obtained from our simulator using the most commonly replacement algorithm (LRU). For this purpose, the proposed environment was adapted to match the performance of the real proxy cache. Experimental results show that proxy cache hit ratio deviations fall very close to the real system, since then, never exceeds 3.42\%.},
  keywords = {Algorithm design and analysis,Analytical models,cache management,cache storage,Computational modeling,Computer simulation,Content management,Delay,digital simulation,Environmental management,Internet,LRU,Navigation,performance comparison,Proposals,Proxy web cache,real system,replacement algorithm,simulation environment,simulation techniques,validation,Web cache simulation,Web proxy cache system,Web server},
  file = {/Users/chakibbelgaid/Zotero/storage/T2B2K5EQ/Cardenas et al. - 2005 - Performance comparison of a Web cache simulation f.pdf}
}

@inproceedings{chamas2017comparing,
  title = {Comparing {{REST}}, {{SOAP}}, {{Socket}} and {{gRPC}} in Computation Offloading of Mobile Applications: {{An}} Energy Cost Analysis},
  booktitle = {2017 {{IEEE}} 9th Latin-American Conference on Communications ({{LATINCOM}})},
  author = {Chamas, Carolina Luiza and Cordeiro, Daniel and Eler, Marcelo Medeiros},
  year = {2017},
  pages = {1--6},
  organization = {{IEEE}}
}

@inproceedings{chasapis2016runtime,
  title = {Runtime-Guided Mitigation of Manufacturing Variability in Power-Constrained Multi-Socket Numa Nodes},
  booktitle = {Proceedings of the 2016 International Conference on Supercomputing},
  author = {Chasapis, Dimitrios and Casas, Marc and Moret{\'o}, Miquel and Schulz, Martin and Ayguad{\'e}, Eduard and Labarta, Jesus and Valero, Mateo},
  year = {2016},
  pages = {1--12}
}

@inproceedings{chekam_empirical_2017-1,
  title = {An {{Empirical Study}} on {{Mutation}}, {{Statement}} and {{Branch Coverage Fault Revelation That Avoids}} the {{Unreliable Clean Program Assumption}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Chekam, T. T. and Papadakis, M. and Traon, Y. Le and Harman, M.},
  year = {2017},
  month = may,
  pages = {597--608},
  doi = {10.1109/ICSE.2017.61},
  abstract = {Many studies suggest using coverage concepts, such as branch coverage, as the starting point of testing, while others as the most prominent test quality indicator. Yet the relationship between coverage and fault-revelation remains unknown, yielding uncertainty and controversy. Most previous studies rely on the Clean Program Assumption, that a test suite will obtain similar coverage for both faulty and fixed ('clean') program versions. This assumption may appear intuitive, especially for bugs that denote small semantic deviations. However, we present evidence that the Clean Program Assumption does not always hold, thereby raising a critical threat to the validity of previous results. We then conducted a study using a robust experimental methodology that avoids this threat to validity, from which our primary finding is that strong mutation testing has the highest fault revelation of four widely-used criteria. Our findings also revealed that fault revelation starts to increase significantly only once relatively high levels of coverage are attained.},
  keywords = {branch coverage fault revelation,code coverage,Correlation,Java,mutation testing,Mutation testing,program testing,real faults,Robustness,semantic deviations,software fault tolerance,software quality,Standards,test adequacy,test effectiveness,test quality indicator,Testing,Tools,unreliable clean program assumption avoidance},
  file = {/Users/chakibbelgaid/Zotero/storage/764HWRHE/Chekam et al. - 2017 - An Empirical Study on Mutation, Statement and Bran.pdf;/Users/chakibbelgaid/Zotero/storage/EXS2QKSM/7985697.html;/Users/chakibbelgaid/Zotero/storage/PP24JJXP/7985697.html}
}

@inproceedings{chen_empirical_2016-1,
  title = {An {{Empirical Comparison}} of {{Compiler Testing Techniques}}},
  booktitle = {Proceedings of the 38th {{International Conference}} on {{Software Engineering}}},
  author = {Chen, Junjie and Hu, Wenxiang and Hao, Dan and Xiong, Yingfei and Zhang, Hongyu and Zhang, Lu and Xie, Bing},
  year = {2016},
  series = {{{ICSE}} '16},
  pages = {180--190},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2884781.2884878},
  abstract = {Compilers, as one of the most important infrastructure of today's digital world, are expected to be trustworthy. Different testing techniques are developed for testing compilers automatically. However, it is unknown so far how these testing techniques compared to each other in terms of testing effectiveness: how many bugs a testing technique can find within a time limit. In this paper, we conduct a systematic and comprehensive empirical comparison of three compiler testing techniques, namely, Randomized Differential Testing (RDT), a variant of RDT---Different Optimization Levels (DOL), and Equivalence Modulo Inputs (EMI). Our results show that DOL is more effective at detecting bugs related to optimization, whereas RDT is more effective at detecting other types of bugs, and the three techniques can complement each other to a certain degree. Furthermore, in order to understand why their effectiveness differs, we investigate three factors that influence the effectiveness of compiler testing, namely, efficiency, strength of test oracles, and effectiveness of generated test programs. The results indicate that all the three factors are statistically significant, and efficiency has the most significant impact.},
  isbn = {978-1-4503-3900-1},
  file = {/Users/chakibbelgaid/Zotero/storage/ITGNTF7F/Chen et al. - 2016 - An Empirical Comparison of Compiler Testing Techni.pdf}
}

@inproceedings{chowdhury_client-side_2016-1,
  title = {Client-{{Side Energy Efficiency}} of {{HTTP}}/2 for {{Web}} and {{Mobile App Developers}}},
  booktitle = {2016 {{IEEE}} 23rd {{International Conference}} on {{Software Analysis}}, {{Evolution}}, and {{Reengineering}} ({{SANER}})},
  author = {Chowdhury, S. A. and Sapra, V. and Hindle, A.},
  year = {2016},
  month = mar,
  volume = {1},
  pages = {529--540},
  doi = {10.1109/SANER.2016.77},
  abstract = {Recent technological advancements have enabled mobile devices to provide mobile users with substantial capability and accessibility. Energy is evidently one of the most critical resources for such devices, in spite of the substantial gain in popularity of mobile devices, such as smart phones, their utility is severely constrained by the bounded battery capacity. Mobile users are very interested in accessing the Internet although it is one of the most expensive operations in terms of energy and cost. HTTP/2 has been proposed and accepted as the new standard for supporting the World Wide Web. HTTP/2 is expected to offer better performance, such as reduced page load time. Consequently, from the mobile users point of view, the question arises:does HTTP/2 offer improved energy consumption performance achieving longer battery life?In this paper, we compare the energy consumption of HTTP/2 with its predecessor (i.e., HTTP/1.1) using a variety of realworld and synthetic test scenarios. We also investigate how Transport Layer Security (TLS) impacts the energy consumption of the mobile devices. Our study suggests that Round Trip Time (RTT) is one of the biggest factors in deciding how advantageous HTTP/2 is compared to HTTP/1.1. We conclude that for networks with higher RTTs, HTTP/2 has better energy consumption performance than HTTP/1.1.},
  keywords = {Android applications,Energy consumption,GreenMining,HTTP/2 client-side energy efficiency,improving energy consumption,Internet,Mining software repositories,mobile app developers,Mobile communication,mobile computing,mobile device energy consumption,Modeling energy consumption,power aware computing,Protocols,reduced page load time,round trip time,Servers,smart phone battery capacity,Smart phones,Software energy,transport layer security,Web developers,World Wide Web},
  file = {/Users/chakibbelgaid/Zotero/storage/KQEAIZQG/Chowdhury et al. - 2016 - Client-Side Energy Efficiency of HTTP2 for Web an.pdf;/Users/chakibbelgaid/Zotero/storage/HG9QLISW/7476672.html;/Users/chakibbelgaid/Zotero/storage/WS5S2SFM/7476672.html}
}

@inproceedings{chowdhury_greenoracle_2016-1,
  title = {{{GreenOracle}}: {{Estimating Software Energy Consumption}} with {{Energy Measurement Corpora}}},
  shorttitle = {{{GreenOracle}}},
  booktitle = {Proceedings of the 13th {{International Conference}} on {{Mining Software Repositories}}},
  author = {Chowdhury, Shaiful Alam and Hindle, Abram},
  year = {2016},
  series = {{{MSR}} '16},
  pages = {49--60},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2901739.2901763},
  abstract = {Software energy consumption is a relatively new concern for mobile application developers. Poor energy performance can harm adoption and sales of applications. Unfortunately for the developers, the measurement of software energy consumption is expensive in terms of hardware and difficult in terms of expertise. Many prior models of software energy consumption assume that developers can use hardware instrumentation and thus cannot evaluate software running within emulators or virtual machines. Some prior models require actual energy measurements from the previous versions of applications in order to model the energy consumption of later versions of the same application. In this paper, we take a big-data approach to software energy consumption and present a model that can estimate software energy consumption mostly within 10\% error (in joules) and does not require the developer to train on energy measurements of their own applications. This model leverages a big-data approach whereby a collection of prior applications' energy measurements allows us to train, transmit, and apply the model to estimate any foreign application's energy consumption for a test run. Our model is based on the dynamic traces of system calls and CPU utilization.},
  isbn = {978-1-4503-4186-8},
  file = {/Users/chakibbelgaid/Zotero/storage/3ZPKNLPW/Chowdhury and Hindle - 2016 - GreenOracle Estimating Software Energy Consumptio.pdf}
}

@article{cockburn_threats_2020-1,
  title = {Threats of a Replication Crisis in Empirical Computer Science},
  author = {Cockburn, Andy and Dragicevic, Pierre and Besan{\c c}on, Lonni and Gutwin, Carl},
  year = {2020},
  month = jul,
  journal = {Communications of the ACM},
  volume = {63},
  number = {8},
  pages = {70--79},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/3360311},
  abstract = {Research replication only works if there is confidence built into the results.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/S54LTRLY/Cockburn et al. - 2020 - Threats of a replication crisis in empirical compu.pdf}
}

@techreport{coles_comparing_2014,
  ids = {coles2014comparing},
  title = {Comparing {{Server Energy Use}} and {{Efficiency Using Small Sample Sizes}}},
  author = {Coles, Henry and Qin, Yong and Price, Phillip},
  year = {2014},
  month = nov,
  number = {LBNL-6831E, 1163229},
  langid = {english},
  optdoi = {10.2172/1163229}
}

@phdthesis{colmant_multi-dimensional_2016-1,
  title = {Multi-{{Dimensional Analysis}} of {{Software Power Consumptions}} in {{Multi-Core Architectures}}},
  author = {Colmant, Maxime},
  year = {2016},
  month = nov,
  abstract = {Energy-efficient computing is becoming increasingly important. Among the reasons, one can mention the massive consumption of large data centers that consume as much as 180,000 homes. This trend, combined with environmental concerns, makes energy efficiency a prime technological and societal challenge. Currently, widely used power distribution units (PDUs) are often shared amongst nodes to deliver aggregated power consumption reports, in the range of hours and minutes. However, in order to improve the energy efficiency of software systems, we need to support process-level power estimation in real-time, which goes beyond the capacity of a PDUs. In particular, the CPU is considered by the research community as the major power consumer within a node and draws attention while trying to model the system power consumption. Over the last few years, a dozen of ad hoc power models have been proposed to cope with the wide diversity and the growing complexity of modern CPU architectures. In this thesis, we rather propose PowerAPI for learning power models and building software-defined power meters that provide accurate power estimation on modern architectures. With the emergence of cloud computing, we propose BitWatts and WattsKit for leveraging software power estimation in VMs and clusters. A finer level of estimation may be required to further evaluate the effectiveness of the software optimizations and we therefore propose codEnergy for helping developers to understand how the energy is really consumed by a software. We deeply assessed all above approaches, thus demonstrating the usefulness of PowerAPI to better understand the software power consumption on modern architectures.},
  langid = {english},
  school = {Universit\'e Lille 1 - Sciences et Technologies},
  file = {/Users/chakibbelgaid/Zotero/storage/468DW7ED/Colmant - 2016 - Multi-Dimensional Analysis of Software Power Consu.pdf;/Users/chakibbelgaid/Zotero/storage/35D99NIR/tel-01403559.html;/Users/chakibbelgaid/Zotero/storage/TCHAYPAL/tel-01403559.html}
}

@article{corcoran_emerging_nodate,
  title = {Emerging	  ~{{Trends}}	  ~in	  ~{{Electricity}}	  ~{{Consumption}}	  ~ for	  ~{{Consumer}}	  ~{{ICT}}},
  author = {Corcoran, Peter and Andrae, Anders},
  pages = {56},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/6C7KXMBT/Corcoran and Andrae - Emerging    Trends    in    Electricity    Consump.pdf}
}

@article{corcoran_emerging_nodate,
  title = {Emerging  {{Trends}}  in  {{Electricity}}  {{Consumption}}   for  {{Consumer}}  {{ICT}}},
  author = {Corcoran, Peter and Andrae, Anders},
  pages = {56},
  langid = {english}
}

@inproceedings{corral2014method,
  title = {Method Reallocation to Reduce Energy Consumption: An Implementation in Android Os},
  booktitle = {Proceedings of the 29th Annual {{ACM}} Symposium on Applied Computing},
  author = {Corral, Luis and Georgiev, Anton B and Sillitti, Alberto and Succi, Giancarlo},
  year = {2014},
  pages = {1213--1218}
}

@inproceedings{correia_detecting_2019-1,
  title = {Detecting {{Design Violations}} in {{Django-based Web Applications}}},
  booktitle = {Proceedings of the {{XIII Brazilian Symposium}} on {{Software Components}}, {{Architectures}}, and {{Reuse}}  - {{SBCARS}} '19},
  author = {Correia, Renieri and Adachi, Eiji},
  year = {2019},
  pages = {33--42},
  publisher = {{ACM Press}},
  address = {{Salvador, Brazil}},
  doi = {10.1145/3357141.3357600},
  abstract = {If on one hand frameworks allow programmers to reuse well-known architectural solutions, on the other hand they can make programmers unaware of important design decisions that should be followed during software construction, maintenance and evolution. And if programmers are unaware of these design decisions, there is a high risk of introducing design violations in the source code, and the accumulation of these violations might hinder software maintainability and evolvability. The use of static analysis tools might be employed to mitigate these problems by assisting the detection of recurring design violations in a given architectural pattern. In this work, we present MTV-Checker, a tool to assist the automatic detection of 5 design violations in Django-based web applications. We also conducted an empirical study in the context of the SUAP system, a large-scale Django-based information system with more than 175.000 lines of Python code currently deployed in more than 30 Brazilian institutions. Our results present the most recurrent violations, how they evolve along software evolution, and the opinions and experiences of software architects regarding these violations.},
  isbn = {978-1-4503-7637-2},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/EF5V57DS/Correia and Adachi - 2019 - Detecting Design Violations in Django-based Web Ap.pdf}
}

@inproceedings{couto2017towards,
  title = {Towards a Green Ranking for Programming Languages},
  booktitle = {Proceedings of the 21st Brazilian Symposium on Programming Languages},
  author = {Couto, Marco and Pereira, Rui and Ribeiro, Francisco and Rua, Rui and Saraiva, Jo{\~a}o},
  year = {2017},
  pages = {1--8}
}

@inproceedings{crist_dask_2016-1,
  title = {Dask {{Numba}}: {{Simple}} Libraries for Optimizing Scientific Python Code},
  shorttitle = {Dask {{Numba}}},
  booktitle = {2016 {{IEEE International Conference}} on {{Big Data}} ({{Big Data}})},
  author = {Crist, James},
  year = {2016},
  month = dec,
  pages = {2342--2343},
  doi = {10.1109/BigData.2016.7840867},
  abstract = {Python is a high level language that is used by scientists for numeric computations. However, the performance of the language can be a hindrance when scaling to larger data sets, requiring some operations to be rewritten in a lower level language. To address this problem, we propose two libraries to allow numeric Python code to be optimized incrementally, requiring minimal changes. Here we describe Numba, a compiler for a subset of the Python language, and Dask, a flexible parallel programming library.},
  keywords = {Arrays,Big data,Complexity theory,Conferences,Dask \& Numba,data handling,data sets,flexible parallel programming library,high level language,high level languages,Instruction sets,libraries,Libraries,numeric computations,parallel programming,scientific Python code,software libraries,Syntactics},
  file = {/Users/chakibbelgaid/Zotero/storage/WIX66XKX/Crist - 2016 - Dask Numba Simple libraries for optimizing scient.pdf;/Users/chakibbelgaid/Zotero/storage/3VWCBI37/7840867.html;/Users/chakibbelgaid/Zotero/storage/W898H76Z/7840867.html}
}

@inproceedings{cruz_leafactor_2017,
  title = {Leafactor: {{Improving Energy Efficiency}} of {{Android Apps}} via {{Automatic Refactoring}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 4th {{International Conference}} on {{Mobile Software Engineering}} and {{Systems}} ({{MOBILESoft}})},
  author = {Cruz, L. and Abreu, R. and Rouvignac, J.},
  year = {2017},
  month = may,
  pages = {205--206},
  doi = {10.1109/MOBILESoft.2017.21},
  keywords = {Android (operating system),Android apps,Androids,automatic refactoring,energy consumption,energy efficiency,Engines,Green Computing,Humanoid robots,Java,Leafactor,Mobile Computing,Optimization,power aware computing,Refactoring,software maintenance,source code (software),source code refactoring,Tools,XML}
}

@inproceedings{cruz_performance-based_2017-1,
  ids = {DBLP:conf/icse/CruzA17},
  title = {Performance-{{Based Guidelines}} for {{Energy Efficient Mobile Applications}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 4th {{International Conference}} on {{Mobile Software Engineering}} and {{Systems}} ({{MOBILESoft}})},
  author = {Cruz, L. and Abreu, R.},
  year = {2017},
  month = may,
  pages = {46--57},
  doi = {10.1109/MOBILESoft.2017.19},
  abstract = {Mobile and wearable devices are nowadays the de facto personal computers, while desktop computers are becoming less popular. Therefore, it is important for companies to deliver efficient mobile applications. As an example, Google has published a set of best practices to optimize the performance of Android applications. However, these guidelines fall short to address energy consumption. As mobile software applications operate in resource-constrained environments, guidelines to build energy efficient applications are of utmost importance. In this paper, we studied whether or not a set of best performance-based practices have an impact on the energy consumed by Android applications. In an experimental study with six popular mobile applications, we observed that the battery of the mobile device can last up to approximately an extra hour if the applications are developed with energy-aware practices. This work paves the way for a set of guidelines for energy-aware automatic refactoring techniques.},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/icse/CruzA17.bib},
  keywords = {Android applications,Androids,Anti patterns,energy conservation,energy consumption,Energy consumption,energy efficient applications,energy efficient mobile applications,energy-aware automatic refactoring,energy-aware practices,Green Computing,Humanoid robots,Mobile applications,Mobile communication,mobile computing,Mobile Computing,mobile device battery,Mobile handsets,mobile software applications,Performance evaluation,performance-based guidelines,performance-based practices,personal computers,power aware computing,resource-constrained environments,wearable devices},
  note = {the structure of the paper :
\par
\begin{itemize}

\item a clear abstract of what they will present

\item introduction :

\begin{itemize}

\item ~~~ motivation behind : statistics about the amount of~ android users - using stackoverflow to show the need of those optimizations by developers

\item ~~~ RQs :

\end{itemize}

\item ~~~ the contributions of this paper

\item ~~~ related work : what is used ? and \textbf{why this one is different from the state of art (}\emph{ in general they say : we are aware that other works have been done in this field which enhance the usefulness and the pertinence of the subject , but our~ work is still new because wee covered what has not been covered by the other works relatives to this field )~}

\item Empirical study : we describe our methodology and explain our choices :

\begin{itemize}

\item ~~~ the choice of the testes

\item the number of experimentation used in this case

\item the testing process

\item the distribution of the result ( test of shapiro wilk )

\item the normalized data

\end{itemize}

\item data analyses : we show the data and the graphs and the tables and some magic figures to blow the mind of the reader x)

\item discussion : here we show the results of our tests and discuss the impact in the real cases

\begin{itemize}

\item ~~~ we answer the RQs too~

\end{itemize}

\item Threats of the validity :

\begin{itemize}

\item ~~~ we show that we are aware of the uncertainty of the result and the experimentation itself due to external factors and even tho we can still take conclusions , otherwise our study has no need

\end{itemize}

\item Conclusion :

\begin{itemize}

\item ~~~ remembering the impact of the subject and this study in the real world

\item ~~~ a brief description of the study

\item ~~~ adding some ideas of future works about this study

\end{itemize}

\end{itemize}

\par
the structure of the paper : 

\par
\begin{itemize}
 
\item a clear abstract of what they will present 
\item introduction : 

\begin{itemize}
 
\item     motivation behind : statistics about the amount of  android users - using stackoverflow to show the need of those optimizations by developers 
\item     RQs : 

\end{itemize}
 
\item     the contributions of this paper 
\item     related work : what is used ? and \textbf{why this one is different from the state of art (}\emph{ in general they say : we are aware that other works have been done in this field which enhance the usefulness and the pertinence of the subject , but our  work is still new because wee covered what has not been covered by the other works relatives to this field ) } 
\item Empirical study : we describe our methodology and explain our choices : 

\begin{itemize}
 
\item     the choice of the testes 
\item the number of experimentation used in this case 
\item the testing process 
\item the distribution of the result ( test of shapiro wilk ) 
\item the normalized data 

\end{itemize}
 
\item data analyses : we show the data and the graphs and the tables and some magic figures to blow the mind of the reader x) 
\item discussion : here we show the results of our tests and discuss the impact in the real cases 

\begin{itemize}
 
\item     we answer the RQs too  

\end{itemize}
 
\item Threats of the validity : 

\begin{itemize}
 
\item     we show that we are aware of the uncertainty of the result and the experimentation itself due to external factors and even tho we can still take conclusions , otherwise our study has no need 

\end{itemize}
 
\item Conclusion : 

\begin{itemize}
 
\item     remembering the impact of the subject and this study in the real world 
\item     a brief description of the study 
\item     adding some ideas of future works about this study 

\end{itemize}
 

\end{itemize}},
  timestamp = {Wed, 16 Oct 2019 14:14:49 +0200},
  file = {/Users/chakibbelgaid/Zotero/storage/JA4NR4RC/Cruz and Abreu - 2017 - Performance-Based Guidelines for Energy Efficient .pdf;/Users/chakibbelgaid/Zotero/storage/JIZSQYDP/7972717.html;/Users/chakibbelgaid/Zotero/storage/KC4HAL8M/7972717.html}
}

@inproceedings{DaCapo:paper,
  title = {The {{DaCapo}} Benchmarks: {{Java}} Benchmarking Development and Analysis},
  booktitle = {{{OOPSLA}} '06: {{Proceedings}} of the 21st Annual {{ACM SIGPLAN}} Conference on Object-Oriented Programing, Systems, Languages, and Applications},
  author = {Blackburn, S. M. and Garner, R. and Hoffman, C. and Khan, A. M. and McKinley, K. S. and Bentzur, R. and Diwan, A. and Feinberg, D. and Frampton, D. and Guyer, S. Z. and Hirzel, M. and Hosking, A. and Jump, M. and Lee, H. and Moss, J. E. B. and Phansalkar, A. and Stefanovi{\'c}, D. and VanDrunen, T. and {von Dincklage}, D. and Wiedermann, B.},
  year = {2006},
  month = oct,
  pages = {169--190},
  publisher = {{ACM Press}},
  address = {{New York, NY, USA}},
  doi = {http://doi.acm.org/10.1145/1167473.1167488}
}

@article{dayarathna_data_2016-1,
  title = {Data {{Center Energy Consumption Modeling}}: {{A Survey}}},
  shorttitle = {Data {{Center Energy Consumption Modeling}}},
  author = {Dayarathna, M. and Wen, Y. and Fan, R.},
  year = {Firstquarter 2016},
  journal = {IEEE Communications Surveys Tutorials},
  volume = {18},
  number = {1},
  pages = {732--794},
  issn = {1553-877X},
  doi = {10.1109/COMST.2015.2481183},
  abstract = {Data centers are critical, energy-hungry infrastructures that run large-scale Internet-based services. Energy consumption models are pivotal in designing and optimizing energy-efficient operations to curb excessive energy consumption in data centers. In this paper, we survey the state-of-the-art techniques used for energy consumption modeling and prediction for data centers and their components. We conduct an in-depth study of the existing literature on data center power modeling, covering more than 200 models. We organize these models in a hierarchical structure with two main branches focusing on hardware-centric and software-centric power models. Under hardware-centric approaches we start from the digital circuit level and move on to describe higher-level energy consumption models at the hardware component level, server level, data center level, and finally systems of systems level. Under the software-centric approaches we investigate power models developed for operating systems, virtual machines and software applications. This systematic approach allows us to identify multiple issues prevalent in power modeling of different levels of data center systems, including: i) few modeling efforts targeted at power consumption of the entire data center ii) many state-of-the-art power models are based on a few CPU or server metrics, and iii) the effectiveness and accuracy of these power models remain open questions. Based on these observations, we conclude the survey by describing key challenges for future research on constructing effective and accurate data center power models.},
  keywords = {cloud computing,Cloud Computing,Computational modeling,computer centres,Data center,Data Center,data center energy consumption modeling,data center power modeling,Data models,digital circuit level,energy consumption,Energy consumption,energy consumption modeling,Energy Consumption Modeling,energy efficiency,Energy Efficiency,energy-efficient operations,energy-hungry infrastructures,hardware component level,hardware-centric power models,hierarchical structure,Internet,large-scale Internet-based services,Mathematical model,operating systems,operating systems (computers),power aware computing,Power demand,Predictive models,server level,Servers,software-centric power models,telecommunication power management,virtual machines},
  file = {/Users/chakibbelgaid/Zotero/storage/MXUGL597/Dayarathna et al. - 2016 - Data Center Energy Consumption Modeling A Survey.pdf;/Users/chakibbelgaid/Zotero/storage/9TCTVPR6/7279063.html;/Users/chakibbelgaid/Zotero/storage/Z539HCFX/7279063.html}
}

@inproceedings{DBLP:conf/oopsla/KaliberaMJV12,
  title = {A Black-Box Approach to Understanding Concurrency in {{DaCapo}}},
  booktitle = {Proceedings of the 27th Annual {{ACM SIGPLAN}} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {{OOPSLA}} 2012, Part of {{SPLASH}} 2012, Tucson, {{AZ}}, {{USA}}, October 21-25, 2012},
  author = {Kalibera, Tomas and Mole, Matthew and Jones, Richard E. and Vitek, Jan},
  editor = {Leavens, Gary T. and Dwyer, Matthew B.},
  year = {2012},
  pages = {335--354},
  publisher = {{ACM}},
  doi = {10.1145/2384616.2384641},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/oopsla/KaliberaMJV12.bib},
  timestamp = {Tue, 06 Nov 2018 16:57:16 +0100}
}

@inproceedings{DBLP:conf/pldi/ProkopecRLD0SBZ19,
  ids = {renaissance},
  title = {Renaissance: Benchmarking Suite for Parallel Applications on the {{JVM}}},
  booktitle = {{{PLDI}}},
  author = {Prokopec, Aleksandar and Ros{\`a}, Andrea and Leopoldseder, David and Duboscq, Gilles and Tuma, Petr and Studener, Martin and Bulej, Lubom{\'i}r and Zheng, Yudi and Villaz{\'o}n, Alex and Simon, Doug and W{\"u}rthinger, Thomas and Binder, Walter},
  year = {2019},
  pages = {31--47},
  publisher = {{ACM}},
  address = {{Phoenix, AZ, USA}},
  keywords = {benchmarks,Big Data benchmarks,concurrency,functional programming benchmarks,JIT compilation,JVM,object-oriented programming benchmarks,parallelism}
}

@inproceedings{DBLP:conf/seke/ParkHL14,
  title = {Investigation for Software Power Consumption of Code Refactoring Techniques},
  booktitle = {The 26th International Conference on Software Engineering and Knowledge Engineering, Hyatt Regency, Vancouver, {{BC}}, Canada, July 1-3, 2013},
  author = {Park, Jae Jin and Hong, Jang-Eui and Lee, Sang-Ho},
  editor = {Reformat, Marek},
  year = {2014},
  pages = {717--722},
  publisher = {{Knowledge Systems Institute Graduate School}},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/seke/ParkHL14.bib},
  timestamp = {Thu, 12 Mar 2020 11:30:50 +0100}
}

@inproceedings{DBLP:conf/wosp/LengauerBMW17,
  title = {A Comprehensive Java Benchmark Study on Memory and Garbage Collection Behavior of {{DaCapo}}, {{DaCapo}} Scala, and {{SPECjvm2008}}},
  booktitle = {Proceedings of the 8th {{ACM}}/{{SPEC}} on International Conference on Performance Engineering, {{ICPE}} 2017, {{L}}'{{Aquila}}, Italy, April 22-26, 2017},
  author = {Lengauer, Philipp and Bitto, Verena and M{\"o}ssenb{\"o}ck, Hanspeter and Weninger, Markus},
  editor = {Binder, Walter and Cortellessa, Vittorio and Koziolek, Anne and Smirni, Evgenia and Poess, Meikel},
  year = {2017},
  pages = {3--14},
  publisher = {{ACM}},
  doi = {10.1145/3030207.3030211},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/wosp/LengauerBMW17.bib},
  timestamp = {Sun, 25 Oct 2020 22:36:34 +0100}
}

@article{DBLP:journals/corr/abs-1801-04329,
  title = {Effect of Meltdown and Spectre Patches on the Performance of {{HPC}} Applications},
  author = {Simakov, Nikolay A. and Innus, Martins D. and Jones, Matthew D. and White, Joseph P. and Gallo, Steven M. and DeLeon, Robert L. and FOPTurlani, Thomas R.},
  year = {2018},
  journal = {CoRR},
  volume = {abs/1801.04329},
  eprint = {1801.04329},
  eprinttype = {arxiv},
  archiveprefix = {arXiv},
  bibopturl = {https://dblp.org/rec/bib/journals/corr/abs-1801-04329},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  opturl = {http://arxiv.org/abs/1801.04329},
  timestamp = {Mon, 13 Aug 2018 16:47:49 +0200}
}

@article{DBLP:journals/jss/ColmantRKSFS18,
  ids = {colmant2018next},
  title = {The next 700 {{CPU}} Power Models},
  author = {Colmant, Maxime and Rouvoy, Romain and Kurpicz, Mascha and Sobe, Anita and Felber, Pascal and Seinturier, Lionel},
  year = {2018},
  journal = {Journal of Systems and Software},
  volume = {144},
  publisher = {{Elsevier}},
  optpages = {382\textendash 396}
}

@article{DBLP:journals/scp/WurthingerWS13,
  title = {Unrestricted and Safe Dynamic Code Evolution for {{Java}}},
  author = {W{\"u}rthinger, Thomas and Wimmer, Christian and Stadler, Lukas},
  year = {2013},
  journal = {Science of Computer Programming},
  volume = {78},
  number = {5},
  pages = {481--498}
}

@article{DBLP:journals/tse/MoralesSKCA18,
  title = {{{EARMO}}: {{An}} Energy-Aware Refactoring Approach for Mobile Apps},
  author = {Morales, Rodrigo and Saborido, Rub{\'e}n and Khomh, Foutse and Chicano, Francisco and Antoniol, Giuliano},
  year = {2018},
  journal = {IEEE Trans. Software Eng.},
  volume = {44},
  number = {12},
  pages = {1176--1206},
  doi = {10.1109/TSE.2017.2757486},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/journals/tse/MoralesSKCA18.bib},
  timestamp = {Wed, 26 Dec 2018 19:52:11 +0100}
}

@inproceedings{de2021empirical,
  title = {An Empirical Study about the Adoption of Multi-Language Technique in Computation Offloading in a Mobile Cloud Computing Scenario.},
  booktitle = {{{CLOSER}}},
  author = {{de Matos}, Filipe Fernandes SB and Rego, Paulo AL and Trinta, Fernando Antonio Mota},
  year = {2021},
  pages = {207--214}
}

@inproceedings{destefanis_statistical_2016-1,
  title = {A {{Statistical Comparison}} of {{Java}} and {{Python Software Metric Properties}}},
  booktitle = {Proceedings of the 7th {{International Workshop}} on {{Emerging Trends}} in {{Software Metrics}}},
  author = {Destefanis, Giuseppe and Ortu, Marco and Porru, Simone and Swift, Stephen and Marchesi, Michele},
  year = {2016},
  series = {{{WETSoM}} '16},
  pages = {22--28},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2897695.2897697},
  abstract = {This paper presents a statistical analysis of 20 opens ource object-oriented systems with the purpose of detecting differences in metrics distribution between Java and Python projects. We selected ten Java projects from the Java Qualitas Corpus and ten projects written in Python. For each system, we considered 10 class-level software metrics. We performed a best fit procedure on the empirical distributions through the log-normal distribution and the double Pareto distribution to identify differences between the two languages. Even though the statistical distributions for projects written in Java and Python may appear the same for lower values of the metric, performing the procedure with the double Pareto distribution for the Number of Local Methods metric reveals that major differences can be noticed along the queue of the distributions. On the contrary, the same analysis performed with the Number of Statements metric reveals that only the initial portion of the double Pareto distribution shows differences between the two languages. In addition, the dispersion parameter associated to the log-normal distribution fit for the total Number Of Methods can be used for distinguishing Java projects from Python projects.},
  isbn = {978-1-4503-4177-6},
  file = {/Users/chakibbelgaid/Zotero/storage/XX3ZYP9E/Destefanis et al. - 2016 - A Statistical Comparison of Java and Python Softwa.pdf}
}

@inproceedings{deutsch_efficient_1984-1,
  title = {Efficient {{Implementation}} of the {{Smalltalk-80 System}}},
  booktitle = {Proceedings of the 11th {{ACM SIGACT-SIGPLAN Symposium}} on {{Principles}} of {{Programming Languages}}},
  author = {Deutsch, L. Peter and Schiffman, Allan M.},
  year = {1984},
  series = {{{POPL}} '84},
  pages = {297--302},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/800017.800542},
  abstract = {The Smalltalk-80* programming language includes dynamic storage allocation, full upward funargs, and universally polymorphic procedures; the Smalltalk-80 programming system features interactive execution with incremental compilation, and implementation portability. These features of modern programming systems are among the most difficult to implement efficiently, even individually. A new implementation of the Smalltalk-80 system, hosted on a small microprocessor-based computer, achieves high performance while retaining complete (object code) compatibility with existing implementations. This paper discusses the most significant optimization techniques developed over the course of the project, many of which are applicable to other languages. The key idea is to represent certain runtime state (both code and data) in more than one form, and to convert between forms when needed.},
  isbn = {978-0-89791-125-2},
  file = {/Users/chakibbelgaid/Zotero/storage/8L7AZLJM/Deutsch and Schiffman - 1984 - Efficient Implementation of the Smalltalk-80 Syste.pdf}
}

@inproceedings{diouri_your_2013-1,
  ids = {diouri2013your},
  title = {Your Cluster Is Not Power Homogeneous: {{Take}} Care When Designing Green Schedulers!},
  shorttitle = {Your Cluster Is Not Power Homogeneous},
  booktitle = {2013 {{International Green Computing Conference Proceedings}}},
  author = {Diouri, M. El Mehdi and Gl{\"u}ck, O. and Lef{\`e}vre, L. and Mignot, J.},
  year = {2013},
  month = jun,
  pages = {1--10},
  doi = {10.1109/IGCC.2013.6604506},
  abstract = {Future supercomputers will consume enormous amounts of energy. These very large scale systems will gather many homogeneous clusters. In this paper, we analyze the power consumption of the nodes from different homogeneous clusters during different workloads. We classically observe that these nodes exhibit the same level of performance. But we also show that different nodes from a homogeneous cluster may exhibit heterogeneous idle power energy consumption even if they are made of identical hardware. Hence, we propose an experimental methodology to understand such differences. We show that CPUs are responsible for such heterogeneity which can reach 20\% in terms of energy consumption. So energy aware (Green) schedulers must take care of such hidden heterogeneity in order to propose efficient mapping of tasks. To consume less energy, we propose an energy-aware scheduling approach taking into account the heterogeneous idle power consumption of homogeneous nodes. It shows that we are able to save energy up to 17\% while exploiting the high power heterogeneity that may exist in some homogeneous clusters.},
  organization = {{IEEE}},
  keywords = {Benchmark testing,CPU,Dispersion,Energy consumption,energy-aware scheduling approach,green schedulers,Hardware,heterogeneous idle power energy consumption,homogeneous clusters,HPC applications,parallel machines,parallel processing,power consumption,Power demand,Power measurement,scheduling,supercomputers,very large scale systems,Wattmeters},
  file = {/Users/chakibbelgaid/Zotero/storage/VTZU43NV/Diouri et al. - 2013 - Your cluster is not power homogeneous Take care w.pdf;/Users/chakibbelgaid/Zotero/storage/IIAVF9ND/6604506.html;/Users/chakibbelgaid/Zotero/storage/PY695K25/6604506.html}
}

@inproceedings{echtler_open_2018,
  title = {Open {{Source}}, {{Open Science}}, and the {{Replication Crisis}} in {{HCI}}},
  booktitle = {Extended {{Abstracts}} of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Echtler, Florian and H{\"a}u{\ss}ler, Maximilian},
  year = {2018},
  month = apr,
  pages = {1--8},
  publisher = {{ACM}},
  address = {{Montreal QC Canada}},
  doi = {10.1145/3170427.3188395},
  abstract = {The open-source model of software development is an established and widely used method that has been making inroads into several scientific disciplines which use software, thereby also helping much-needed efforts at replication of scientific results. However, our own discipline of HCI does not seem to follow this trend so far. We analyze the entire body of papers from CHI 2016 and CHI 2017 regarding open-source releases, and compare our results with the discipline of bioinformatics. Based on our comparison, we suggest future directions for publication practices in HCI in order to improve scientific rigor and replicability.},
  isbn = {978-1-4503-5621-3},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/P7LEKXDM/Echtler and Häußler - 2018 - Open Source, Open Science, and the Replication Cri.pdf}
}

@misc{echtler2018open,
  title = {Open Source, Open Science, and the Replication Crisis in {{HCI}}. {{Association}} for Computing Machinery, New York, {{NY}}, {{USA}}, 1\textendash 8},
  author = {Echtler, Florian and H{\"a}u{\ss}ler, Maximilian},
  year = {2018}
}

@article{eddie_antonio_santos_how,
  title = {How Does Docker Affect Energy Consumption? {{Evaluating}} Workloads in and out of {{Docker}} Containers},
  author = {{Eddie Antonio Santos} and {Carson McLean} and {Christophr Solinas} and {Abram Hindle}},
  year = {2017},
  journal = {The journal of systems \& Software},
  optabstract = {Context: Virtual machines provide isolation of services at the cost of hypervisors and more resource usage. This spurred the growth of systems like Docker that enable single hosts to isolate several applications, similar to VMs, within a low-overhead OPTabstraction called containers. Motivation: Although containers tout low overhead performance, how much do they increase energy use? Methodology: This work statistically compares the energy consumption of three application workloads in Docker and on bare-metal Linux. Results: In all cases, there was a statistically significant (t-test and Wilcoxon p {$<$} .05) increase in energy consumption when running tests in Docker, mostly due to the performance of I/O system calls. Developers worried about I/O overhead could consider baremetal deployments over Docker container deployments.},
  keywords = {Read}
}

@article{efron2000bootstrap,
  title = {The Bootstrap and Modern Statistics},
  author = {Efron, Bradley},
  year = {2000},
  journal = {Journal of the American Statistical Association},
  volume = {95},
  number = {452},
  publisher = {{Taylor \& Francis Group}},
  optpages = {1293\textendash 1296}
}

@article{fahad2019comparative,
  title = {A Comparative Study of Methods for Measurement of Energy of Computing},
  author = {Fahad, Muhammad and Shahid, Arsalan and Manumachu, Ravi Reddy and Lastovetsky, Alexey},
  year = {2019},
  journal = {Energies},
  volume = {12},
  number = {11},
  pages = {2204},
  publisher = {{Multidisciplinary Digital Publishing Institute}}
}

@inproceedings{fernandes_assisting_2017-1,
  ids = {fernandes2017assisting},
  title = {Assisting {{Non-Specialist Developers}} to {{Build Energy-Efficient Software}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Fernandes, B. and Pinto, G. and Castor, F.},
  year = {2017},
  month = may,
  pages = {158--160},
  doi = {10.1109/ICSE-C.2017.133},
  abstract = {In this paper we introduce CECOTOOL, a tool that analyzes the energy behavior of alternative collection implementations and provides potentially useful recommendations about good implementation options. We applied it to two real-world software systems from the DaCapo suite [1], Xalan and Tomcat. With no prior knowledge of the application domains, we were able to reduce the energy consumption up to 4.37\%.},
  organization = {{IEEE}},
  keywords = {application domains,Benchmark testing,CECOTOOL,DaCapo suite,Data structures,energy behavior,energy conservation,energy consumption,Energy consumption,energy-efficient software,Java,nonspecialist developers,power aware computing,Read,software engineering,software systems,Software systems,Tomcat,Tools,Xalan},
  file = {/Users/chakibbelgaid/Zotero/storage/K4VATVGZ/Fernandes et al. - 2017 - Assisting Non-Specialist Developers to Build Energ.pdf;/Users/chakibbelgaid/Zotero/storage/C5DCIJ42/7965288.html;/Users/chakibbelgaid/Zotero/storage/VNKGLSSB/7965288.html}
}

@inproceedings{fieni2020smartwatts,
  title = {{{SmartWatts}}: {{Self-calibrating}} Software-Defined Power Meter for Containers},
  booktitle = {2020 20th {{IEEE}}/{{ACM}} International Symposium on Cluster, Cloud and Internet Computing ({{CCGRID}})},
  author = {Fieni, Guillaume and Rouvoy, Romain and Seinturier, Lionel},
  year = {2020},
  pages = {479--488},
  organization = {{IEEE}}
}

@inproceedings{fieni2021selfwatts,
  title = {{{SELFWATTS}}: {{On-the-fly}} Selection of Performance Events to Optimize Software-Defined Power Meters},
  booktitle = {2021 {{IEEE}}/{{ACM}} 21st International Symposium on Cluster, Cloud and Internet Computing ({{CCGrid}})},
  author = {Fieni, Guillaume and Rouvoy, Romain and Seiturier, Lionel},
  year = {2021},
  pages = {324--333},
  organization = {{IEEE}}
}

@article{friedley_high-performance_2009-1,
  title = {High-{{Performance Code Generation Using CorePy}}},
  author = {Friedley, Andrew and Mueller, Christopher and Lumsdaine, Andrew},
  year = {2009},
  pages = {6},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/BZQHD3LH/Friedley et al. - 2009 - High-Performance Code Generation Using CorePy.pdf}
}

@inproceedings{gajewski_analysis_2019-1,
  title = {Analysis and {{Comparison}} of the {{Spring Framework}} and {{Play Framework Performance}}, {{Used}} to {{Create Web Applications}} in {{Java}}},
  booktitle = {2019 {{IEEE XVth International Conference}} on the {{Perspective Technologies}} and {{Methods}} in {{MEMS Design}} ({{MEMSTECH}})},
  author = {Gajewski, M. and Zabierowski, W.},
  year = {2019},
  month = may,
  pages = {170--173},
  issn = {2573-5373},
  doi = {10.1109/MEMSTECH.2019.8817390},
  abstract = {In the era of continuous technological development, which is followed by the increase in the speed of computers and the Internet, it is also important to develop techniques and programming languages as well as various mechanisms helping programmers in their work. Therefore, the frameworks were created, or skeleton applications that define the application structure and the general mechanism of its operation, to facilitate writing programs and unify the structure of various applications. The purpose of this article is to analyze and compare the performance of two popular frameworks, used to create a server part of a web application in Java, namely the Spring Framework and Play Framework.},
  keywords = {application structure,Internet,Java,Jmeter,load tests,play framework performance,programming languages,skeleton applications,Spring Boot Play Framework,spring framework,Spring Framework,Web applications},
  file = {/Users/chakibbelgaid/Zotero/storage/9JCUG4DB/Gajewski and Zabierowski - 2019 - Analysis and Comparison of the Spring Framework an.pdf;/Users/chakibbelgaid/Zotero/storage/KUW657FS/8817390.html;/Users/chakibbelgaid/Zotero/storage/LRDKGU5B/8817390.html}
}

@article{garvin_introduction_2021-1,
  title = {An {{Introduction}} to {{Statistical Learning Springer Texts}} in {{Statistics An Introduction}} to {{Statistical Learning}}},
  author = {Garvin, Matthew},
  year = {2021},
  month = may,
  langid = {english}
}

@article{ge2009powerpack,
  title = {Powerpack: {{Energy}} Profiling and Analysis of High-Performance Systems and Applications},
  author = {Ge, Rong and Feng, Xizhou and Song, Shuaiwen and Chang, Hung-Ching and Li, Dong and Cameron, Kirk W},
  year = {2009},
  journal = {IEEE Transactions on Parallel and Distributed Systems},
  volume = {21},
  number = {5},
  pages = {658--671},
  publisher = {{IEEE}}
}

@article{gelenbe_impact_2015-1,
  title = {The {{Impact}} of {{Information Technology}} on {{Energy Consumption}} and {{Carbon Emissions}}},
  author = {Gelenbe, Erol and Caseau, Yves},
  year = {2015},
  month = jun,
  journal = {Ubiquity},
  volume = {2015},
  number = {June},
  pages = {1:1--1:15},
  issn = {1530-2180},
  doi = {10.1145/2755977},
  abstract = {In this article the authors evaluate the impact of different sectors of information and communication technologies (ICT) on energy consumption and CO2 emissions. ICT is understood to cover computer and peripheral equipment including local area networks, telecommunication equipment and networks, and data centers.},
  file = {/Users/chakibbelgaid/Zotero/storage/5EVHKXJC/Gelenbe and Caseau - 2015 - The Impact of Information Technology on Energy Con.pdf}
}

@article{goodman2016does,
  title = {What Does Research Reproducibility Mean?},
  author = {Goodman, Steven N and Fanelli, Daniele and Ioannidis, John PA},
  year = {2016},
  journal = {Science translational medicine},
  volume = {8},
  number = {341},
  pages = {341ps12--341ps12},
  publisher = {{American Association for the Advancement of Science}}
}

@article{gottschalk_energy-efficient_2013,
  title = {Energy-{{Efficient Code}} by {{Refactoring}}},
  author = {Gottschalk, Marion and Jelschen, Jan and Winter, Andreas},
  year = {2013},
  month = may,
  journal = {Softwaretechnik-Trends},
  volume = {33},
  number = {2},
  pages = {23--24},
  issn = {0720-8928},
  doi = {10.1007/s40568-013-0030-4},
  abstract = {The rising number of mobile devices increase the interest in longer battery durations. To increase battery duration, researchers try to improve e.g. different hardware components, such as processors and GPS for lower energy consumption. Frequently, software optimization possibilities to save energy are forgotten. Hence, an approach is shown to reduce energy consumption of applications by reengineering. Therefor, energy-wasteful code in applications is searched by code analysis and then restructured to optimize their energy consumption. Energy savings are validated by different energy measurements techniques.},
  langid = {english}
}

@inproceedings{grambow_benchmarking_2020-1,
  title = {Benchmarking Microservice Performance: A Pattern-Based Approach},
  shorttitle = {Benchmarking Microservice Performance},
  booktitle = {Proceedings of the 35th {{Annual ACM Symposium}} on {{Applied Computing}}},
  author = {Grambow, Martin and Meusel, Lukas and Wittern, Erik and Bermbach, David},
  year = {2020},
  month = mar,
  pages = {232--241},
  publisher = {{ACM}},
  address = {{Brno Czech Republic}},
  doi = {10.1145/3341105.3373875},
  abstract = {Benchmarking microservices serves to understand and check their non-functional properties for relevant workloads and over time. Performing benchmarks, however, can be costly: each microservice requires the design and implementation of a benchmark, possibly repeatedly as the service evolves. As microservice APIs differ, benchmarking tools that assume common interfaces \textendash{} like ones for databases \textendash{} do not exist.},
  isbn = {978-1-4503-6866-7},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/SFKTCPQ8/Grambow et al. - 2020 - Benchmarking microservice performance a pattern-b.pdf}
}

@incollection{grass_energy_2006,
  title = {An {{Energy Consumption Model}} for an {{Embedded Java Virtual Machine}}},
  booktitle = {Architecture of {{Computing Systems}} - {{ARCS}} 2006},
  author = {Lafond, S{\'e}bastien and Lilius, Johan},
  editor = {Grass, Werner and Sick, Bernhard and Waldschmidt, Klaus},
  year = {2006},
  volume = {3894},
  pages = {311--325},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/11682127_22},
  abstract = {In recent years we have seen an explosion of markets for portable electronic devices such as PDAs, personal communicators and mobile phones. The size and complexity of applications, but also development constraints like getting the product to market on time make the use of high-level languages like Java necessary. Java 2 Micro Edition (J2ME) has emerged as a good solution for developing applications on those platforms. The main goal of Java language is to allow applications development with an abstraction of the target platform, making the concept ``write once, run it anywhere'' possible. The Java Virtual machine (JVM) is an abstract machine, making the interface between platform independent applications and the hardware, through a possible operating system. Thus the use of Java language can be seen as adding one more layer, the Java virtual machine, between the hardware and software layers. In this paper we establish a general framework for estimating the energy consumption of an embedded Java virtual machine. We have designed a number of experiments to find the constants overhead of the Virtual Machine and establish energy consumption cost for individual Java Opcodes. The results show that there is a basic constant overhead that is equal for every Java program, and a that a subset of Java opcodes have an almost constant energy cost. We also show that memory access is a crucial energy consumption component.},
  isbn = {978-3-540-32765-3 978-3-540-32766-0},
  langid = {english}
}

@incollection{grid5000,
  title = {Adding Virtualization Capabilities to the {{Grid}}'5000 Testbed},
  booktitle = {Cloud Computing and Services Science},
  author = {Balouek, Daniel and Carpen Amarie, Alexandra and Charrier, Ghislain and Desprez, Fr{\'e}d{\'e}ric and Jeannot, Emmanuel and Jeanvoine, Emmanuel and L{\`e}bre, Adrien and Margery, David and Niclausse, Nicolas and Nussbaum, Lucas and Richard, Olivier and P{\'e}rez, Christian and Quesnel, Flavien and Rohr, Cyril and Sarzyniec, Luc},
  year = {2013},
  series = {Communications in Computer and Information Science},
  volume = {367},
  publisher = {{Springer}},
  optdoi = {10.1007/978-3-319-04519-1\_1},
  opteditor = {Ivanov, Ivan I. and van Sinderen, Marten and Leymann, Frank and Shan, Tony},
  optisbn = {978-3-319-04518-4},
  optpages = {3-20}
}

@article{guimaraes2016some,
  title = {Some Heuristic Approaches for Reducing Energy Consumption on Database Systems},
  author = {Guimar{\~a}es, Miguel and Saraiva, Jo{\~a}o and Belo, Orlando},
  year = {2016},
  journal = {DBKDA 2016},
  pages = {59}
}

@inproceedings{hackenberg_hdeem_2014,
  title = {{{HDEEM}}: {{High Definition Energy Efficiency Monitoring}}},
  shorttitle = {{{HDEEM}}},
  booktitle = {2014 {{Energy Efficient Supercomputing Workshop}}},
  author = {Hackenberg, Daniel and Ilsche, Thomas and Schuchart, Joseph and Sch{\"o}ne, Robert and Nagel, Wolfgang E. and Simon, Marc and Georgiou, Yiannis},
  year = {2014},
  month = nov,
  pages = {1--10},
  doi = {10.1109/E2SC.2014.13},
  abstract = {Accurate and fine-grained power measurements of computing systems are essential for energy-aware performance optimizations of HPC systems and applications. Although cluster wide instrumentation options are available, fine spatial granularity and temporal resolution are not supported by the system vendors and extra hardware is needed to capture the power consumption information. We introduce the High Definition Energy Efficiency Monitoring (HDEEM) infrastructure, a sophisticated approach towards systemwide and fine-grained power measurements that enable energy-aware performance optimizations of parallel codes. Our approach is targeted at instrumenting multiple HPC racks with power sensors that have a sampling rate of about 8 kSa/s as well as finer spatial granularity, e.g., for per-CPU measurements. We specifically focus on the correctness of power measurement samples and energy consumption calculations based on these power samples. We also discuss scalable and low-overhead or overhead-free options for online and offline (post-mortem) processing of power measurement data.},
  keywords = {Accuracy,Current measurement,Energy consumption,Energy measurement,Power demand,Power measurement,Sensors},
  file = {/Users/chakibbelgaid/Zotero/storage/P87MLMXA/Hackenberg et al. - 2014 - HDEEM High Definition Energy Efficiency Monitorin.pdf;/Users/chakibbelgaid/Zotero/storage/WT9435V9/7016382.html}
}

@inproceedings{hackenberg2013power,
  title = {Power Measurement Techniques on Standard Compute Nodes: {{A}} Quantitative Comparison},
  booktitle = {2013 {{IEEE}} International Symposium on Performance Analysis of Systems and Software ({{ISPASS}})},
  author = {Hackenberg, Daniel and Ilsche, Thomas and Sch{\"o}ne, Robert and Molka, Daniel and Schmidt, Maik and Nagel, Wolfgang E},
  year = {2013},
  pages = {194--204},
  organization = {{IEEE}}
}

@inproceedings{hackenberg2014hdeem,
  title = {{{HDEEM}}: High Definition Energy Efficiency Monitoring},
  booktitle = {2014 Energy Efficient Supercomputing Workshop},
  author = {Hackenberg, Daniel and Ilsche, Thomas and Schuchart, Joseph and Sch{\"o}ne, Robert and Nagel, Wolfgang E and Simon, Marc and Georgiou, Yiannis},
  year = {2014},
  pages = {1--10},
  organization = {{IEEE}}
}

@inproceedings{hackenberg2015energy,
  title = {An Energy Efficiency Feature Survey of the Intel Haswell Processor},
  booktitle = {2015 {{IEEE}} International Parallel and Distributed Processing Symposium Workshop},
  author = {Hackenberg, Daniel and Sch{\"o}ne, Robert and Ilsche, Thomas and Molka, Daniel and Schuchart, Joseph and Geyer, Robin},
  year = {2015},
  pages = {896--904},
  organization = {{IEEE}}
}

@article{hammouda_noise-tolerant_2015-1,
  title = {Noise-{{Tolerant Explicit Stencil Computations}} for {{Nonuniform Process Execution Rates}}},
  author = {Hammouda, Adam and Siegel, Andrew R. and Siegel, Stephen F.},
  year = {2015},
  month = apr,
  journal = {ACM Transactions on Parallel Computing},
  volume = {2},
  number = {1},
  pages = {1--33},
  issn = {23294949},
  doi = {10.1145/2742351},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/3Y6L2RSD/Hammouda et al. - 2015 - Noise-Tolerant Explicit Stencil Computations for N.pdf}
}

@article{harinadha_efficacious_2019-1,
  title = {An {{Efficacious Query Processing Approach}} with {{Predictive Energy Saving}} Using {{Online Scheduling}}},
  author = {Harinadha, Maragani and Shekhar, Chinthala},
  year = {2019},
  volume = {9},
  number = {3},
  pages = {7},
  abstract = {Web search engines are composed by thousands of query processing nodes, i.e., servers dedicated to process user queries. Such many servers consume a significant amount of energy, mostly accountable to their CPUs, but they are necessary to ensure low latencies, since users expect sub-second response times (e.g., 500 ms). However, users can hardly notice response times that are faster than their expectations. Hence, we propose the Predictive Energy Saving Online Scheduling Algorithm (PESOS) to select the most appropriate CPU frequency to process a query on a per-core basis. PESOS aim at process queries by their deadlines and leverage high-level scheduling information to reduce the CPU energy consumption of a query processing node. PESOS base its decision on query efficiency predictors, estimating the processing volume and processing time of a query. We experimentally evaluate PESOS upon the TREC ClueWeb09B collection and the MSN2006 query log. Results show that PESOS can reduce the CPU energy consumption of a query processing node up to {$\sim$}48\% compared to a system running at maximum CPU core frequency. PESOS outperform also the best state of the-art competitor with a {$\sim$}20\% energy saving, while the competitor requires a fine parameter tuning and it may incur in uncontrollable latency violations.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/4Q7JVA95/Harinadha and Shekhar - 2019 - An Efficacious Query Processing Approach with Pred.pdf}
}

@inproceedings{hasan_energy_2016-1,
  ids = {hasan2016energy},
  title = {Energy {{Profiles}} of {{Java Collections Classes}}},
  booktitle = {2016 {{IEEE}}/{{ACM}} 38th {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Hasan, S. and King, Z. and Hafiz, M. and Sayagh, M. and Adams, B. and Hindle, A.},
  year = {2016},
  month = may,
  pages = {225--236},
  doi = {10.1145/2884781.2884869},
  abstract = {We created detailed profiles of the energy consumed by common operations done on Java List, Map, and Set abstractions. The results show that the alternative data types for these abstractions differ significantly in terms of energy consumption depending on the operations. For example, an ArrayList consumes less energy than a LinkedList if items are inserted at the middle or at the end, but consumes more energy than a LinkedList if items are inserted at the start of the list. To explain the results, we explored the memory usage and the bytecode executed during an operation. Expensive computation tasks in the analyzed bytecode traces appeared to have an energy impact, but memory usage did not contribute. We evaluated our profiles by using them to selectively replace Collections types used in six applications and libraries. We found that choosing the wrong Collections type, as indicated by our profiles, can cost even 300\% more energy than the most efficient choice. Our work shows that the usage context of a data structure and our measured energy profiles can be used to decide between alternative Collections implementations.},
  keywords = {API,ArrayList,Collections,Encoding,Energy consumption,Energy measurement,Energy Profile,energy profiles,Java,Java collections classes,Java List,LinkedList,Semiconductor device measurement,Set abstractions,Software,Software engineering},
  file = {/Users/chakibbelgaid/Zotero/storage/M4QA9EIU/Hasan et al. - 2016 - Energy Profiles of Java Collections Classes.pdf;/Users/chakibbelgaid/Zotero/storage/BF7CAX4E/7886906.html;/Users/chakibbelgaid/Zotero/storage/CL3KSPMJ/7886906.html}
}

@inproceedings{he_statistics-based_2019-1,
  title = {A Statistics-Based Performance Testing Methodology for Cloud Applications},
  booktitle = {Proceedings of the 2019 27th {{ACM Joint Meeting}} on {{European Software Engineering Conference}} and {{Symposium}} on the {{Foundations}} of {{Software Engineering}}  - {{ESEC}}/{{FSE}} 2019},
  author = {He, Sen and Manns, Glenna and Saunders, John and Wang, Wei and Pollock, Lori and Soffa, Mary Lou},
  year = {2019},
  pages = {188--199},
  publisher = {{ACM Press}},
  address = {{Tallinn, Estonia}},
  doi = {10.1145/3338906.3338912},
  abstract = {The low cost of resource ownership and flexibility have led users to increasingly port their applications to the clouds. To fully realize the cost benefits of cloud services, users usually need to reliably know the execution performance of their applications. However, due to the random performance fluctuations experienced by cloud applications, the black box nature of public clouds and the cloud usage costs, testing on clouds to acquire accurate performance results is extremely difficult. In this paper, we present a novel cloud performance testing methodology called PT4Cloud. By employing non-parametric statistical approaches of likelihood theory and the bootstrap method, PT4Cloud provides reliable stop conditions to obtain highly accurate performance distributions with confidence bands. These statistical approaches also allow users to specify intuitive accuracy goals and easily trade between accuracy and testing cost. We evaluated PT4Cloud with 33 benchmark configurations on Amazon Web Service and Chameleon clouds. When compared with performance data obtained from extensive performance tests, PT4Cloud provides testing results with 95.4\% accuracy on average while reducing the number of test runs by 62\%. We also propose two test execution reduction techniques for PT4Cloud, which can reduce the number of test runs by 90.1\% while retaining an average accuracy of 91\%. We compared our technique to three other techniques and found that our results are much more accurate.},
  isbn = {978-1-4503-5572-8},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/CFIR8SXF/He et al. - 2019 - A statistics-based performance testing methodology.pdf}
}

@article{heinrich_predicting,
  title = {Predicting the {{Performance}} and the {{Power Consumption}} of {{MPI Applications With SimGrid}}},
  author = {Heinrich, Franz and {Carpen-Amarie}, Alexandra and Degomme, Augustin and Hunold, Sascha and Legrand, Arnaud and Orgerie, Anne-C{\'e}cile and Quinson, Martin},
  year = {2017},
  langid = {english},
  optabstract = {The past decade witnessed a rapid development of powerful but energy-hungry parallel and distributed systems, making energy efficiency of large data centers an important optimization goal. Simulation is a popular approach for studying the behavior of HPC applications in a variety of scenarios. However, simulators are infrequently able to provide faithful performance predictions of applications and typically lack the capability of providing details about the energy consumption of the simulated platforms, especially when comprised of multi-core architectures. Furthermore, studying the impact of different application configurations on energy consumption is a difficult task as only few platforms are equipped with proper power measurement devices. In this paper, we present an extension of the SimGrid simulation toolkit that OPTaddresses these challenges. We firstly introduce a model for application energy consumption that supports dynamic voltage/frequency scaling (DVFS) of simulated processors. Secondly, we discuss means to account for coarse-grain memory effects in multi-core architectures. The advantages of our approach, compared to cycle-level simulators, are faster simulation run times and enhanced scalability with, provided the target platform is correctly modeled, a retained excellent accuracy. We discuss our model in detail and demonstrate how it can be instantiated by profiling different applications during the calibration phase. Finally, the proposed simulator is validated through an extensive set of experiments with common HPC benchmarks.},
  optpages = {13}
}

@misc{heinrich_predicting_2017,
  title = {Predicting the {{Performance}} and the {{Power Consumption}} of {{MPI Applications With SimGrid}}},
  author = {Heinrich, Franz and {Carpen-Amarie}, Alexandra and Degomme, Augustin and Hunold, Sascha and Legrand, Arnaud and Orgerie, Anne-C{\'e}cile and Quinson, Martin},
  year = {2017},
  month = jan,
  abstract = {The past decade witnessed a rapid development of powerful but energy-hungry parallel and distributed systems, making energy efficiency of large data centers an important optimization goal. Simulation is a popular approach for studying the behavior of HPC applications in a variety of scenarios. However, simulators are infrequently able to provide faithful performance predictions of applications and typically lack the capability of providing details about the energy consumption of the simulated platforms, especially when comprised of multi-core architectures. Furthermore, studying the impact of different application configurations on energy consumption is a difficult task as only few platforms are equipped with proper power measurement devices. In this paper, we present an extension of the SimGrid simulation toolkit that addresses these challenges. We firstly introduce a model for application energy consumption that supports dynamic voltage/frequency scaling (DVFS) of simulated processors. Secondly, we discuss means to account for coarse-grain memory effects in multi-core architectures. The advantages of our approach, compared to cycle-level simula-tors, are faster simulation run times and enhanced scalability with, provided the target platform is correctly modeled, a retained excellent accuracy. We discuss our model in detail and demonstrate how it can be instantiated by profiling different applications during the calibration phase. Finally, the proposed simulator is validated through an extensive set of experiments with common HPC benchmarks.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/ETEUP9D2/Heinrich et al. - 2017 - Predicting the Performance and the Power Consumpti.pdf;/Users/chakibbelgaid/Zotero/storage/P6UFQQCN/hal-01446134.html}
}

@article{heinrich2017predicting,
  title = {Predicting the Performance and the Power Consumption of {{MPI}} Applications with {{SimGrid}}},
  author = {Heinrich, Franz and {Carpen-Amarie}, Alexandra and Degomme, Augustin and Hunold, Sascha and Legrand, Arnaud and Orgerie, Anne-C{\'e}cile and Quinson, Martin},
  year = {2017}
}

@inproceedings{hindle_greenminer_2014-1,
  ids = {hindle2014greenminer},
  title = {{{GreenMiner}}: {{A Hardware Based Mining Software Repositories Software Energy Consumption Framework}}},
  shorttitle = {{{GreenMiner}}},
  booktitle = {Proceedings of the 11th {{Working Conference}} on {{Mining Software Repositories}}},
  author = {Hindle, Abram and Wilson, Alex and Rasmussen, Kent and Barlow, E. Jed and Campbell, Joshua Charles and Romansky, Stephen},
  year = {2014},
  series = {{{MSR}} 2014},
  pages = {12--21},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2597073.2597097},
  abstract = {Green Mining is a field of MSR that studies software energy consumption and relies on software performance data. Unfortunately there is a severe lack of publicly available software power use performance data. This means that green mining researchers must generate this data themselves by writing tests, building multiple revisions of a product, and then running these tests multiple times (10+) for each software revision while measuring power use. Then, they must aggregate these measurements to estimate the energy consumed by the tests for each software revision. This is time consuming and is made more difficult by the constraints of mobile devices and their OSes. In this paper we propose, implement, and demonstrate Green Miner: the first dedicated hardware mining software repositories testbed. The Green Miner physically measures the energy consumption of mobile devices (Android phones) and automates the testing of applications, and the reporting of measurements back to developers and researchers. The Green Miner has already produced valuable results for commercial Android application developers, and has been shown to replicate other power studies' results.},
  isbn = {978-1-4503-2863-0},
  keywords = {Android,Software Change,Software Energy Consumption},
  file = {/Users/chakibbelgaid/Zotero/storage/I8NZXEJT/Hindle et al. - 2014 - GreenMiner A Hardware Based Mining Software Repos.pdf}
}

@article{hirst_watts_2013,
  title = {Watts {{Up}}? {{Pro AC Power Meter}} for {{Automated Energy Recording}}: {{A Product Review}}},
  shorttitle = {Watts {{Up}}?},
  author = {Hirst, Jason M. and Miller, Jonathan R. and Kaplan, Brent A. and Reed, Derek D.},
  year = {2013},
  month = jun,
  journal = {Behavior Analysis in Practice},
  volume = {6},
  number = {1},
  pages = {82--95},
  issn = {1998-1929, 2196-8934},
  doi = {10.1007/BF03391795},
  abstract = {U\^E The automation of permanent product recording is useful for both researchers and practitioners. U\^E Electronic or mechanical recording of data tends to be efficient, unobtrusive, and reliable. A product measure that is related to many human behaviors is the consumption of electricity, typically measured in watts or kilowatt hours.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/GS8RYQEE/Hirst et al. - 2013 - Watts Up Pro AC Power Meter for Automated Energy .pdf}
}

@misc{hirst2013watts,
  title = {Watts up? Pro Ac Power Meter for Automated Energy Recording},
  author = {Hirst, Jason M and Miller, Jonathan R and Kaplan, Brent A and Reed, Derek D},
  year = {2013},
  publisher = {{Springer}}
}

@article{howe_virtual_2012-1,
  title = {Virtual {{Appliances}}, {{Cloud Computing}}, and {{Reproducible Research}}},
  author = {Howe, Bill},
  year = {2012},
  month = jul,
  journal = {Computing in Science Engineering},
  volume = {14},
  number = {4},
  pages = {36--41},
  issn = {1558-366X},
  doi = {10.1109/MCSE.2012.62},
  abstract = {As science becomes increasingly computational, reproducibility has become increasingly difficult, perhaps surprisingly. In many contexts, virtualization and cloud computing can mitigate the issues involved without significant overhead to the researcher, enabling the next generation of rigorous and reproducible computational science.},
  keywords = {case studies in scientific applications,cloud computing,Cloud computing,Context awareness,Documentation,Information retrieval,information storage and retrieval,Reproducibility of results,reproducible results,Research and development,scientific computing,Scientific computing,services computing,Virtual machining},
  file = {/Users/chakibbelgaid/Zotero/storage/7X8YSW6D/Howe - 2012 - Virtual Appliances, Cloud Computing, and Reproduci.pdf;/Users/chakibbelgaid/Zotero/storage/9QLTYYWB/6193081.html;/Users/chakibbelgaid/Zotero/storage/F35AB4XS/6193081.html}
}

@misc{httpsplusgooglecom100601164815113053596_why_2018,
  title = {Why {{Are There So Many Pythons}}? {{A Python Implementation Comparison}}},
  shorttitle = {Why {{Are There So Many Pythons}}?},
  author = {{https://plus.google.com/100601164815113053596}},
  year = {2018},
  month = apr,
  abstract = {Starting from scratch, the author of this guide examines the various Python interfaces, implementations, and their characteristics.},
  file = {/Users/chakibbelgaid/Zotero/storage/YZPLXVAR/why-are-there-so-many-pythons.html}
}

@inproceedings{ilsche_power_2015-1,
  title = {Power Measurements for Compute Nodes: {{Improving}} Sampling Rates, Granularity and Accuracy},
  shorttitle = {Power Measurements for Compute Nodes},
  booktitle = {2015 {{Sixth International Green}} and {{Sustainable Computing Conference}} ({{IGSC}})},
  author = {Ilsche, Thomas and Hackenberg, Daniel and Graul, Stefan and Schone, Robert and Schuchart, Joseph},
  year = {2015},
  month = dec,
  pages = {1--8},
  publisher = {{IEEE}},
  address = {{Las Vegas, NV, USA}},
  doi = {10.1109/IGCC.2015.7393710},
  abstract = {Energy efficiency is a key optimization goal for software and hardware in the High Performance Computing (HPC) domain. This necessitates sophisticated power measurement capabilities that are characterized by the key criteria (i) high sampling rates, (ii) measurement of individual components, (iii) well-defined accuracy, and (iv) high scalability. In this paper, we tackle the first three of these goals and describe the instrumentation of two high-end compute nodes with three different current measurement techniques: (i) Hall effect sensors, (ii) measuring shunts in extension cables and riser cards, and (iii) tapping into the voltage regulators. The resulting measurement data for components such as sockets, PCIe cards, and DRAM DIMMs is digitized at sampling rates from 7 kSa/s up to 500 kSa/s, enabling a fine-grained correlation between power usage and application events. The accuracy of all elements in the measurement infrastructure is studied carefully. Moreover, potential pitfalls in building custom power instrumentation are discussed. We raise the awareness for the properties of power measurements, as disregarding existing inaccuracies can lead to invalid conclusions regarding energy efficiency.},
  isbn = {978-1-5090-0172-9},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/PBJIQRBK/Ilsche et al. - 2015 - Power measurements for compute nodes Improving sa.pdf}
}

@inproceedings{imes_copper_2019-1,
  title = {{{CoPPer}}: {{Soft Real-Time Application Performance Using Hardware Power Capping}}},
  shorttitle = {{{CoPPer}}},
  booktitle = {2019 {{IEEE International Conference}} on {{Autonomic Computing}} ({{ICAC}})},
  author = {Imes, C. and Zhang, H. and Zhao, K. and Hoffmann, H.},
  year = {2019},
  month = jun,
  pages = {31--41},
  doi = {10.1109/ICAC.2019.00015},
  abstract = {Dynamic voltage and frequency scaling (DVFS) has been the cornerstone of innumerable software approaches to meeting application timing requirements with minimal energy. However, recent trends in technology-e.g., moving voltage converters on chip-favor hardware control of DVFS, as hardware can both react faster to external events and perform fine-grained power management across a device. We respond to these trends with CoPPer, which instead uses hardware power capping to meet application performance requirements with high energy efficiency. We find that meeting performance requirements with power capping is more challenging than using DVFS because the relationship between power and performance is non-linear and has diminishing returns at high power values. CoPPer overcomes these difficulties by using adaptive control to approximate non-linearities and a novel gain limit to avoid over-allocating power when it is no longer beneficial. We evaluate CoPPer with 20 parallel applications and compare it to both a classic linear DVFS controller and to a sophisticated control-theoretic, model-driven software DVFS manager. CoPPer provides all the functionality of the sophisticated DVFS-based approach, without requiring a user-specified model or time-consuming, exhaustive application/system pre-characterization. Compared to DVFS, CoPPer's gain limit reduces energy by 6\% on average and by 12\% for memory-bound applications. For high performance requirements, the energy savings are even greater: 8\% on average and 18\% for memory-bound applications.},
  keywords = {adaptive control,application timing requirements,chip-favor hardware control,Computational modeling,control theory,Copper,CoPPer,dvfs,dynamic voltage and frequency scaling,energy conservation,energy efficiency,fine-grained power management,Hardware,hardware power capping,linear DVFS controller,Market research,memory-bound applications,minimal energy,model-driven software DVFS manager,multiprocessing systems,parallel applications,performance,power aware computing,power cap,Power demand,rapl,self aware systems,soft real-time application performance,Software,sophisticated DVFS-based approach,Timing,voltage converters},
  file = {/Users/chakibbelgaid/Zotero/storage/USUAKL49/Imes et al. - 2019 - CoPPer Soft Real-Time Application Performance Usi.pdf;/Users/chakibbelgaid/Zotero/storage/QPJU95BF/8831193.html;/Users/chakibbelgaid/Zotero/storage/RWZDWXG5/8831193.html}
}

@inproceedings{imminni_spyse_2016-1,
  title = {{{SPYSE}}: {{A Semantic Search Engine}} for {{Python Packages}} and {{Modules}}},
  shorttitle = {{{SPYSE}}},
  booktitle = {Proceedings of the 38th {{International Conference}} on {{Software Engineering Companion}}},
  author = {Imminni, Shiva Krishna and Hasan, Mir Anamul and Duckett, Michael and Sachdeva, Puneet and Karmakar, Sudipta and Kumar, Piyush and Haiduc, Sonia},
  year = {2016},
  series = {{{ICSE}} '16},
  pages = {625--628},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2889160.2889174},
  abstract = {Code reuse is a common practice among software developers, whether novices or experts. Developers often rely on online resources in order to find code to reuse. For Python, the Python Package Index (PyPI) contains all packages developed for the community and is the largest catalog of reusable, open source packages developers can consult. While a valuable resource, the state of the art PyPI search has very limited capabilities, making it hard for developers to find useful, high quality Python code to use for their task at hand. We introduce SPYSE (Semantic PYthon Search Engine), a web-based search engine that overcomes the limitations of the state of the art, making it easier for developers to find useful code. The power of SPYSE lays in the combination of three different aspects meant to provide developers with relevant, and at the same time high quality code: code semantics, popularity, and code quality. SPYSE also allows searching for modules, in addition to packages, which opens new reuse opportunities for developers, currently not supported. TOOL URL: https://pypi.compgeom.com VIDEO URL: https://youtu.be/Praglw-vS50},
  isbn = {978-1-4503-4205-6},
  keywords = {code reuse,Python,recommender systems,search engine},
  file = {/Users/chakibbelgaid/Zotero/storage/WKNXRPRS/Imminni et al. - 2016 - SPYSE A Semantic Search Engine for Python Package.pdf}
}

@inproceedings{inadomi2015analyzing,
  title = {Analyzing and Mitigating the Impact of Manufacturing Variability in Power-Constrained Supercomputing},
  booktitle = {{{SC}}'15: {{Proceedings}} of the International Conference for High Performance Computing, Networking, Storage and Analysis},
  author = {Inadomi, Yuichi and Patki, Tapasya and Inoue, Koji and Aoyagi, Mutsumi and Rountree, Barry and Schulz, Martin and Lowenthal, David and Wada, Yasutaka and Fukazawa, Keiichiro and Ueda, Masatsugu and others},
  year = {2015},
  pages = {1--12},
  organization = {{IEEE}}
}

@inproceedings{islam2016measuring,
  title = {Measuring Energy Footprint of Software Features},
  booktitle = {2016 {{IEEE}} 24th International Conference on Program Comprehension ({{ICPC}})},
  author = {Islam, Syed and Noureddine, Adel and Bashroush, Rabih},
  year = {2016},
  pages = {1--4},
  organization = {{IEEE}}
}

@inproceedings{jabbarvand_advancing_2017-1,
  title = {Advancing {{Energy Testing}} of {{Mobile Applications}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Jabbarvand, R. and Malek, S.},
  year = {2017},
  month = may,
  pages = {491--492},
  doi = {10.1109/ICSE-C.2017.45},
  abstract = {The rising popularity of mobile apps deployed on battery-constrained devices has motivated the need for effective energy-aware testing techniques. However, currently there is a lack of test generation tools for exercising the energy properties of apps. Automated test generation is not useful without tools that help developers to measure the quality of the tests. Additionally, the collection of tests generated for energy testing could be quite large, as it may involve a test suite that covers all the energy hotspots under different use cases. Thereby, there is a need for techniques to manage the size of test suite, while maintaining its effectiveness in revealing energy defects. Our research plan to advance energy testing for mobile applications include various techniques for energy-aware test generation, energy-aware test-suite adequacy assessment, and energy-aware test-suite minimization.},
  keywords = {Android,Androids,battery-constrained devices,Energy Consumption,energy defects,Energy measurement,energy-aware test generation,energy-aware test-suite adequacy assessment,energy-aware test-suite minimization,energy-aware testing techniques,Green Software Engineering,Humanoid robots,Minimization,mobile applications,Mobile communication,mobile computing,Mutation Testing,power aware computing,program testing,Software Testing,Test suite Minimization,Testing,Tools},
  file = {/Users/chakibbelgaid/Zotero/storage/2CIQK3JK/Jabbarvand and Malek - 2017 - Advancing Energy Testing of Mobile Applications.pdf;/Users/chakibbelgaid/Zotero/storage/35QJPWNG/7965399.html;/Users/chakibbelgaid/Zotero/storage/MSFWF4AE/7965399.html}
}

@inproceedings{jae-jin_park_investigation_2014,
  title = {Investigation for {{Software Power Consumption}} of {{Code Refactoring Techniques}}},
  booktitle = {{{SEKE}}},
  author = {{Jae-Jin Park} and {Jang-Eui Hong} and {Sang-Ho Lee}},
  year = {2014},
  abstract = {Code refactoring technique focuses on enhancing the maintainability of software to extend its lifetime. However, there are other efforts to improve software qualities like performance or reliability a s well as maintainability by using code refactoring techniques. Recently, as low -power software has become one of the critical issues in mobile environment s, developing energy - efficient software through code refactoring becomes an important one. This paper aims to investigate whether the existing refactoring techniques can support energy -efficient software generation or not . The refactored codes generated by the existing techniques can consume more power than original codes because they did not consider the power consumption in their refactoring processes . This paper analyzes the power consumption to investigate the energy efficiency of M. Fowler's refactoring techniques . Our analysis result can provide useful information about energy -efficient refactoring t echniques to software engineers , and support the development of software that has high maintainability and good energy efficiency},
  keywords = {Read}
}

@inproceedings{jagroep_software_2016-1,
  title = {Software {{Energy Profiling}}: {{Comparing Releases}} of a {{Software Product}}},
  shorttitle = {Software {{Energy Profiling}}},
  booktitle = {Proceedings of the 38th {{International Conference}} on {{Software Engineering Companion}}},
  author = {Jagroep, Erik A. and {van der Werf}, Jan Martijn and Brinkkemper, Sjaak and Procaccianti, Giuseppe and Lago, Patricia and Blom, Leen and {van Vliet}, Rob},
  year = {2016},
  series = {{{ICSE}} '16},
  pages = {523--532},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2889160.2889216},
  abstract = {In the quest for energy efficiency of Information and Communication Technology, so far research has mostly focused on the role of hardware. However, as hardware technology becomes more sophisticated, the role of software becomes crucial. Recently, the impact of software on energy consumption has been acknowledged as significant by researchers in software engineering. In spite of that, measuring the energy consumption of software has proven to be a challenge, due to the large number of variables that need to be controlled to obtain reliable measurements. Due to cost and time constraints, many software product organizations are unable to effectively measure the energy consumption of software. This prevents them to be in control over the energy efficiency of their products. In this paper, we propose a software energy profiling method to reliably compare the energy consumed by a software product across different releases, from the perspective of a software organization. Our method allows to attribute differences in energy consumption to changes in the software. We validate our profiling method through an empirical experiment on two consecutive releases of a commercial software product. We demonstrate how the method can be applied by organizations and provide an analysis of the software related changes in energy consumption. Our results show that, despite a lack of precise measurements, energy consumption differences between releases of a software product can be quantified down to the level of individual processes. Additionally, the results provide insights on how specific software changes might affect energy consumption.},
  isbn = {978-1-4503-4205-6},
  keywords = {energy efficiency,profiling,software architecture,software product},
  file = {/Users/chakibbelgaid/Zotero/storage/SF4DNNL7/Jagroep et al. - 2016 - Software Energy Profiling Comparing Releases of a.pdf}
}

@article{jagroep2017energy,
  title = {Energy Efficiency on the Product Roadmap: An Empirical Study across Releases of a Software Product},
  author = {Jagroep, Erik and Procaccianti, Giuseppe and {van der Werf}, Jan Martijn and Brinkkemper, Sjaak and Blom, Leen and {van Vliet}, Rob},
  year = {2017},
  journal = {Journal of Software: Evolution and process},
  volume = {29},
  number = {2},
  pages = {e1852},
  publisher = {{John Wiley \& Sons, Ltd Chichester, UK}}
}

@book{james_introduction_2013-1,
  title = {An {{Introduction}} to {{Statistical Learning}}},
  author = {James, Gareth and Witten, Daniela and Hastie, Trevor and Tibshirani, Robert},
  year = {2013},
  series = {Springer {{Texts}} in {{Statistics}}},
  volume = {103},
  publisher = {{Springer New York}},
  address = {{New York, NY}},
  doi = {10.1007/978-1-4614-7138-7},
  isbn = {978-1-4614-7137-0 978-1-4614-7138-7},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/ZTLYY7VV/James et al. - 2013 - An Introduction to Statistical Learning.pdf}
}

@book{kahraman_uncertainty_2012-1,
  title = {Uncertainty {{Modeling}} in {{Knowledge Engineering}} and {{Decision Making}} - {{Proceedings}} of the 10th {{International Flins Conference}}},
  author = {Kahraman, Cengiz and Bozbura, Faik Tunc and Kerre, Etienne E.},
  year = {2012},
  publisher = {{World Scientific}},
  abstract = {FLINS, originally an acronym for Fuzzy Logic and Intelligent Technologies in Nuclear Science, is now extended to Computational Intelligence for applied research. The contributions to the 10th of FLINS conference cover state-of-the-art research, development, and technology for computational intelligence systems, both from the foundations and the applications points-of-view.},
  googlebooks = {j9K2MkNlhqQC},
  isbn = {978-981-4417-73-0},
  langid = {english},
  keywords = {Computers / Intelligence (AI) \& Semantics,Computers / Machine Theory,Computers / Software Development \& Engineering / General}
}

@inproceedings{kalibera2013rigorous,
  title = {Rigorous Benchmarking in Reasonable Time},
  booktitle = {Proceedings of the 2013 International Symposium on Memory Management},
  author = {Kalibera, Tomas and Jones, Richard},
  year = {2013},
  pages = {63--74}
}

@article{kaur_analysis_2016,
  title = {Analysis of {{Code Refactoring Impact}} on {{Software Quality}}},
  author = {Kaur, Amandeep and Kaur, Manpreet},
  editor = {Srivastava, T. and Rani, S. and Kakkar, S.},
  year = {2016},
  journal = {MATEC Web of Conferences},
  volume = {57},
  pages = {02012},
  issn = {2261-236X},
  doi = {10.1051/matecconf/20165702012},
  abstract = {Code refactoring is a ``Technique used for restructuring an existing source code, improving its internal structure without changing its external behaviour''. It is the process of changing a source code in such a way that it does not alter the external behaviour of the code yet improves its internal structure. It is a way to clean up code that minimizes the chances of introducing bugs. Refactoring is a change made to the internal structure of a software component to make it easier to understand and cheaper to modify, without changing the observable behaviour of that software component. Bad smells indicate that there is something wrong in the code that have to refactor. There are different tools that are available to identify and remove these bad smells. It is a technique that change our source code in a more readable and maintainable form by removing the bad smells from the code. Refactoring is used to improve the quality of software by reducing the complexity. In this paper bad smells are found and perform the refactoring based on these bad smell and then find the complexity of program and compare with initial complexity. This paper shows that when refactoring is performed the complexity of software decrease and easily understandable.},
  langid = {english}
}

@article{Khan:2018:RAE:3199681.3177754,
  title = {{{RAPL}} in Action: {{Experiences}} in Using {{RAPL}} for Power Measurements},
  author = {Khan, Kashif Nizam and Hirki, Mikael and Niemi, Tapio and Nurminen, Jukka K. and Ou, Zhonghong},
  year = {2018},
  month = mar,
  journal = {ACM Trans. Model. Perform. Eval. Comput. Syst.},
  volume = {3},
  number = {2},
  publisher = {{ACM}},
  issn = {2376-3639},
  acmid = {3177754},
  articleno = {9},
  issue_date = {April 2018},
  numoptpages = {26},
  optaddress = {New York, NY, USA},
  optdoi = {10.1145/3177754},
  optpages = {9:1\textendash 9:26},
  opturl = {http://OPTdoi.acm.org/10.1145/3177754},
  keywords = {DRAM power,power modeling,RAPL,RAPL accuracy,RAPL validation}
}

@article{khokhriakov_modern_2019-2,
  ids = {khokhriakov_modern_2019},
  title = {Modern {{Multicore CPUs}} Are Not {{Energy Proportional}}: {{Opportunity}} for {{Bi-objective Optimization}} for {{Performance}} and {{Energy}}},
  shorttitle = {Modern {{Multicore CPUs}} Are Not {{Energy Proportional}}},
  author = {Khokhriakov, Semyon and Manumachu, Ravi Reddy and Lastovetsky, Alexey},
  year = {2019},
  month = oct,
  journal = {arXiv:1910.06674 [cs, eess]},
  eprint = {1910.06674},
  eprinttype = {arxiv},
  primaryclass = {cs, eess},
  abstract = {Energy proportionality is the key design goal followed by architects of modern multicore CPUs. One of its implications is that optimization of an application for performance will also optimize it for energy. In this work, we show that energy proportionality does not hold true for multicore CPUs. This finding creates the opportunity for bi-objective optimization of applications for performance and energy. We propose and study the first application-level method for bi-objective optimization of multithreaded data-parallel applications for performance and energy. The method uses two decision variables, the number of identical multithreaded kernels (threadgroups) executing the application and the number of threads in each threadgroup, so that a given workload is partitioned equally between the threadgroups. We experimentally demonstrate the efficiency of the method using four highly optimized multithreaded data-parallel applications, 2D fast Fourier transform based on FFTW and Intel MKL, and dense matrix-matrix multiplication using OpenBLAS and Intel MKL. Four modern multicore CPUs are used in the experiments. The experiments show that the optimization for performance alone results in the increase in dynamic energy consumption by up to 89\% and optimization for dynamic energy alone results in performance degradation by up to 49\%. By solving the bi-objective optimization problem, the method determines up to 11 globally Pareto-optimal solutions.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {and Cluster Computing,Computer Science - Distributed,Computer Science - Distributed; Parallel; and Cluster Computing,Computer Science - Hardware Architecture,Computer Science - Performance,Electrical Engineering and Systems Science - Systems and Control,Parallel},
  file = {/Users/chakibbelgaid/Zotero/storage/CULEM9W9/Khokhriakov et al. - 2019 - Modern Multicore CPUs are not Energy Proportional.pdf}
}

@inproceedings{kitaura_random_2018-1,
  title = {Random Testing of Compilers' Performance Based on Mixed Static and Dynamic Code Comparison},
  booktitle = {Proceedings of the 9th {{ACM SIGSOFT International Workshop}} on {{Automating TEST Case Design}}, {{Selection}}, and {{Evaluation}} - {{A-TEST}} 2018},
  author = {Kitaura, Kota and Ishiura, Nagisa},
  year = {2018},
  pages = {38--44},
  publisher = {{ACM Press}},
  address = {{Lake Buena Vista, FL, USA}},
  doi = {10.1145/3278186.3278192},
  abstract = {This paper proposes an automated test method for detecting performance bugs in compilers. It is based on di erential random testing, in which randomly generated programs are compiled by two di erent compilers and resulting pairs of assembly codes are compared. Our method attempts to achieve e cient and accurate detection of performance di erence, by combining dynamic measurement of execution time with static assembly-level comparison and test program minimization. In the rst step, discrepant pairs of code sections in the assembly codes are extracted, and then the sums of the weights of discrepant instructions in the sections are computed. If signi cant di erences are detected, the test program is reduced to a small program that still exhibits the static di erence and then the actual execution time of the codes are compared. A test system has been implemented on top of the random test system Orange4, which has successfully detected a regression in the optimizer of a development version of GCC-8.0.0 (latest as of May, 2017).},
  isbn = {978-1-4503-6053-1},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/2SG8QRC6/Kitaura and Ishiura - 2018 - Random testing of compilers’ performance based on .pdf}
}

@article{kothari2009joulemeter,
  title = {Joulemeter: {{Virtual}} Machine Power Measurement and Management},
  author = {Kothari, Nupur and Bhattacharya, Arka},
  year = {2009},
  journal = {MSR Tech Report}
}

@inproceedings{kumar_energy_2017,
  title = {Energy Consumption in {{Java}}: {{An}} Early Experience},
  shorttitle = {Energy Consumption in {{Java}}},
  booktitle = {2017 {{Eighth International Green}} and {{Sustainable Computing Conference}} ({{IGSC}})},
  author = {Kumar, Mohit and Li, Youhuizi and Shi, Weisong},
  year = {2017},
  month = oct,
  pages = {1--8},
  publisher = {{IEEE}},
  address = {{Orlando, FL}},
  doi = {10.1109/IGCC.2017.8323579},
  abstract = {There has been a 10,000-fold increase in performance of supercomputers since 1992 but only 300-fold improvement in performance per watt. Dynamic adaptation of hardware techniques such as fine-grain clock gating, power gating and dynamic voltage/frequency scaling, are used for many years to improve the computer's energy efficiency. However, recent demands of exascale computation, as well as the increasing carbon footprint, require new breakthrough to make ICT systems more energy efficient. Energy efficient software has not been well studied in the last decade. In this paper, we take an early step to investigate the energy efficiency of Java which is one of the most common languages used in ICT systems. We evaluate energy consumption of data types, operators, control statements, exception, and object in Java at a granular level. Intel Running Average Power Limit (RAPL) technology is applied to measure the relative power consumption of small code snippets. Several observations are found, and these results will help in standardizing the energy consumption traits of Java which can be leveraged by software developers to generate energy efficient code in future.},
  isbn = {978-1-5386-3470-7},
  langid = {english}
}

@inproceedings{kurpicz2016much,
  title = {How Much Does a {{VM}} Cost? {{Energy-proportional}} Accounting in {{VM-based}} Environments},
  booktitle = {2016 24th Euromicro International Conference on Parallel, Distributed, and Network-Based Processing ({{PDP}})},
  author = {Kurpicz, Mascha and Orgerie, Anne-C{\'e}cile and Sobe, Anita},
  year = {2016},
  pages = {651--658},
  organization = {{IEEE}}
}

@inproceedings{lafond2006energy,
  title = {An Energy Consumption Model for an Embedded Java Virtual Machine},
  booktitle = {International Conference on Architecture of Computing Systems},
  author = {Lafond, S{\'e}bastien and Lilius, Johan},
  year = {2006},
  pages = {311--325},
  organization = {{Springer}}
}

@inproceedings{lam_numba_2015-1,
  title = {Numba: A {{LLVM-based Python JIT}} Compiler},
  shorttitle = {Numba},
  author = {Lam, Siu Kwan and Pitrou, Antoine and Seibert, Stanley},
  year = {2015},
  pages = {1--6},
  publisher = {{ACM Press}},
  doi = {10.1145/2833157.2833162},
  abstract = {Dynamic, interpreted languages, like Python, are attractive for domain-experts and scientists experimenting with new ideas. However, the performance of the interpreter is often a barrier when scaling to larger data sets. This paper presents a just-in-time compiler for Python that focuses in scientific and array-oriented computing. Starting with the simple syntax of Python, Numba compiles a subset of the language into efficient machine code that is comparable in performance to a traditional compiled language. In addition, we share our experience in building a JIT compiler using LLVM[1].},
  isbn = {978-1-4503-4005-2},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/GX2BLGFY/Lam et al. - 2015 - Numba a LLVM-based Python JIT compiler.pdf}
}

@inproceedings{lancor_analyzing_2013-1,
  title = {Analyzing {{PHP}} Frameworks for Use in a Project-Based Software Engineering Course},
  booktitle = {Proceeding of the 44th {{ACM}} Technical Symposium on {{Computer}} Science Education},
  author = {Lancor, Lisa and Katha, Samyukta},
  year = {2013},
  month = mar,
  series = {{{SIGCSE}} '13},
  pages = {519--524},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2445196.2445350},
  abstract = {Given the popularity of PHP frameworks used in developing web-based applications, a comparative study is conducted to determine which framework is best suited for incorporation into the curriculum of an undergraduate software engineering course that uses project-based learning. The top six PHP frameworks (Zend, Yii, CakePHP, CodeIgniter, PRADO, and Symphony) were initially considered and then narrowed down to two (CakePHP and CodeIgniter) based on their alignment with common functionality in previous class projects, framework complexity for those new to frameworks (learning curve), and developer friendliness (availability of documentation and online resources). An in-depth comparative study is conducted by developing a functionally-equivalent web application using each of the two frameworks as well as plain PHP (no framework). This work was motivated by the difficulties that were encountered in an evolving, content-rich software engineering course and discusses the educational changes that were made to align student learning with sound software engineering principles and current software development practices used in the computing industry.},
  isbn = {978-1-4503-1868-6},
  keywords = {PHP frameworks,project-based learning,software design and development,software engineering}
}

@inproceedings{laros2013powerinsight,
  title = {Powerinsight-a Commodity Power Measurement Capability},
  booktitle = {2013 International Green Computing Conference Proceedings},
  author = {Laros, James H and Pokorny, Phil and DeBonis, David},
  year = {2013},
  pages = {1--6},
  organization = {{IEEE}}
}

@article{lawall_coccinelle_nodate-1,
  title = {Coccinelle {{Features}}},
  author = {Lawall, Julia},
  pages = {27},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/29RFM95P/Lawall - Coccinelle Features.pdf}
}

@article{lawall_coccinelle_nodate-2,
  title = {Coccinelle: {{Practical Program Transformation}} for the {{Linux Kernel}}},
  author = {Lawall, Julia},
  journal = {critical infrastructure},
  pages = {64},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/FUN4GE8U/Lawall - Coccinelle Practical Program Transformation for t.pdf}
}

@article{lawall_introduction_nodate-1,
  title = {Introduction to {{Coccinelle}}},
  author = {Lawall, Julia},
  pages = {45},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/Z4UDF99X/Lawall - Introduction to Coccinelle.pdf}
}

@inproceedings{lebeane2015watt,
  title = {Watt Watcher: Fine-Grained Power Estimation for Emerging Workloads},
  booktitle = {2015 27th International Symposium on Computer Architecture and High Performance Computing ({{SBAC-PAD}})},
  author = {LeBeane, Michael and Ryoo, Jee Ho and Panda, Reena and John, Lizy Kurian},
  year = {2015},
  pages = {106--113},
  organization = {{IEEE}}
}

@inproceedings{li_boosting_2016-1,
  title = {Boosting {{Python Performance}} on {{Intel Processors}}: {{A Case Study}} of {{Optimizing Music Recognition}}},
  shorttitle = {Boosting {{Python Performance}} on {{Intel Processors}}},
  booktitle = {2016 6th {{Workshop}} on {{Python}} for {{High-Performance}} and {{Scientific Computing}} ({{PyHPC}})},
  author = {Li, Yuanzhe and Schwiebert, Loren},
  year = {2016},
  month = nov,
  pages = {52--58},
  doi = {10.1109/PyHPC.2016.011},
  abstract = {We present a case study of optimizing a Python-based music recognition application on Intel Haswell Xeon processor. With support from Numpy and Scipy, Python addresses the requirements of the music recognition problem with math library utilization and special structures for data access. However, a general optimized Python application cannot fully utilize the latest high performance multicore processors. In this study, we survey an existing open-source music recognition application, written in Python, to explore the effect of applying changes to the Scipy and Numpy libraries to achieve full processor resource occupancy and reduce code latency. Instead of comparing across many different architectures, we focus on Intel high performance processors that have multiple cores and vector registers, and we attempt to preserve both user-friendliness and code scalability so that the revised library functions can be ported to other platforms and require no additional code changes.},
  keywords = {code latency reduction,full processor resource occupancy,Graphics processing units,high level languages,Instruction sets,Intel Haswell Xeon processor,Intel high performance processors,Libraries,math library utilization,Multithreading,music,Numpy libraries,open-source music recognition,parallel processing,public domain software,Python performance optimization,Python-based music recognition,Registers,roofline,Scipy libraries,software libraries,vector processing},
  file = {/Users/chakibbelgaid/Zotero/storage/9NGU625G/Li and Schwiebert - 2016 - Boosting Python Performance on Intel Processors A.pdf;/Users/chakibbelgaid/Zotero/storage/E4WL55I8/7836844.html;/Users/chakibbelgaid/Zotero/storage/TB8I97K6/7836844.html}
}

@book{lilja2005measuring,
  title = {Measuring Computer Performance: A Practitioner's Guide},
  author = {Lilja, David J},
  year = {2005},
  publisher = {{Cambridge university press}}
}

@inproceedings{linares-vasquez_mining_2014-1,
  title = {Mining Energy-Greedy {{API}} Usage Patterns in {{Android}} Apps: An Empirical Study},
  shorttitle = {Mining Energy-Greedy {{API}} Usage Patterns in {{Android}} Apps},
  author = {{Linares-V{\'a}squez}, Mario and Bavota, Gabriele and {Bernal-C{\'a}rdenas}, Carlos and Oliveto, Rocco and Di Penta, Massimiliano and Poshyvanyk, Denys},
  year = {2014},
  pages = {2--11},
  publisher = {{ACM Press}},
  doi = {10.1145/2597073.2597085},
  abstract = {Energy consumption of mobile applications is nowadays a hot topic, given the widespread use of mobile devices. The high demand for features and improved user experience, given the available powerful hardware, tend to increase the apps' energy consumption. However, excessive energy consumption in mobile apps could also be a consequence of energy greedy hardware, bad programming practices, or particular API usage patterns. We present the largest to date quantitative and qualitative empirical investigation into the categories of API calls and usage patterns that\textemdash in the context of the Android development framework\textemdash exhibit particularly high energy consumption profiles. By using a hardware power monitor, we measure energy consumption of method calls when executing typical usage scenarios in 55 mobile apps from different domains. Based on the collected data, we mine and analyze energy-greedy APIs and usage patterns. We zoom in and discuss the cases where either the anomalous energy consumption is unavoidable or where it is due to suboptimal usage or choice of APIs. Finally, we synthesize our findings into actionable knowledge and recipes for developers on how to reduce energy consumption while using certain categories of Android APIs and patterns.},
  isbn = {978-1-4503-2863-0},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/HYQZPJP7/Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf}
}

@incollection{liu_data-oriented_2015,
  title = {Data-{{Oriented Characterization}} of {{Application-Level Energy Optimization}}},
  booktitle = {Fundamental {{Approaches}} to {{Software Engineering}}},
  author = {Liu, Kenan and Pinto, Gustavo and Liu, Yu David},
  editor = {Egyed, Alexander and Schaefer, Ina},
  year = {2015},
  volume = {9033},
  pages = {316--331},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-46675-9_21},
  abstract = {Empowering application programmers to make energy-aware decisions is a critical dimension in improving energy efficiency of computer systems. Despite the growing interest in designing software development processes, frameworks, and programming models to facilitate application-level energy management, little is empirically known on how application-level features impact energy management. In this paper, we illuminate the optimization space of application-level energy management, from a novel data-oriented perspective. First, we study the varying energy impacts of alternative data management choices by programmers, such as data access patterns, data precision choices, and data organization. Second, we attempt to build a bridge between application-level energy management and hardware-level energy management, by elucidating how various application-level features respond to Dynamic Voltage and Frequency Scaling (DVFS), arguably the most classic hardware-based energy management approach. Finally, we apply our findings to real-world applications, demonstrating their potential for greater energy savings. The empirical study is particularly relevant in the Big Data era, where dataintensive applications are large energy consumers, and their energy efficiency is strongly correlated to how data are maintained and handled in programs.},
  isbn = {978-3-662-46674-2 978-3-662-46675-9},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/37WXZYGG/Liu et al. - 2015 - Data-Oriented Characterization of Application-Leve.pdf}
}

@incollection{liu_data-oriented_2015,
  title = {Data-{{Oriented Characterization}} of {{Application-Level Energy Optimization}}},
  booktitle = {Fundamental {{Approaches}} to {{Software Engineering}}},
  author = {Liu, Kenan and Pinto, Gustavo and Liu, Yu David},
  editor = {Egyed, Alexander and Schaefer, Ina},
  year = {2015},
  volume = {9033},
  pages = {316--331},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-46675-9_21},
  abstract = {Empowering application programmers to make energy-aware decisions is a critical dimension in improving energy efficiency of computer systems. Despite the growing interest in designing software development processes, frameworks, and programming models to facilitate application-level energy management, little is empirically known on how application-level features impact energy management. In this paper, we illuminate the optimization space of application-level energy management, from a novel data-oriented perspective. First, we study the varying energy impacts of alternative data management choices by programmers, such as data access patterns, data precision choices, and data organization. Second, we attempt to build a bridge between application-level energy management and hardware-level energy management, by elucidating how various application-level features respond to Dynamic Voltage and Frequency Scaling (DVFS), arguably the most classic hardware-based energy management approach. Finally, we apply our findings to real-world applications, demonstrating their potential for greater energy savings. The empirical study is particularly relevant in the Big Data era, where dataintensive applications are large energy consumers, and their energy efficiency is strongly correlated to how data are maintained and handled in programs.},
  isbn = {978-3-662-46674-2 978-3-662-46675-9},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/VS65I5IH/Liu et al. - 2015 - Data-Oriented Characterization of Application-Leve.pdf}
}

@inproceedings{liu2015data,
  title = {Data-Oriented Characterization of Application-Level Energy Optimization},
  booktitle = {International Conference on Fundamental Approaches to Software Engineering},
  author = {Liu, Kenan and Pinto, Gustavo and Liu, Yu David},
  year = {2015},
  pages = {316--331},
  organization = {{Springer}}
}

@article{longo_reducing_2019,
  ids = {longo2019reducing},
  title = {Reducing Energy Usage in Resource-Intensive {{Java-Based}} Scientific Applications via Micro-Benchmark Based Code Refactorings},
  author = {Longo, Mathias and Rodriguez, Ana and Mateos, Cristian and Zunino, Alejandro},
  year = {2019},
  journal = {Computer Science and Information Systems},
  volume = {16},
  number = {2},
  pages = {541--564},
  publisher = {{Comsis Consortium}},
  issn = {1820-0214, 2406-1018},
  doi = {10.2298/CSIS180608009L},
  abstract = {In-silico research has grown considerably. Today's scientific code involves long-running computer simulations and hence powerful computing infrastructures are needed. Traditionally, research in high-performance computing has focused on executing code as fast as possible, while energy has been recently recognized as another goal to consider. Yet, energy-driven research has mostly focused on the hardware and middleware layers, but few efforts target the application level, where many energy-aware optimizations are possible. We revisit a catalog of Java primitives commonly used in OO scientific programming, or micro-benchmarks, to identify energy-friendly versions of the same primitive. We then apply the micro-benchmarks to classical scientific application kernels and machine learning algorithms for both single-thread and multi-thread implementations on a server. Energy usage reductions at the micro-benchmark level are substantial, while for applications obtained reductions range from 3.90\% to 99.18\%.},
  langid = {english}
}

@article{ma2017biogeography,
  title = {Biogeography-Based Optimization: A 10-Year Review},
  author = {Ma, Haiping and Simon, Dan and Siarry, Patrick and Yang, Zhile and Fei, Minrui},
  year = {2017},
  journal = {IEEE Transactions on Emerging Topics in Computational Intelligence},
  volume = {1},
  number = {5},
  pages = {391--407},
  publisher = {{IEEE}}
}

@inproceedings{madhumathi_relevance_2018-1,
  title = {The {{Relevance}} of {{Container Monitoring Towards Container Intelligence}}},
  booktitle = {2018 9th {{International Conference}} on {{Computing}}, {{Communication}} and {{Networking Technologies}} ({{ICCCNT}})},
  author = {Madhumathi, R.},
  year = {2018},
  month = jul,
  pages = {1--5},
  doi = {10.1109/ICCCNT.2018.8493766},
  abstract = {The Docker platform has become the leading containerization-enablement solution these days. Containers emerge as the most appropriate way for agile software development, packaging, shipping and deployment across heterogeneous IT environments (local servers, cloud servers, personal devices, etc.). The software portability being achieved through the containerization movement is being applauded by business houses and IT industry professionals. Containers are being touted as the viable alternative to virtual machines, which are verbose and bulky. The faster provisioning, the real-time scalability, and quick transmission of application containers are being pronounced as the key differentiators of the containerization paradigm. With a growing array of enabling tools from various product vendors, the realization of containerized cloud environments is picking up fast. The DevOps concept gets strengthened with the faster maturity and stability of the Docker platform. As a result, IT can ship faster and run the same application, unchanged, on laptops, data centre VMs, and any cloud. In this paper, the integration of Docker containers with the monitoring tool ``Sysdig'' (https://sysdig.com/) is explained. This integration simplifies and streamlines the container monitoring, measurement and management.},
  keywords = {Cloud computing,Cloud Computing,Container Monitoring,Containers,Docker Container,Monitoring,Software,Tools,Virtual machining,Virtualization},
  file = {/Users/chakibbelgaid/Zotero/storage/9WDFEEWN/Madhumathi - 2018 - The Relevance of Container Monitoring Towards Cont.pdf;/Users/chakibbelgaid/Zotero/storage/8Y25GBT2/8493766.html;/Users/chakibbelgaid/Zotero/storage/B3DQTI8A/8493766.html}
}

@article{mann1947test,
  title = {On a Test of Whether One of Two Random Variables Is Stochastically Larger than the Other},
  author = {Mann, Henry B and Whitney, Donald R},
  year = {1947},
  journal = {The annals of mathematical statistics},
  publisher = {{JSTOR}},
  optpages = {50\textendash 60}
}

@inproceedings{manotas_empirical_2016-1,
  title = {An {{Empirical Study}} of {{Practitioners}}' {{Perspectives}} on {{Green Software Engineering}}},
  booktitle = {2016 {{IEEE}}/{{ACM}} 38th {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Manotas, I. and Bird, C. and Zhang, R. and Shepherd, D. and Jaspan, C. and Sadowski, C. and Pollock, L. and Clause, J.},
  year = {2016},
  month = may,
  pages = {237--248},
  doi = {10.1145/2884781.2884810},
  abstract = {The energy consumption of software is an increasing concern as the use of mobile applications, embedded systems, and data center-based services expands. While research in green software engineering is correspondingly increasing, little is known about the current practices and perspectives of software engineers in the field. This paper describes the first empirical study of how practitioners think about energy when they write requirements, design, construct, test, and maintain their software. We report findings from a quantitative,targeted survey of 464 practitioners from ABB, Google, IBM, and Microsoft, which was motivated by and supported with qualitative data from 18 in-depth interviews with Microsoft employees. The major findings and implications from the collected data contextualize existing green software engineering research and suggest directions for researchers aiming to develop strategies and tools to help practitioners improve the energy usage of their applications.},
  keywords = {ABB,Conferences,data center-based services,embedded systems,Empirical Study,Encoding,energy consumption,energy usage,Google,green computing,Green products,green software engineering,Green Software Engineering,IBM,Interviews,Microsoft,mobile applications,practitioner perspective,Software,software engineering,Software engineering,Survey},
  file = {/Users/chakibbelgaid/Zotero/storage/K7F2JAI9/Manotas et al. - 2016 - An Empirical Study of Practitioners' Perspectives .pdf;/Users/chakibbelgaid/Zotero/storage/2C8IF3MQ/7886907.html;/Users/chakibbelgaid/Zotero/storage/4N6JYMIZ/7886907.html}
}

@inproceedings{manotas_investigating_2013,
  ids = {manotas2013investigating,manotas_investigating_2013-1},
  title = {Investigating the Impacts of Web Servers on Web Application Energy Usage},
  booktitle = {2013 2nd {{International Workshop}} on {{Green}} and {{Sustainable Software}} ({{GREENS}})},
  author = {Manotas, I. and Sahin, C. and Clause, J. and Pollock, L. and Winbladh, K.},
  year = {2013},
  month = may,
  pages = {16--23},
  doi = {10.1109/GREENS.2013.6606417},
  abstract = {Software engineers make decisions about the design of the software they are creating on a daily basis. These decisions may impact the application in terms of efficiency, usability, flexibility, etc. Different competing design decisions are therefore often evaluated in terms of their projected impact on quality metrics prior to implementation. Recently energy has become a concern for software systems, ranging from mobile devices to large data centers. Additionally, it has been recognized that the software executing on a computing device can have a significant impact on the device's energy consumption. This raises the obvious question of whether or not it is possible to reduce the energy consumption of a software system by the means of software design decisions. This work examines how the use of different servers impacts the energy consumption of a web application. Through a controlled empirical experiment we have discovered several important findings in this regard. The results indicate that the energy consumption of a web application can vary greatly depending on the web server used to handle its requests. Furthermore, different web servers are more or less energy efficient depending on which web application features are being executed. The paper details an analysis of the results of the experiment.},
  organization = {{IEEE}},
  keywords = {Browsers,Calendars,computing device,Context,data centers,device energy consumption,empirical studies,energy consumption,Energy consumption,energy consumption reduction,Energy usage,file servers,Internet,mobile devices,power aware computing,quality metrics,request handling,software design decision,software engineering,software systems,Web application energy usage,Web applications,Web servers},
  file = {/Users/chakibbelgaid/Zotero/storage/5SGJ4QQ9/Manotas et al. - 2013 - Investigating the impacts of web servers on web ap.pdf;/Users/chakibbelgaid/Zotero/storage/MQ98KSJM/Manotas et al. - 2013 - Investigating the impacts of web servers on web ap.pdf;/Users/chakibbelgaid/Zotero/storage/5BFL9EPZ/6606417.html;/Users/chakibbelgaid/Zotero/storage/CNQSTLUX/6606417.html;/Users/chakibbelgaid/Zotero/storage/DD6XQJNG/6606417.html;/Users/chakibbelgaid/Zotero/storage/L22VXPSM/6606417.html;/Users/chakibbelgaid/Zotero/storage/NNG56EYV/6606417.html}
}

@inproceedings{manotas_seeds_2014,
  ids = {manotas2014seeds},
  title = {{{SEEDS}}: {{A}} Software Engineer's Energy-Optimization Decision Support Framework},
  shorttitle = {{{SEEDS}}},
  booktitle = {Proceedings of the 36th {{International Conference}} on {{Software Engineering}} - {{ICSE}} 2014},
  author = {Manotas, Irene and Pollock, Lori and Clause, James},
  year = {2014},
  pages = {503--514},
  publisher = {{ACM Press}},
  address = {{Hyderabad, India}},
  doi = {10.1145/2568225.2568297},
  abstract = {Reducing the energy usage of software is becoming more important in many environments, in particular, batterypowered mobile devices, embedded systems and data centers. Recent empirical studies indicate that software engineers can support the goal of reducing energy usage by making design and implementation decisions in ways that take into consideration how such decisions impact the energy usage of an application. However, the large number of possible choices and the lack of feedback and information available to software engineers necessitates some form of automated decision-making support.},
  isbn = {978-1-4503-2756-5},
  langid = {english}
}

@inproceedings{marathe2017empirical,
  title = {An Empirical Survey of Performance and Energy Efficiency Variation on {{Intel}} Processors},
  booktitle = {Proceedings of the 5th International Workshop on Energy Efficient Supercomputing},
  author = {Marathe, Aniruddha and Zhang, Yijia and Blanks, Grayson and Kumbhare, Nirmal and Abdulla, Ghaleb and Rountree, Barry},
  year = {2017},
  pages = {1--8}
}

@article{marr_cross-language_2016,
  title = {Cross-Language Compiler Benchmarking: Are We Fast Yet?},
  shorttitle = {Cross-Language Compiler Benchmarking},
  author = {Marr, Stefan and Daloze, Benoit and M{\"o}ssenb{\"o}ck, Hanspeter},
  year = {2016},
  month = nov,
  journal = {ACM SIGPLAN Notices},
  volume = {52},
  number = {2},
  pages = {120--131},
  issn = {0362-1340},
  doi = {10.1145/3093334.2989232},
  abstract = {Comparing the performance of programming languages is difficult because they differ in many aspects including preferred programming abstractions, available frameworks, and their runtime systems. Nonetheless, the question about relative performance comes up repeatedly in the research community, industry, and wider audience of enthusiasts. This paper presents 14 benchmarks and a novel methodology to assess the compiler effectiveness across language implementations. Using a set of common language abstractions, the benchmarks are implemented in Java, JavaScript, Ruby, Crystal, Newspeak, and Smalltalk. We show that the benchmarks exhibit a wide range of characteristics using language-agnostic metrics. Using four different languages on top of the same compiler, we show that the benchmarks perform similarly and therefore allow for a comparison of compiler effectiveness across languages. Based on anecdotes, we argue that these benchmarks help language implementers to identify performance bugs and optimization potential by comparing to other language implementations.},
  keywords = {Benchmarking,Languages,Virtual Machines},
  file = {/Users/chakibbelgaid/Zotero/storage/MTGQJFIR/Marr et al. - 2016 - Cross-language compiler benchmarking are we fast .pdf}
}

@article{mccullough_evaluating_nodate-1,
  title = {Evaluating the {{Effectiveness}} of {{Model-Based Power Characterization}}},
  author = {McCullough, John C and Agarwal, Yuvraj and Chandrashekar, Jaideep and Kuppuswamy, Sathyanarayan and Snoeren, Alex C and Gupta, Rajesh K},
  pages = {14},
  abstract = {Accurate power characterization is important in computing platforms for several reasons ranging from poweraware adaptation to power provisioning. Power characterization is typically obtained through either direct measurements enabled by physical instrumentation or modeling based on hardware performance counters. We show, however, that linear-regression based modeling techniques commonly used in the literature work well only in restricted settings. These techniques frequently exhibit high prediction error in modern computing platforms due to inherent complexities such as multiple cores, hidden device states, and large dynamic power components.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/74KK3WLU/McCullough et al. - Evaluating the Effectiveness of Model-Based Power .pdf}
}

@article{mcdowell_189_nodate-1,
  title = {189 {{Programming Questions}} and {{Solutions}}},
  author = {Mcdowell, Gayle Laakmann},
  pages = {708},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/4YH7AZ47/Mcdowell - 189 Programming Questions and Solutions.pdf}
}

@inproceedings{mcintire_etop-sensor_2007-1,
  title = {Etop-{{Sensor Network Application Energy Profiling}} on the {{LEAP2 Platform}}},
  booktitle = {2007 6th {{International Symposium}} on {{Information Processing}} in {{Sensor Networks}}},
  author = {McIntire, D. and Stathopoulos, T. and Kaiser, W.},
  year = {2007},
  month = apr,
  pages = {576--577},
  doi = {10.1109/IPSN.2007.4379734},
  abstract = {A broad range of embedded networked sensor (ENS) systems for critical environmental monitoring applications now require complex, high peak power dissipating sensor devices, as well as on-demand high performance computing and high bandwidth communication. Embedded computing demands for these new platforms include support for computationally intensive image and signal processing as well as optimization and statistical computing. To meet these new requirements while maintaining critical support for low energy operation, a new multiprocessor node hardware and software architecture, low power energy aware Processing (LEAP), has been developed. The LEAP architecture integrates fine-grained energy dissipation monitoring and sophisticated power control scheduling for all subsystems including sensor subsystems. The LEAP2 platform is a second generation LEAP system with even higher resolution energy monitoring as well as the unique ability to do per process and per application energy profiling via a dedicated high performance ASIC. Our demonstration will highlight this profiling capability through a custom monitoring application named etop.},
  keywords = {Algorithms,Bandwidth,Computer architecture,Design,Embedded computing,Embedded wireless networked sensor,Energy dissipation,energy profiling,energy-aware multiprocessor platform,Experimentation,Hardware,High performance computing,Management,Measurement,Monitoring,Performance,power aware applications,Reliability,Sensor systems and applications,Signal processing,Software architecture},
  file = {/Users/chakibbelgaid/Zotero/storage/5QV4U78K/McIntire et al. - 2007 - etop-Sensor Network Application Energy Profiling o.pdf;/Users/chakibbelgaid/Zotero/storage/SZQVF69Z/4379734.html;/Users/chakibbelgaid/Zotero/storage/Y6KK724A/4379734.html}
}

@article{merkel_docker_nodate-1,
  title = {Docker: {{Lightweight Linux Containers}} for {{Consistent Development}} and {{Deployment}}},
  author = {Merkel, Dirk},
  pages = {5},
  abstract = {Take on ``dependency hell'' with Docker containers, the lightweight and nimble cousin of VMs. Learn how Docker makes applications portable and isolated by packaging them in containers based on LXC technology.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/I6NPVLTZ/Merkel - Docker Lightweight Linux Containers for Consisten.pdf}
}

@inproceedings{mirowski2020rosetta,
  title = {Rosetta Code: {{Improv}} in Any Language},
  booktitle = {Proceedings of the 11th International Conference on Computational Creativity},
  author = {Mirowski, Piotr and Mathewson, Kory and Branch, Boyd and Winters, Thomas and Verhoeven, Ben and Elfving, Jenny},
  year = {2020},
  pages = {115--122},
  organization = {{Association for Computational Creativity}}
}

@article{mishra2018energy,
  title = {Energy-Efficient {{VM-placement}} in Cloud Data Center},
  author = {Mishra, Sambit Kumar and Puthal, Deepak and Sahoo, Bibhudatta and Jayaraman, Prem Prakash and Jun, Song and Zomaya, Albert Y and Ranjan, Rajiv},
  year = {2018},
  journal = {Sustainable computing: informatics and systems},
  volume = {20},
  pages = {48--55},
  publisher = {{Elsevier}}
}

@article{mishra2021web,
  title = {Web Development Frameworks and Its Performance Analysis\textemdash a Review},
  author = {Mishra, SP and Srivastava, SK},
  year = {2021},
  journal = {Smart Computing},
  pages = {337--343},
  publisher = {{CRC Press}}
}

@inproceedings{moghadam_code-imp_2011,
  title = {Code-{{Imp}}: {{A}} Tool for Automated Search-Based Refactoring},
  shorttitle = {Code-{{Imp}}},
  booktitle = {Proceeding of the 4th Workshop on {{Refactoring}} Tools - {{WRT}} '11},
  author = {Moghadam, Iman Hemati and {\'O} Cinn{\'e}ide, Mel},
  year = {2011},
  pages = {41},
  publisher = {{ACM Press}},
  address = {{Waikiki, Honolulu, HI, USA}},
  doi = {10.1145/1984732.1984742},
  abstract = {Manual refactoring is tedious and error-prone, so it is natural to try to automate this process as much as possible. Fully automated refactoring usually involves using metaheuristic search to determine which refactorings should be applied to improve the program according to some fitness function, expressed in terms of standard software quality metrics.},
  isbn = {978-1-4503-0579-2},
  langid = {english}
}

@inproceedings{morabito_power_2015-1,
  title = {Power {{Consumption}} of {{Virtualization Technologies}}: {{An Empirical Investigation}}},
  shorttitle = {Power {{Consumption}} of {{Virtualization Technologies}}},
  booktitle = {2015 {{IEEE}}/{{ACM}} 8th {{International Conference}} on {{Utility}} and {{Cloud Computing}} ({{UCC}})},
  author = {Morabito, Roberto},
  year = {2015},
  month = dec,
  pages = {522--527},
  doi = {10.1109/UCC.2015.93},
  abstract = {Virtualization is growing rapidly as a result of the increasing number of alternative solutions in this area, and of the wide range of application field. Until now, hypervisor-based virtualization has been the de facto solution to perform server virtualization. Recently, container-based virtualization \textendash{} an alternative to hypervisors \textendash{} has gained more attention because of lightweight characteristics, attracting cloud providers that have already made use of it to deliver their services. However, a gap in the existing research on containers exists in the area of power consumption. This paper presents the results of a performance comparison in terms of power consumption of four different virtualization technologies: KVM and Xen, which are based on hypervisor virtualization, Docker and LXC which are based on container virtualization. The aim of this empirical investigation, carried out by means of a testbed, is to understand how these technologies react to particular workloads. Our initial results show how, despite of the number of virtual entities running, both kinds of virtualization alternatives behave similarly in idle state and in CPU/Memory stress test. Contrarily, the results on network performance show differences between the two technologies.},
  keywords = {Cloud Computing,container,Containers,Docker,Hardware,hypervisor,KVM,LXC,Operating systems,Performance,power consumption,Power demand,Servers,Virtual machine monitors,virtualization,Virtualization,Xen},
  file = {/Users/chakibbelgaid/Zotero/storage/HP6JFXMN/Morabito - 2015 - Power Consumption of Virtualization Technologies .pdf;/Users/chakibbelgaid/Zotero/storage/374MTI99/7431468.html;/Users/chakibbelgaid/Zotero/storage/TADQCMLV/7431468.html}
}

@inproceedings{moreira_overviewing_2020,
  title = {Overviewing the Liveness of Refactoring for Energy Efficiency},
  booktitle = {Conference {{Companion}} of the 4th {{International Conference}} on {{Art}}, {{Science}}, and {{Engineering}} of {{Programming}}},
  author = {Moreira, Emanuel and Correia, Filipe F. and Bispo, Jo{\~a}o},
  year = {2020},
  month = mar,
  pages = {211--212},
  publisher = {{ACM}},
  address = {{Porto Portugal}},
  doi = {10.1145/3397537.3397538},
  abstract = {Mobile device users have been growing in the last years but the limited battery life of these devices is considered one of the major issues amongst users and programmers. Therefore, there is a need to guide developers in developing mobile applications in the most energy efficient way. One of the ways to improve this is to provide live feedback about the energy efficiency of a program while it's being programmed. We have analyzed and compared a total of 16 different tools and presented a list of 15 code smells and respective refactorings. From the analyzed tools, Leafactor is the closest to a valid solution to our problem because it's the only energy-aware tool with the highest liveness level. However, in order to be executed the programmer needs to trigger it on the IDE by selecting the file, instead of automatically being executed without the programmer being noticed and refactor his inefficient code.},
  isbn = {978-1-4503-7507-8},
  langid = {english}
}

@article{mukherjee2009spatio,
  title = {Spatio-Temporal Thermal-Aware Job Scheduling to Minimize Energy Consumption in Virtualized Heterogeneous Data Centers},
  author = {Mukherjee, Tridib and Banerjee, Ayan and Varsamopoulos, Georgios and Gupta, Sandeep KS and Rungta, Sanjay},
  year = {2009},
  journal = {Computer Networks},
  volume = {53},
  number = {17},
  pages = {2888--2904},
  publisher = {{Elsevier}}
}

@article{murri_performance_2013,
  title = {Performance of {{Python}} Runtimes on a Non-Numeric Scientific Code},
  author = {Murri, Riccardo},
  year = {2013},
  pages = {6},
  abstract = {The Python library FatGHol [FatGHoL] used in [Murri2012] to reckon the rational homology of the moduli space of Riemann surfaces is an example of a non-numeric scientific code: most of the processing it does is generating graphs (represented by complex Python objects) and computing their isomorphisms (a triple of Python lists; again a nested data structure). These operations are repeated many times over: for example, the spaces M0,6 and M1,4 are triangulated by 4'583'322 and 747'664 graphs, respectively.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/8LP2VCLF/Murri - 2013 - Performance of Python runtimes on a non-numeric sc.pdf}
}

@article{murri_performance_2014-1,
  ids = {murri_performance_2013},
  title = {Performance of {{Python}} Runtimes on a Non-Numeric Scientific Code},
  author = {Murri, Riccardo},
  year = {2014},
  month = apr,
  journal = {arXiv:1404.6388 [cs]},
  eprint = {1404.6388},
  eprinttype = {arxiv},
  primaryclass = {cs},
  abstract = {The Python library FatGHol FatGHoL used in Murri2012 to reckon the rational homology of the moduli space of Riemann surfaces is an example of a non-numeric scientific code: most of the processing it does is generating graphs (represented by complex Python objects) and computing their isomorphisms (a triple of Python lists; again a nested data structure). These operations are repeated many times over: for example, the spaces and are triangulated by 4'583'322 and 747'664 graphs, respectively. This is an opportunity for every Python runtime to prove its strength in optimization. The purpose of this experiment was to assess the maturity of alternative Python runtimes, in terms of: compatibility with the language as implemented in CPython 2.7, and performance speedup. This paper compares the results and experiences from running FatGHol with different Python runtimes: CPython 2.7.5, PyPy 2.1, Cython 0.19, Numba 0.11, Nuitka 0.4.4 and Falcon.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Mathematical Software,Computer Science - Programming Languages},
  note = {Comment: Part of the Proceedings of the 6th European Conference on Python in Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)
\par
Comment: Part of the Proceedings of the 6th European Conference on Python in Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)},
  file = {/Users/chakibbelgaid/Zotero/storage/CLERKQPI/Murri - 2014 - Performance of Python runtimes on a non-numeric sc.pdf;/Users/chakibbelgaid/Zotero/storage/GE45XHDB/1404.html;/Users/chakibbelgaid/Zotero/storage/IUKMCQMU/1404.html}
}

@article{mytkowicz2009producing,
  title = {Producing Wrong Data without Doing Anything Obviously Wrong!},
  author = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F},
  year = {2009},
  journal = {ACM Sigplan Notices},
  volume = {44},
  number = {3},
  pages = {265--276},
  publisher = {{ACM New York, NY, USA}}
}

@inproceedings{nanz2015comparative,
  title = {A Comparative Study of Programming Languages in Rosetta Code},
  booktitle = {2015 {{IEEE}}/{{ACM}} 37th {{IEEE}} International Conference on Software Engineering},
  author = {Nanz, Sebastian and Furia, Carlo A},
  year = {2015},
  volume = {1},
  pages = {778--788},
  organization = {{IEEE}}
}

@article{ni_review_2017-1,
  title = {A Review of Air Conditioning Energy Performance in Data Centers},
  author = {Ni, Jiacheng and Bai, Xuelian},
  year = {2017},
  month = jan,
  journal = {Renewable and Sustainable Energy Reviews},
  volume = {67},
  pages = {625--640},
  issn = {1364-0321},
  doi = {10.1016/j.rser.2016.09.050},
  abstract = {During the last years, many countries are experiencing rapid expansions in the number and size of data centers to keep pace with their internet and cloud computing needs. High energy consumption of the data center has gradually attracted public attention. However, there are no common efficiency standards governing the design or operation of data centers and the associated air conditioning systems. And the statistical research on air conditioning energy performance is still sorely lacking. This paper presents a summary of 100 data centers air conditioning energy performance. Energy efficiency metrics and benchmarks are also provided so that operators can use these information to track the performance of and identify opportunities to reduce energy use of air conditioning systems in their data centers. The collected data from articles and reports show that the average of HVAC system effectiveness index is 1.44. More than half of the data centers' air conditioning systems are inefficient. In total, HVAC systems account for about 38\% of facility energy consumption. The range for this usage was 21\% for the most efficient system and 61\% for the least efficient system. Moreover it would be necessary to review some currently available energy efficiency strategies such as economizer cycles, airflow optimization, energy management, and simulations tools.},
  keywords = {Air conditioning,Data center,Energy efficiency,Energy performance},
  file = {/Users/chakibbelgaid/Zotero/storage/8YCUD7CT/Ni and Bai - 2017 - A review of air conditioning energy performance in.pdf;/Users/chakibbelgaid/Zotero/storage/APA6J6HT/S136403211630541X.html;/Users/chakibbelgaid/Zotero/storage/BI6KY2MR/S136403211630541X.html}
}

@misc{noauthor_254_2019,
  title = {25.4. 2to3 - {{Automated Python}} 2 to 3 Code Translation \textemdash{} {{Python}} 2.7.16 Documentation},
  year = {2019},
  month = sep,
  howpublished = {https://docs.python.org/2/library/2to3.html},
  file = {/Users/chakibbelgaid/Zotero/storage/E472Z84A/2to3.html}
}

@misc{noauthor_254_2019,
  title = {25.4. 2to3 - {{Automated Python}} 2 to 3 Code Translation \textemdash{} {{Python}} 2.7.16 Documentation},
  year = {2019},
  month = sep,
  file = {/Users/chakibbelgaid/Zotero/storage/A3TMZ2C5/2to3.html}
}

@misc{noauthor_convert_nodate,
  title = {Convert {{PDF}} to {{BIBTEX Online}} | {{pdfFiller}}},
  abstract = {Convert PDF to BIBTEX online. PDFfiller is the best-quality online PDF editor and form builder - it's protected, fast, and easy to use. Use it to save time and money!},
  howpublished = {https://www.pdffiller.com/en/functionality/convert-pdf-to-bibtex-online.htm},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/XABXBESX/convert-pdf-to-bibtex-online.html}
}

@misc{noauthor_energy_2018,
  title = {Energy {{Efficiency}} of {{Java Programming Language}} - {{ProQuest}}},
  year = {2018},
  month = jun,
  howpublished = {https://search.proquest.com/openview/e7295f20d24f20391922e9baf5e835a8/1?pq-origsite=gscholar\&cbl=18750\&diss=y},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/7QII69FG/1.html}
}

@misc{noauthor_energy_2018,
  title = {Energy {{Efficiency}} of {{Java Programming Language}} - {{ProQuest}}},
  year = {2018},
  month = jun,
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/5VHU65LC/1.html}
}

@misc{noauthor_enseignements_2018,
  title = {Enseignements - {{Pierre Boulet}} - {{Universit\'e}} de {{Lille}}},
  year = {2018},
  month = jun,
  howpublished = {https://pro.univ-lille.fr/pierre-boulet/enseignements/\#descr},
  file = {/Users/chakibbelgaid/Zotero/storage/6YKZRRXV/enseignements.html}
}

@misc{noauthor_enseignements_2018,
  title = {Enseignements - {{Pierre Boulet}} - {{Universit\'e}} de {{Lille}}},
  year = {2018},
  month = jun,
  file = {/Users/chakibbelgaid/Zotero/storage/77B6MXZ7/enseignements.html}
}

@article{noauthor_epa_2007,
  title = {{{EPA Report}} to {{Congress}} on {{Server}} and {{Data Center Energy Efficiency}}},
  year = {2007},
  pages = {13},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/926X88QN/2007 - EPA Report to Congress on Server and Data Center E.pdf}
}

@misc{noauthor_holistic_2018,
  title = {A {{Holistic Evaluation}} of {{Docker Containers}} for {{Interfering Microservices}} - {{IEEE Conference Publication}}},
  year = {2018},
  month = oct,
  howpublished = {https://ieeexplore.ieee.org/document/8456398},
  file = {/Users/chakibbelgaid/Zotero/storage/D6V3MCGM/8456398.html}
}

@misc{noauthor_holistic_2018,
  title = {A {{Holistic Evaluation}} of {{Docker Containers}} for {{Interfering Microservices}} - {{IEEE Conference Publication}}},
  year = {2018},
  month = oct,
  file = {/Users/chakibbelgaid/Zotero/storage/M6WQNJEU/8456398.html}
}

@misc{noauthor_lazy_2019,
  title = {On Lazy Evaluation as a Tool to Optimize the Efficiency of Large Scale Numerical Simulations in {{Python}} | {{Elsevier Enhanced Reader}}},
  year = {2019},
  month = nov,
  doi = {10.1016/j.procs.2010.04.240},
  howpublished = {https://reader.elsevier.com/reader/sd/pii/S1877050910002413?token=D3F5799C47E5D5C405BA38C3179A996555E4484B7419F259787A03358531943C2E444BCDA181515FCDC550D54F6C77B5},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/G4XT5I2V/On lazy evaluation as a tool to optimize the effic.pdf;/Users/chakibbelgaid/Zotero/storage/SC285JYH/S1877050910002413.html}
}

@misc{noauthor_lazy_2019,
  title = {On Lazy Evaluation as a Tool to Optimize the Efficiency of Large Scale Numerical Simulations in {{Python}} | {{Elsevier Enhanced Reader}}},
  year = {2019},
  month = nov,
  doi = {10.1016/j.procs.2010.04.240},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/F3ARZMSZ/On lazy evaluation as a tool to optimize the effic.pdf;/Users/chakibbelgaid/Zotero/storage/MGL2QB3V/S1877050910002413.html}
}

@article{noauthor_notitle_nodate,
  type = {Article}
}

@article{noauthor_notitle_nodate,
  type = {Article}
}

@article{noauthor_notitle_nodate-1,
  type = {Article}
}

@article{noauthor_notitle_nodate-1,
  type = {Article}
}

@misc{noauthor_notitle_nodate-2,
  file = {/Users/chakibbelgaid/Zotero/storage/VLIXMXY7/_.pdf}
}

@misc{noauthor_notitle_nodate-2,
  file = {/Users/chakibbelgaid/Zotero/storage/5ZSLE9QP/_.pdf}
}

@misc{noauthor_pdf_2019,
  title = {({{PDF}}) {{The YouTube}} Video Recommendation System},
  year = {2019},
  month = may,
  journal = {ResearchGate},
  abstract = {ResearchGate is a network dedicated to science and research. Connect, collaborate and discover scientific publications, jobs and conferences. All for free.},
  howpublished = {https://www.researchgate.net/publication/221140967\_The\_YouTube\_video\_recommendation\_system},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/LXIQKC6J/221140967_The_YouTube_video_recommendation_system.html}
}

@misc{noauthor_pdf_2019,
  title = {({{PDF}}) {{The YouTube}} Video Recommendation System},
  year = {2019},
  month = may,
  abstract = {ResearchGate is a network dedicated to science and research. Connect, collaborate and discover scientific publications, jobs and conferences. All for free.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/R628K7XJ/221140967_The_YouTube_video_recommendation_system.html}
}

@misc{noauthor_power_2019,
  title = {Power Profiling Overview},
  year = {2019},
  month = oct,
  journal = {MDN Web Docs},
  abstract = {This article covers important background information about power profiling, with an emphasis on Intel processors used in desktop and laptop machines. It serves as a starting point for anybody doing power profiling for the first time.},
  howpublished = {https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Power\_profiling\_overview},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/QH3RCPIB/Power_profiling_overview.html}
}

@misc{noauthor_power_2019,
  title = {Power Profiling Overview},
  year = {2019},
  month = oct,
  abstract = {This article covers important background information about power profiling, with an emphasis on Intel processors used in desktop and laptop machines. It serves as a starting point for anybody doing power profiling for the first time.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/YCEY2LEA/Power_profiling_overview.html}
}

@misc{noauthor_pypl_2018,
  title = {{{PYPL PopularitY}} of {{Programming Language}} Index},
  year = {2018},
  month = oct,
  abstract = {PYPL popularity of programming language},
  howpublished = {https://pypl.github.io/PYPL.html},
  langid = {english}
}

@misc{noauthor_pypl_2018,
  title = {{{PYPL PopularitY}} of {{Programming Language}} Index},
  year = {2018},
  month = oct,
  abstract = {PYPL popularity of programming language},
  langid = {english}
}

@misc{noauthor_pypl_nodate,
  title = {{{PYPL PopularitY}} of {{Programming Language}} Index},
  abstract = {PYPL popularity of programming language},
  howpublished = {https://pypl.github.io/PYPL.html},
  langid = {english}
}

@misc{noauthor_pypl_nodate,
  title = {{{PYPL PopularitY}} of {{Programming Language}} Index},
  abstract = {PYPL popularity of programming language},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/PM6RVNHQ/PYPL.html}
}

@misc{noauthor_python_2019,
  title = {Python {{Developers Survey}} 2017 - {{Results}}},
  year = {2019},
  month = feb,
  journal = {JetBrains},
  abstract = {At the very end of 2017, the Python Software Foundation together with JetBrains conducted an official Python Developers Survey. We set out to identify the latest trends and gather insight into how the Python development world looks today. Over 9,500 developers from almost 150 different countries participated to help us map out an accurate landscape of the Python community.},
  howpublished = {https://www.jetbrains.com/research/python-developers-survey-2017/},
  file = {/Users/chakibbelgaid/Zotero/storage/U7BJUNP6/python-developers-survey-2017.html}
}

@misc{noauthor_python_2019,
  title = {Python {{Developers Survey}} 2017 - {{Results}}},
  year = {2019},
  month = feb,
  abstract = {At the very end of 2017, the Python Software Foundation together with JetBrains conducted an official Python Developers Survey. We set out to identify the latest trends and gather insight into how the Python development world looks today. Over 9,500 developers from almost 150 different countries participated to help us map out an accurate landscape of the Python community.}
}

@misc{noauthor_python_2019-1,
  title = {Python {{Developers Survey}} 2018 {{Results}}},
  year = {2019},
  month = feb,
  journal = {JetBrains},
  abstract = {Results of the official Python Developers Survey 2018 by Python Software Foundation and JetBrains: more than 20k responses from more than 150 countries.},
  howpublished = {https://www.jetbrains.com/research/python-developers-survey-2018/},
  note = {things that i might use~
\par
84\% of python used is python3~
\par
- python 2 maintenance will stoop in 2020~
\par
- python 2 is used for maintaining existing projects only~
\par
31\% of projects are isolated in docker - 64\% using virtualenv
\par
frameworks~
\par
| activity | framework | \% |~
\par
|:-------|---------:|:--:
\par
| web ~~ | ~~ Flask ~~~ | ~~ 47\%|
\par
|~~~ ~~~ ~~~ | ~~ Django | 45 \% |
\par
|----------------------|
\par
|data~~~ |~~~ numpy|~ 62\% |
\par
|science | Pandas |51 \% |
\par
| ~~~ ~~~ ~~~ | matplotlib 46\%~ |
\par
| ~~ ~~~ ~~~~| scipy | 38 |
\par
--------------------------
\par
|others | request | 53\% |
\par
|..........| Pillow| 29\% |
\par
|~~~ ~~~ ~~~ | Scrapy | 19\% |
\par
-----------------------------------
\par
usage in cloud~
\par
40\% in containers~
\par
69\%~ is used in linux~},
  file = {/Users/chakibbelgaid/Zotero/storage/VEIGT725/python-developers-survey-2018.html}
}

@misc{noauthor_python_2019-1,
  title = {Python {{Developers Survey}} 2018 {{Results}}},
  year = {2019},
  month = feb,
  abstract = {Results of the official Python Developers Survey 2018 by Python Software Foundation and JetBrains: more than 20k responses from more than 150 countries.}
}

@misc{noauthor_python_2019-2,
  title = {Python {{Developers Survey}} 2018 {{Results}}},
  year = {2019},
  month = feb,
  journal = {JetBrains},
  abstract = {Results of the official Python Developers Survey 2018 by Python Software Foundation and JetBrains: more than 20k responses from more than 150 countries.},
  howpublished = {https://www.jetbrains.com/research/python-developers-survey-2018/}
}

@misc{noauthor_python_2019-2,
  title = {Python {{Developers Survey}} 2018 {{Results}}},
  year = {2019},
  month = feb,
  abstract = {Results of the official Python Developers Survey 2018 by Python Software Foundation and JetBrains: more than 20k responses from more than 150 countries.}
}

@misc{noauthor_reproducible_nodate,
  title = {Reproducible {{Research}} in {{Computational Science}} | {{Science}}},
  howpublished = {https://science.sciencemag.org/content/334/6060/1226.abstract}
}

@misc{noauthor_reproducible_nodate,
  title = {Reproducible {{Research}} in {{Computational Science}} | {{Science}}},
  file = {/Users/chakibbelgaid/Zotero/storage/S74L4F4L/1226.html}
}

@misc{noauthor_scientific_2018,
  title = {Scientific English},
  year = {2018},
  month = jun,
  howpublished = {https://xmindshare.s3.amazonaws.com/preview/s6bQ-ZenrdCi-25363.png},
  file = {/Users/chakibbelgaid/Zotero/storage/NGLZYHTH/s6bQ-ZenrdCi-25363.html}
}

@misc{noauthor_scientific_2018,
  title = {Scientific English},
  year = {2018},
  month = jun
}

@misc{noauthor_survey_2018,
  title = {A Survey on Techniques for Improving the Energy Efficiency of Large-Scale Distributed Systems},
  year = {2018},
  month = jun,
  howpublished = {https://dl.acm.org/citation.cfm?id=2532637},
  file = {/Users/chakibbelgaid/Zotero/storage/9MYT85PG/citation.html}
}

@misc{noauthor_survey_2018,
  title = {A Survey on Techniques for Improving the Energy Efficiency of Large-Scale Distributed Systems},
  year = {2018},
  month = jun,
  file = {/Users/chakibbelgaid/Zotero/storage/CGTERTMR/citation.html}
}

@misc{noauthor_watching_2018,
  title = {Watching for Software Inefficiencies with {{Witch}}},
  year = {2018},
  month = apr,
  abstract = {Watching for software inefficiencies with Witch Wen et al., ASPLOS'18 (The link above is to the ACM Digital Library, if you don't have membership you should still be able to access the paper \ldots},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/BVWTJEGN/2018 - Watching for software inefficiencies with Witch.html}
}

@misc{noauthor_watching_2018,
  title = {Watching for Software Inefficiencies with {{Witch}}},
  year = {2018},
  month = apr,
  abstract = {Watching for software inefficiencies with Witch Wen et al., ASPLOS'18 (The link above is to the ACM Digital Library, if you don't have membership you should still be able to access the paper \ldots},
  langid = {english}
}

@misc{noauthor_welcome_nodate,
  title = {Welcome to the {{Evaluate Collaboratory}}! | {{Evaluate Collaboratory}}},
  howpublished = {http://evaluate.inf.usi.ch/},
  file = {/Users/chakibbelgaid/Zotero/storage/R7AGKGLJ/evaluate.inf.usi.ch.html}
}

@misc{noauthor_which_2018,
  title = {Which Benchmark Programs Are Faster? | {{Computer Language Benchmarks Game}}},
  year = {2018},
  month = oct,
  howpublished = {https://benchmarksgame-team.pages.debian.net/benchmarksgame/},
  file = {/Users/chakibbelgaid/Zotero/storage/H6RHNVCB/benchmarksgame.html}
}

@misc{noauthor_which_2018,
  title = {Which Benchmark Programs Are Faster? | {{Computer Language Benchmarks Game}}},
  year = {2018},
  month = oct
}

@misc{noauthor_which_2020,
  title = {Which Programming Language Is Fastest? | {{Computer Language Benchmarks Game}}},
  year = {2020},
  month = nov,
  howpublished = {https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html}
}

@misc{noauthor_which_2020,
  title = {Which Programming Language Is Fastest? | {{Computer Language Benchmarks Game}}},
  year = {2020},
  month = nov
}

@inproceedings{noureddine_optimising_2015-1,
  title = {Optimising {{Energy Consumption}} of {{Design Patterns}}},
  booktitle = {2015 {{IEEE}}/{{ACM}} 37th {{IEEE International Conference}} on {{Software Engineering}}},
  author = {Noureddine, A. and Rajan, A.},
  year = {2015},
  month = may,
  volume = {2},
  pages = {623--626},
  doi = {10.1109/ICSE.2015.208},
  abstract = {Software design patterns are widely used in software engineering to enhance productivity and maintainability.However, recent empirical studies revealed the high energy overhead in these patterns. Our vision is to automatically detect and transform design patterns during compilation for better energy efficiency without impacting existing coding practices. In this paper, we propose compiler transformations for two design patterns, Observer and Decorator, and perform an initial evaluation of their energy efficiency.},
  keywords = {coding practices,compilation,compiler transformations,Computers,Energy consumption,energy consumption optimisation,energy efficiency,maintainability,Observers,Optimization,power aware computing,program compilers,Software,software design patterns,software engineering,Software engineering,software maintenance,Transforms},
  file = {/Users/chakibbelgaid/Zotero/storage/JIJNR8XA/Noureddine and Rajan - 2015 - Optimising Energy Consumption of Design Patterns.pdf;/Users/chakibbelgaid/Zotero/storage/VVFMGX6Q/7203028.html;/Users/chakibbelgaid/Zotero/storage/WGP9QBY9/7203028.html}
}

@inproceedings{noureddine_preliminary_2012-1,
  title = {A Preliminary Study of the Impact of Software Engineering on {{GreenIT}}},
  booktitle = {2012 {{First International Workshop}} on {{Green}} and {{Sustainable Software}} ({{GREENS}})},
  author = {Noureddine, A. and Bourdon, A. and Rouvoy, R. and Seinturier, L.},
  year = {2012},
  month = jun,
  pages = {21--27},
  doi = {10.1109/GREENS.2012.6224251},
  abstract = {GreenIT has emerged as a discipline concerned with the optimization of software solutions with regards to their energy consumption. In this domain, most of state-of-the-art solutions offer limited or constraining approaches to monitor the energy consumption of a device or a process. In this paper, we therefore report on a runtime energy monitoring framework we developed to easily report on the energy consumption of system processes. Concretely, our approach adopts an OS-level library, called PowerAPI, which estimates the power consumption of processes according to different dimensions (CPU, network, etc.). In order to better understand potential energy leaks of legacy software, we use this library to study the impact of programming languages and algorithmic choices on the energy consumption. This preliminary study is based on an empirical evaluation of a eight implementations of the Towers of Hanoi problem.},
  keywords = {algorithmic choices,Energy,energy consumption,Energy consumption,energy leaks,environmental factors,Experimentation,GreenIT,Hanoi towers problem,Hardware,legacy software,Libraries,Measurement,Monitoring,OS-level library,Performance,power aware computing,Power demand,Power Model,POWERAPI,Program processors,programming languages,runtime energy monitoring framework,software engineering,software maintenance,software solutions optimization},
  file = {/Users/chakibbelgaid/Zotero/storage/V58A29BC/Noureddine et al. - 2012 - A preliminary study of the impact of software engi.pdf;/Users/chakibbelgaid/Zotero/storage/7IE25Q7C/6224251.html;/Users/chakibbelgaid/Zotero/storage/ZAD5TPQB/6224251.html}
}

@article{noureddine2015monitoring,
  title = {Monitoring Energy Hotspots in Software},
  author = {Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
  year = {2015},
  journal = {Automated Software Engineering},
  volume = {22},
  number = {3},
  pages = {291--332},
  publisher = {{Springer}}
}

@inproceedings{noureddine2016jolinar,
  title = {Jolinar: Analysing the Energy Footprint of Software Applications},
  booktitle = {Proceedings of the 25th International Symposium on Software Testing and Analysis},
  author = {Noureddine, Adel and Islam, Syed and Bashroush, Rabih},
  year = {2016},
  pages = {445--448}
}

@inproceedings{noureddine2022powerjoular,
  title = {{{PowerJoular}} and {{JoularJX}}: {{Multi-platform}} Software Power Monitoring Tools},
  booktitle = {18th International Conference on Intelligent Environments},
  author = {Noureddine, Adel},
  year = {2022}
}

@inproceedings{nucci_petra_2017-1,
  title = {{{PETrA}}: {{A Software-Based Tool}} for {{Estimating}} the {{Energy Profile}} of {{Android Applications}}},
  shorttitle = {{{PETrA}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Nucci, D. Di and Palomba, F. and Prota, A. and Panichella, A. and Zaidman, A. and Lucia, A. De},
  year = {2017},
  month = may,
  pages = {3--6},
  doi = {10.1109/ICSE-C.2017.18},
  abstract = {Energy efficiency is a vital characteristic of any mobile application, and indeed is becoming an important factor for user satisfaction. For this reason, in recent years several approaches and tools for measuring the energy consumption of mobile devices have been proposed. Hardware-based solutions are highly precise, but at the same time they require costly hardware toolkits. Model-based techniques require a possibly difficult calibration of the parameters needed to correctly create a model on a specific hardware device. Finally, software-based solutions are easier to use, but they are possibly less precise than hardware-based solution. In this demo, we present PETrA, a novel software-based tool for measuring the energy consumption of Android apps. With respect to other tools, PETrA is compatible with all the smartphones with Android 5.0 or higher, not requiring any device specific energy profile. We also provide evidence that our tool is able to perform similarly to hardware-based solutions.},
  keywords = {Android (operating system),Android 5.0,Android applications,Androids,energy conservation,energy consumption,Energy consumption,Energy Consumption,energy consumption measurement,energy efficiency,Energy measurement,energy profile estimation,Estimation,Hardware,hardware device,hardware toolkits,hardware-based solutions,Humanoid robots,mobile application,Mobile Apps,mobile computing,mobile devices,model-based techniques,parameter calibration,PETrA,power aware computing,smart phones,smartphones,software tools,software-based solutions,software-based tool,Tools,user satisfaction},
  file = {/Users/chakibbelgaid/Zotero/storage/H5IT28V7/Nucci et al. - 2017 - PETrA A Software-Based Tool for Estimating the En.pdf;/Users/chakibbelgaid/Zotero/storage/2STL2UFZ/7965243.html;/Users/chakibbelgaid/Zotero/storage/U7F8YU85/7965243.html}
}

@article{oliphant_python_2007-1,
  title = {Python for {{Scientific Computing}}},
  author = {Oliphant, T. E.},
  year = {2007},
  month = may,
  journal = {Computing in Science Engineering},
  volume = {9},
  number = {3},
  pages = {10--20},
  issn = {1521-9615},
  doi = {10.1109/MCSE.2007.58},
  abstract = {Python is an excellent "steering" language for scientific codes written in other languages. However, with additional basic tools, Python transforms into a high-level language suited for scientific and engineering code that's often fast enough to be immediately useful but also flexible enough to be sped up with additional extensions.},
  keywords = {Application software,computer languages,Embedded software,high level languages,High level languages,high-level language,Internet,Libraries,Prototypes,Python,scientific codes,scientific computing,Scientific computing,scientific programming,Software standards,Standards development,steering language,Writing},
  file = {/Users/chakibbelgaid/Zotero/storage/4I2U5KQR/Oliphant - 2007 - Python for Scientific Computing.pdf;/Users/chakibbelgaid/Zotero/storage/FUZR4AFP/4160250.html;/Users/chakibbelgaid/Zotero/storage/LHZ9X5VF/4160250.html}
}

@article{oliveira_recommending_nodate,
  title = {Recommending {{Energy-Efficient Java Collections}}},
  author = {Oliveira, Wellington and Oliveira, Renato and Castor, Fernando and Fernandes, Benito and Pinto, Gustavo},
  pages = {11},
  abstract = {Over the last years, increasing attention has been given to creating energy-efficient software systems. However, developers still lack the knowledge and the tools to support them in that task. In this work, we explore our vision that energy consumption non-specialists can build software that consumes less energy by alternating, at development time, between thirdparty, readily available, diversely-designed pieces of software, without increasing the development complexity. To support our vision, we propose an approach for energy-aware development that combines the construction of application-independent energy profiles of Java collections and static analysis to produce an estimate of in which ways and how intensively a system employs these collections. By combining these two pieces of information, it is possible to produce energy-saving recommendations for alternative collection implementations to be used in different parts of the system. We implement this approach in a tool named CT+ that works with both desktop and mobile Java systems, and is capable of analyzing 40 different collection implementations of lists, maps, and sets. We applied CT+ to twelve software systems: two mobile-based, seven desktop-based, and three that can run in both environments. Our evaluation infrastructure involved a high-end server, a notebook, and three mobile devices. When applying the (mostly trivial) recommendations, we achieved up to 17.34\% reduction in energy consumption just by replacing collection implementations. Even for a real world, mature, highlyoptimized system such as Xalan, CT+ could achieve a 5.81\% reduction in energy consumption. Our results indicate that some widely used collections, e.g., ArrayList, HashMap, and HashTable, are not energy-efficient and sometimes should be avoided when energy consumption is a major concern.},
  langid = {english},
  note = {Chapter 2:
\par
Collections- Introducing the main study field
\par
- categorizing them with the characteristics of each category~},
  file = {/Users/chakibbelgaid/Zotero/storage/YMZ2D2UV/Oliveira et al. - Recommending Energy-Efﬁcient Java Collections.pdf}
}

@inproceedings{opaper,
  title = {Taming Energy Consumption Variations in Systems Benchmarking},
  booktitle = {Proceedings of the {{ACM}}/{{SPEC}} International Conference on Performance Engineering},
  author = {Ournani, Zakaria and Belgaid, Mohammed Chakib and Rouvoy, Romain and Rust, Pierre and Penhoat, Joel and Seinturier, Lionel},
  year = {2020},
  series = {{{ICPE}} '20},
  pages = {36--47},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3358960.3379142},
  abstract = {The past decade witnessed the inclusion of power measurements to evaluate the energy efficiency of software systems, thus making energy a prime indicator along with performance. Nevertheless, measuring the energy consumption of a software system remains a tedious task for practitioners. In particular, the energy measurement process may be subject to a lot of variations that hinder the relevance of potential comparisons. While the state of the art mostly acknowledged the impact of hardware factors (chip printing process, CPU temperature), this paper investigates the impact of controllable factors on these variations. More specifically, we conduct an empirical study of multiple controllable parameters that one can easily tune to tame the energy consumption variations when benchmarking software systems. To better understand the causes of such variations, we ran more than a 1,000 experiments on more than 100 nodes with different workloads and configurations. The main factors we studied encompass: experimental protocol, CPU features (C-states, Turbo Boost, core pinning) and generations, as well as the operating system. Our experiments showed that, for some workloads, it is possible to tighten the energy variation by up to 30x. Finally, we summarize our results as guidelines to tame energy consumption variations. We argue that the guidelines we deliver are the minimal requirements to be considered prior to any energy efficiency evaluation.},
  isbn = {978-1-4503-6991-6},
  keywords = {energy consumption,energy efficiency,energy variations,system benchmarking}
}

@article{orgerie_survey_2014-1,
  title = {A Survey on Techniques for Improving the Energy Efficiency of Large-Scale Distributed Systems},
  author = {Orgerie, Anne-Cecile and de Assuncao, Marcos Dias and Lefevre, Laurent},
  year = {2014},
  month = mar,
  journal = {ACM Computing Surveys},
  volume = {46},
  number = {4},
  pages = {1--31},
  issn = {03600300},
  doi = {10.1145/2532637},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/2NIWT9N3/Orgerie et al. - 2014 - A survey on techniques for improving the energy ef.pdf}
}

@article{ortin_hybrid_2014-1,
  title = {A Hybrid Class- and Prototype-Based Object Model to Support Language-Neutral Structural Intercession},
  author = {Ortin, Francisco and Labrador, Miguel A. and Redondo, Jose M.},
  year = {2014},
  month = feb,
  journal = {Information and Software Technology},
  volume = {56},
  number = {2},
  pages = {199--219},
  issn = {0950-5849},
  doi = {10.1016/j.infsof.2013.09.002},
  abstract = {Context Dynamic languages have turned out to be suitable for developing specific applications where runtime adaptability is an important issue. Although .Net and Java platforms have gradually incorporated features to improve their support of dynamic languages, they do not provide intercession for every object or class. This limitation is mainly caused by the rigid class-based object model these platforms implement, in contrast to the flexible prototype-based model used by most dynamic languages. Objective Our approach is to provide intercession for any object or class by defining a hybrid class- and prototype-based object model that efficiently incorporates structural intercession into the object model implemented by the widespread .Net and Java platforms. Method In a previous work, we developed and evaluated an extension of a shared-source implementation of the .Net platform. In this work, we define the formal semantics of the proposed reflective model, and modify the existing implementation to include the hybrid model. Finally, we assess its runtime performance and memory consumption, comparing it to existing approaches. Results Our platform shows a competitive runtime performance compared to 9 widespread systems. On average, it performs 73\% and 61\% better than the second fastest system for short- and long-running applications, respectively. Besides, it is the JIT-compiler approach that consumes less average memory. The proposed approach of including a hybrid object-model into the virtual machine involves a 444\% performance improvement (and 65\% less memory consumption) compared to the existing alternative of creating an extra software layer (the DLR). When none of the new features are used, our platform requires 12\% more execution time and 13\% more memory than the original .Net implementation. Conclusion Our proposed hybrid class- and prototype-based object model supports structural intercession for any object or class. It can be included in existing JIT-compiler class-based platforms to support common dynamic languages, providing competitive runtime performance and low memory consumption.},
  keywords = {Duck typing,Dynamic languages,Prototype-based object model,Reflection,Structural intercession,Virtual machine},
  file = {/Users/chakibbelgaid/Zotero/storage/8P2M47MJ/S0950584913001778.html;/Users/chakibbelgaid/Zotero/storage/VHPLTJGW/S0950584913001778.html}
}

@article{ouni_multi-criteria_2016,
  title = {Multi-{{Criteria Code Refactoring Using Search-Based Software Engineering}}: {{An Industrial Case Study}}},
  shorttitle = {Multi-{{Criteria Code Refactoring Using Search-Based Software Engineering}}},
  author = {Ouni, Ali and Kessentini, Marouane and Sahraoui, Houari and Inoue, Katsuro and Deb, Kalyanmoy},
  year = {2016},
  month = aug,
  journal = {ACM Transactions on Software Engineering and Methodology},
  volume = {25},
  number = {3},
  pages = {1--53},
  issn = {1049-331X, 1557-7392},
  doi = {10.1145/2932631},
  langid = {english}
}

@phdthesis{ournani_software_2021-1,
  type = {Theses},
  title = {Software Eco-Design : Investigating and Reducing the Energy Consumption of Software},
  shorttitle = {Software Eco-Design},
  author = {Ournani, Zakaria},
  year = {2021},
  month = nov,
  number = {2021LILUB018},
  school = {Universit\'e de Lille},
  keywords = {Energy efficiency,Green refactoring,Green software design,Logiciels verts,Réusinage de code,Software energy consumption},
  file = {/Users/chakibbelgaid/Zotero/storage/SSN9R7E4/Ournani - 2021 - Software eco-design  investigating and reducing t.pdf}
}

@book{padala_virtualization_2018-1,
  title = {Virtualization of {{Data Centers}} : Study on {{Server Energy Consumption Performance}}},
  shorttitle = {Virtualization of {{Data Centers}}},
  author = {Padala, Praneel Reddy},
  year = {2018},
  abstract = {DiVA portal is a finding tool for research publications and student theses written at the following 47 universities and research institutions.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/XQKGE4NN/Padala - 2018 - Virtualization of Data Centers  study on Server E.pdf;/Users/chakibbelgaid/Zotero/storage/E7A8GYT9/record.html;/Users/chakibbelgaid/Zotero/storage/SWYK94S8/record.html}
}

@article{pang_what_nodate-1,
  title = {What {{Programming Languages Do Developers Use}}? {{A Theory}} of {{Static}} vs {{Dynamic Language Choice}}},
  author = {Pang, Aaron and Anslow, Craig and Noble, James},
  pages = {9},
  abstract = {We know very little about why developers do what they do. Lab studies are all very well, but often their results (e.g. that static type systems make development faster) seem contradicted by practice (e.g. developers choosing JavaScript or Python rather than Java or C\#). In this paper we build a first cut of a theory of why developers do what they do with a focus on the domain of static versus dynamic programming languages. We used a qualitative research method \textendash{} Grounded Theory, to interview a number of developers (n=15) about their experience using static and dynamic languages, and constructed a Grounded Theory of their programming language choices.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/XI73MUQT/Pang et al. - What Programming Languages Do Developers Use A Th.pdf}
}

@article{pankiv_concurrent_nodate-1,
  title = {Concurrent Benchmark System for Web-Frameworks on {{Python}}},
  author = {Pankiv, Andriy},
  pages = {26},
  abstract = {The frameworks have come a long way, and each new developer is faced not only with learning the language but also with the choice of the first framework for himself. The current choice is the result of incredible innovations in a relatively short period. As recently as 2004, Google released Gmail, which is considered the first product to be an all-in-browser; Today, such products are called one-page applications. Have you ever tried to create a front-end web interface using only HTML, CSS, and JavaScript? Well, nowadays it's not so hard. If the requirements are not too complicated, a small project can be completed relatively quickly. As for medium and large projects, to cope with the complexity of user requirements, you will need at least one framework.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/VXFIFW3Z/Pankiv - Concurrent benchmark system for web-frameworks on .pdf}
}

@phdthesis{pankiv2019concurrent,
  title = {Concurrent Benchmark System for Web-Frameworks on {{Python}}},
  author = {Pankiv, Andriy},
  year = {2019},
  school = {Ukrainian Catholic University}
}

@inproceedings{park_investigation_2014,
  title = {Investigation for {{Software Power Consumption}} of {{Code Refactoring Techniques}}},
  booktitle = {{{SEKE}}},
  author = {Park, Jae Jin and Hong, Jang-Eui and Lee, Sang-Ho},
  year = {2014}
}

@article{park_investigation_nodate,
  title = {Investigation for {{Software Power Consumption}} of {{Code Refactoring Techniques}}},
  author = {Park, Jae-Jin and Hong, Jang-Eui and Lee, Sang-Ho},
  pages = {6},
  abstract = {Code refactoring technique focuses on enhancing the maintainability of software to extend its lifetime. However, there are other efforts to improve software qualities like performance or reliability as well as maintainability by using code refactoring techniques. Recently, as low-power software has become one of the critical issues in mobile environments, developing energyefficient software through code refactoring becomes an important one. This paper aims to investigate whether the existing refactoring techniques can support energy-efficient software generation or not. The refactored codes generated by the existing techniques can consume more power than original codes because they did not consider the power consumption in their refactoring processes. This paper analyzes the power consumption to investigate the energy efficiency of M. Fowler's refactoring techniques. Our analysis result can provide useful information about energy-efficient refactoring techniques to software engineers, and support the development of software that has high maintainability and good energy efficiency.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/5JJGP8HE/Park et al. - Investigation for Software Power Consumption of Co.pdf}
}

@article{park_investigation_nodate,
  title = {Investigation for {{Software Power Consumption}} of {{Code Refactoring Techniques}}},
  author = {Park, Jae-Jin and Hong, Jang-Eui and Lee, Sang-Ho},
  pages = {6},
  abstract = {Code refactoring technique focuses on enhancing the maintainability of software to extend its lifetime. However, there are other efforts to improve software qualities like performance or reliability as well as maintainability by using code refactoring techniques. Recently, as low-power software has become one of the critical issues in mobile environments, developing energyefficient software through code refactoring becomes an important one. This paper aims to investigate whether the existing refactoring techniques can support energy-efficient software generation or not. The refactored codes generated by the existing techniques can consume more power than original codes because they did not consider the power consumption in their refactoring processes. This paper analyzes the power consumption to investigate the energy efficiency of M. Fowler's refactoring techniques. Our analysis result can provide useful information about energy-efficient refactoring techniques to software engineers, and support the development of software that has high maintainability and good energy efficiency.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/S75SWUSC/Park et al. - Investigation for Software Power Consumption of Co.pdf}
}

@article{paulson_developers_2007-1,
  title = {Developers Shift to Dynamic Programming Languages},
  author = {Paulson, L. D.},
  year = {2007},
  month = feb,
  journal = {Computer},
  volume = {40},
  number = {2},
  pages = {12--15},
  issn = {0018-9162},
  doi = {10.1109/MC.2007.53},
  abstract = {Software developers are always looking for ways to boost their effectiveness and productivity and perform complex jobs more quickly and easily, particularly as projects have become increasingly large and complex. Programmers want to shed unneeded complexity and outdated methodologies and move to approaches that focus on making programming simpler and faster. With this in mind, many developers are increasingly using dynamic languages such as JavaScript, Perl, Python, and Ruby. Although software experts disagree on the exact definition, a dynamic language basically enables programs that can change their code and logical structures at runtime, adding variable types, module names, classes, and functions as they are running. These languages frequently are interpreted and generally check typing at runtime},
  keywords = {Application software,C++ language,Computer languages,Dynamic programming,dynamic programming languages,Error correction,Java,JavaScript,Memory management,Mission critical systems,parallel languages,Perl,PHP,Programming profession,Python,Ruby,Runtime,software developers,Testing},
  file = {/Users/chakibbelgaid/Zotero/storage/ISMKEXML/Paulson - 2007 - Developers shift to dynamic programming languages.pdf;/Users/chakibbelgaid/Zotero/storage/4XMHZQEF/4085614.html;/Users/chakibbelgaid/Zotero/storage/GW3NQDCX/4085614.html}
}

@article{peng2011reproducible,
  title = {Reproducible Research in Computational Science},
  author = {Peng, Roger D},
  year = {2011},
  journal = {Science (New York, N.Y.)},
  volume = {334},
  number = {6060},
  pages = {1226--1227},
  publisher = {{American Association for the Advancement of Science}}
}

@inproceedings{pereira_energy_2017-1,
  ids = {pereira2017energy},
  title = {Energy {{Efficiency Across Programming Languages}}: {{How Do Energy}}, {{Time}}, and {{Memory Relate}}?},
  shorttitle = {Energy {{Efficiency Across Programming Languages}}},
  booktitle = {Proceedings of the 10th {{ACM SIGPLAN International Conference}} on {{Software Language Engineering}}},
  author = {Pereira, Rui and Couto, Marco and Ribeiro, Francisco and Rua, Rui and Cunha, J{\'a}come and Fernandes, Jo{\~a}o Paulo and Saraiva, Jo{\~a}o},
  year = {2017},
  series = {{{SLE}} 2017},
  pages = {256--267},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3136014.3136031},
  abstract = {This paper presents a study of the runtime, memory usage and energy consumption of twenty seven well-known software languages. We monitor the performance of such languages using ten different programming problems, expressed in each of the languages. Our results show interesting findings, such as, slower/faster languages consuming less/more energy, and how memory usage influences energy consumption. Finally, we show how to use our results to provide software engineers support to decide which language to use when energy efficiency is a concern.},
  isbn = {978-1-4503-5525-4},
  keywords = {Energy Efficiency,Green Software,Language Benchmarking,Programming Languages,Read},
  note = {this paper discuss the energy consumption through memory usage however we aim to see the relation between CPU usage and energy consumption rather than memory usage
\par
this paper discuss the energy consumption through memory usage however we aim to see the relation between CPU usage and energy consumption rather than memory usage},
  file = {/Users/chakibbelgaid/Zotero/storage/36CLI8YY/Pereira et al. - 2017 - Energy Efficiency Across Programming Languages Ho.pdf}
}

@inproceedings{pereira_helping_2017-1,
  ids = {pereira2017helping},
  title = {Helping {{Programmers Improve}} the {{Energy Efficiency}} of {{Source Code}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Pereira, Rui and Carcao, Tiago and Couto, Marco and Cunha, Jacome and Fernandes, Joao Paulo and Saraiva, Joao},
  year = {2017},
  month = may,
  pages = {238--240},
  publisher = {{IEEE}},
  address = {{Buenos Aires, Argentina}},
  doi = {10.1109/ICSE-C.2017.80},
  abstract = {This paper briefly proposes a technique to detect energy inefficient fragments in the source code of a software system. Test cases are executed to obtain energy consumption measurements, and a statistical method, based on spectrum-based fault localization, is introduced to relate energy consumption to the system's source code. The result of our technique is an energy ranking of source code fragments pointing developers to possible energy leaks in their code.},
  isbn = {978-1-5386-1589-8},
  langid = {english},
  organization = {{IEEE}},
  note = {\#\# main idea
\par
This paper presents a technique to spot the energy leaks inside a program using a spectrum technique called SPELL (Spectrum-based Energy Leak Localization)
\par
\#\# How it works ~
\par
We have a matrix (n*m) where n is the number of the tests and m is the number of components (like classes, methods, packages, etc.) after this we calculate the oracle (a vector that says which component is responsible for what)
\par
\#\# Contributions
\par
This paper helps developers to spot the red areas in their code and optimize the energy consumption. As an example it helped to reduce the energy consumption of a java application 50\% faster and with 18\% more efficiency.
\par
\#\# main idea 

This paper presents a technique to spot the energy leaks inside a program using a spectrum technique called SPELL (Spectrum-based Energy Leak Localization) 

\#\# How it works   

We have a matrix (n*m) where n is the number of the tests and m is the number of components (like classes, methods, packages, etc.) after this we calculate the oracle (a vector that says which component is responsible for what) 

\#\# Contributions 

This paper helps developers to spot the red areas in their code and optimize the energy consumption. As an example it helped to reduce the energy consumption of a java application 50\% faster and with 18\% more efficiency.},
  file = {/Users/chakibbelgaid/Zotero/storage/5FKHHGPV/Pereira et al. - 2017 - Helping Programmers Improve the Energy Efficiency .pdf}
}

@inproceedings{pereira_locating_2017-1,
  title = {Locating {{Energy Hotspots}} in {{Source Code}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Pereira, R.},
  year = {2017},
  month = may,
  pages = {88--90},
  doi = {10.1109/ICSE-C.2017.151},
  abstract = {This paper briefly presents a new approach for helping developers identify energy hot spots in their applications. Using tests cases, and statistical methods based on Spectrum-based Fault Localization, high energy consumption is related to the system's source code and a ranking of possible energy leaks are pointed. This technique is both language independent, and context level independent. Initial studies have also shown that using this technique helped developers identify and optimize energy problems in half the time while improving the energy efficiency by 18\%.},
  keywords = {Conferences,Context,energy conservation,energy consumption,Energy consumption,energy hotspot location,Energy measurement,fault diagnosis,Fault Localization,Green Computing,program execution,program fault identification,Program Optimization,program testing,Software,Software engineering,software maintenance,software system,source code (software),source code components,spectrum-based energy leak localization,spectrum-based fault localization,SPELL,statistical analysis,statistical methods,Tools},
  file = {/Users/chakibbelgaid/Zotero/storage/58RVFUPV/Pereira - 2017 - Locating Energy Hotspots in Source Code.pdf;/Users/chakibbelgaid/Zotero/storage/GTFM9SLZ/7965265.html;/Users/chakibbelgaid/Zotero/storage/PR3YFUTX/7965265.html}
}

@inproceedings{philippot_characterization_2014-1,
  title = {Characterization of the Energy Consumption of Websites: {{Impact}} of Website Implementation on Resource Consumption},
  shorttitle = {Characterization of the Energy Consumption of Websites},
  booktitle = {{{ICT}} for {{Sustainability}} 2014 ({{ICT4S-14}})},
  author = {Philippot, Olivier and Anglade, Alain and Leboucq, Thierry},
  year = {2014},
  month = aug,
  pages = {171--178},
  publisher = {{Atlantis Press}},
  issn = {2352-538X},
  doi = {10.2991/ict4s-14.2014.21},
  abstract = {This document presents the Web Energy Archive (WEA) project led by the Green Code Lab. This tools aims at measuring the computer resource consumption (energy, memory\ldots ) of the loading of a website in a browser. Firstly, considering the measure of 500 websites, website behavior can be characterized in terms of environmental impact. In a second step, best...},
  isbn = {978-94-6252-022-6},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/2FKJJ42Z/Philippot et al. - 2014 - Characterization of the energy consumption of webs.pdf;/Users/chakibbelgaid/Zotero/storage/MSRQCJ37/13439.html;/Users/chakibbelgaid/Zotero/storage/ZFXFHL5P/13439.html}
}

@phdthesis{pinto_2015-a_refactoring_approach_to_improve_energy_consumption_of_parallel_software_systems.pdf_2015,
  title = {2015-{{A}}\_{{Refactoring}}\_{{Approach}}\_to\_{{Improve}}\_{{Energy}}\_{{Consumption}}\_of\_{{Parallel}}\_{{Software}}\_{{Systems}}.{{Pdf}}},
  author = {Pinto, Gustavo},
  year = {2015},
  keywords = {Read}
}

@inproceedings{pinto_comprehensive_2016,
  title = {A {{Comprehensive Study}} on the {{Energy Efficiency}} of {{Java}}'s {{Thread-Safe Collections}}},
  booktitle = {2016 {{IEEE International Conference}} on {{Software Maintenance}} and {{Evolution}} ({{ICSME}})},
  author = {Pinto, Gustavo and Liu, Kenan and Castor, Fernando and Liu, Yu David},
  year = {2016},
  month = oct,
  pages = {20--31},
  publisher = {{IEEE}},
  address = {{Raleigh, NC, USA}},
  doi = {10.1109/ICSME.2016.34},
  isbn = {978-1-5090-3806-0},
  langid = {english},
  keywords = {Read}
}

@article{pinto_energy_2017-1,
  title = {Energy {{Efficiency}}: {{A New Concern}} for {{Application Software Developers}}},
  shorttitle = {Energy {{Efficiency}}},
  author = {Pinto, Gustavo and Castor, Fernando},
  year = {2017},
  month = nov,
  journal = {Commun. ACM},
  volume = {60},
  number = {12},
  pages = {68--75},
  issn = {0001-0782},
  doi = {10.1145/3154384},
  abstract = {Development of energy-efficient software is hindered by a lack of knowledge and a lack of tools.},
  note = {things to extend :
\par
use micro benchmarks , and say that each one is used to measure a specific thing (memory intensive , cpu intensive , io intesive ..etc )
\par
things to extend : 

use micro benchmarks , and say that each one is used to measure a specific thing (memory intensive , cpu intensive , io intesive ..etc )},
  file = {/Users/chakibbelgaid/Zotero/storage/H5GHCEVR/Pinto and Castor - 2017 - Energy Efficiency A New Concern for Application S.pdf}
}

@inproceedings{pinto_mining_2014-1,
  title = {Mining {{Questions About Software Energy Consumption}}},
  booktitle = {Proceedings of the 11th {{Working Conference}} on {{Mining Software Repositories}}},
  author = {Pinto, Gustavo and Castor, Fernando and Liu, Yu David},
  year = {2014},
  series = {{{MSR}} 2014},
  pages = {22--31},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2597073.2597110},
  abstract = {A growing number of software solutions have been proposed to address application-level energy consumption problems in the last few years. However, little is known about how much software developers are concerned about energy consumption, what aspects of energy consumption they consider important, and what solutions they have in mind for improving energy efficiency. In this paper we present the first empirical study on understanding the views of application programmers on software energy consumption problems. Using StackOverflow as our primary data source, we analyze a carefully curated sample of more than 300 questions and 550 answers from more than 800 users. With this data, we observed a number of interesting findings. Our study shows that practitioners are aware of the energy consumption problems: the questions they ask are not only diverse -- we found 5 main themes of questions -- but also often more interesting and challenging when compared to the control question set. Even though energy consumption-related questions are popular when considering a number of different popularity measures, the same cannot be said about the quality of their answers. In addition, we observed that some of these answers are often flawed or vague. We contrast the advice provided by these answers with the state-of-the-art research on energy consumption. Our summary of software energy consumption problems may help researchers focus on what matters the most to software developers and end users.},
  isbn = {978-1-4503-2863-0},
  keywords = {Practitioners,Q\&A,Software Energy Consumption},
  file = {/Users/chakibbelgaid/Zotero/storage/Q3SVE8QW/Pinto et al. - 2014 - Mining Questions About Software Energy Consumption.pdf}
}

@inproceedings{pinto_refactoring_2015,
  ids = {pinto_refactoring_2015-1},
  title = {Refactoring for {{Energy Efficiency}}: {{A Reflection}} on the {{State}} of the {{Art}}},
  shorttitle = {Refactoring for {{Energy Efficiency}}},
  booktitle = {2015 {{IEEE}}/{{ACM}} 4th {{International Workshop}} on {{Green}} and {{Sustainable Software}}},
  author = {Pinto, Gustavo and {Soares-Neto}, Francisco and Castor, Fernando},
  year = {2015},
  month = may,
  pages = {29--35},
  publisher = {{IEEE}},
  address = {{Florence, Italy}},
  doi = {10.1109/GREENS.2015.12},
  abstract = {Recent refactoring research introduced several innovations addressing diverse goals, such code extensibility, reusability, and testability. However, energy consumption, a critical property of any software system, remains unaddressed by refactoring research. In this paper, we provide an accounting of some of the recent and successful state-of-the-art research on software energy consumption. Through an investigation on premiere software engineering venues, we identify and discuss 12 contributions that can be further instantiated in refactoring tools used to improve software energy efficiency \textemdash{} and the challenges behind this process. These opportunities span a wide range of software characteristics, such as mobile applications and concurrent programming. Mobile applications is the topic with the greatest number of opportunities (6 out of 11). The study serves as a call to action for refactoring researchers interested in software energy consumption issues.},
  isbn = {978-1-4673-7049-3},
  langid = {english}
}

@inproceedings{pinto2016comprehensive,
  title = {A Comprehensive Study on the Energy Efficiency of Java's Thread-Safe Collections},
  booktitle = {2016 {{IEEE}} International Conference on Software Maintenance and Evolution ({{ICSME}})},
  author = {Pinto, Gustavo and Liu, Kenan and Castor, Fernando and Liu, Yu David},
  year = {2016},
  pages = {20--31},
  organization = {{IEEE}}
}

@article{procaccianti_empirical_2016-1,
  title = {Empirical Evaluation of Two Best Practices for Energy-Efficient Software Development},
  author = {Procaccianti, Giuseppe and Fern{\'a}ndez, H{\'e}ctor and Lago, Patricia},
  year = {2016},
  month = jul,
  journal = {Journal of Systems and Software},
  volume = {117},
  pages = {185--198},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2016.02.035},
  abstract = {Background. Energy efficiency is an increasingly important property of software. A large number of empirical studies have been conducted on the topic. However, current state-of-the-Art does not provide empirically-validated guidelines for developing energy-efficient software. Aim. This study aims at assessing the impact, in terms of energy savings, of best practices for achieving software energy efficiency, elicited from previous work. By doing so, it identifies which resources are affected by the practices and the possible trade-offs with energy consumption. Method. We performed an empirical experiment in a controlled environment, where we applied two different Green Software practices to two software applications, namely query optimization in MySQL Server and usage of ``sleep'' instruction in the Apache web server. We then performed a comparison of the energy consumption at system-level and at resource-level, before and after applying the practice. Results. Our results show that both practices are effective in improving software energy efficiency, reducing consumption up to 25\%. We observe that after applying the practices, resource usage is more energy-proportional i.e., increasing CPU usage increases energy consumption in an almost linear way. We also provide our reflections on empirical experimentation in software energy efficiency. Conclusions. Our contribution shows that significant improvements in software energy efficiency can be gained by applying best practices during design and development. Future work will be devoted to further validate best practices, and to improve their reusability.},
  keywords = {Best practices,Energy efficiency,Software engineering},
  file = {/Users/chakibbelgaid/Zotero/storage/URFCAUSA/Procaccianti et al. - 2016 - Empirical evaluation of two best practices for ene.pdf;/Users/chakibbelgaid/Zotero/storage/ETR782KY/S0164121216000777.html;/Users/chakibbelgaid/Zotero/storage/WSQG3ZEJ/S0164121216000777.html}
}

@article{procaccianti_energy_nodate,
  title = {Energy {{Efficiency}} of {{ORM Approaches}}: An {{Empirical Evaluation}}},
  author = {Procaccianti, Giuseppe and Lago, Patricia and Diesveld, Wouter},
  pages = {10},
  abstract = {Method. We performed an empirical experiment in a controlled environment. We selected three factors for our experimentation: the different ORM approaches, the type of query (Create, Read, Update, Delete) and the size of database tables. Our response variables were execution time and energy consumption. Results. As expected, pure SQL yielded the best performance and energy efficiency in all test cases. Propel exhibited a much higher energy consumption and longer execution times. The TinyQueries tool performed slightly worse than SQL, but significantly better than Propel, offering a convenient trade\textendash off between ORM benefits and energy efficiency. Conclusions. Our experiment shows that ORM approaches have a significant impact on both energy consumption and performance. This helps developers and architects when considering the trade-off between their benefits (e.g. in terms of code maintainability and readability) and drawbacks.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/Z3QWFHJF/Procaccianti et al. - Energy Efﬁciency of ORM Approaches an Empirical E.pdf}
}

@article{procaccianti_energy_nodate,
  title = {Energy {{Efficiency}} of {{ORM Approaches}}: {{An Empirical Evaluation}}},
  author = {Procaccianti, Giuseppe and Lago, Patricia and Diesveld, Wouter},
  pages = {10},
  abstract = {Method. We performed an empirical experiment in a controlled environment. We selected three factors for our experimentation: the different ORM approaches, the type of query (Create, Read, Update, Delete) and the size of database tables. Our response variables were execution time and energy consumption. Results. As expected, pure SQL yielded the best performance and energy efficiency in all test cases. Propel exhibited a much higher energy consumption and longer execution times. The TinyQueries tool performed slightly worse than SQL, but significantly better than Propel, offering a convenient trade\textendash off between ORM benefits and energy efficiency. Conclusions. Our experiment shows that ORM approaches have a significant impact on both energy consumption and performance. This helps developers and architects when considering the trade-off between their benefits (e.g. in terms of code maintainability and readability) and drawbacks.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/M2HIDHCV/Procaccianti et al. - Energy Efﬁciency of ORM Approaches an Empirical E.pdf}
}

@inproceedings{procaccianti_green_2015-1,
  title = {The {{Green Lab}}: {{Experimentation}} in {{Software Energy Efficiency}}},
  shorttitle = {The {{Green Lab}}},
  booktitle = {2015 {{IEEE}}/{{ACM}} 37th {{IEEE International Conference}} on {{Software Engineering}}},
  author = {Procaccianti, G. and Lago, P. and Vetr{\`o}, A. and Fern{\'a}ndez, D. M. and Wieringa, R.},
  year = {2015},
  month = may,
  volume = {2},
  pages = {941--942},
  doi = {10.1109/ICSE.2015.297},
  abstract = {Software energy efficiency is a research topic where experimentation is widely adopted. Nevertheless, current studies and research approaches struggle to find generalizable findings that can be used to build a consistent knowledge base for energy-efficient software. To this end, we will discuss how to combine the traditional hypothesis-driven (top-down) approach with a bottom-up discovery approach. In this technical briefing, participants will learn the challenges that characterize the research in software energy efficiency. They will experience the complexity in this field and its implications for experimentation.},
  keywords = {bottom-up discovery approach,Complexity theory,Conferences,Empirical Methods,energy conservation,Energy consumption,Energy Efficiency,Energy measurement,green computing,green laboratory,hypothesis-driven approach,Software,software energy efficiency,software engineering,Software engineering,Software Engineering,Software measurement},
  file = {/Users/chakibbelgaid/Zotero/storage/JYNPTIT8/Procaccianti et al. - 2015 - The Green Lab Experimentation in Software Energy .pdf;/Users/chakibbelgaid/Zotero/storage/ELDXEBJ5/7203119.html;/Users/chakibbelgaid/Zotero/storage/H495GW4R/7203119.html}
}

@article{putri_performance_2020-1,
  title = {Performance Analysis of Multi Services on Container {{Docker}}, {{LXC}}, and {{LXD}}},
  author = {Putri, Adinda Riztia and Munadi, Rendy and Negara, Ridha Muldina},
  year = {2020},
  month = oct,
  journal = {Bulletin of Electrical Engineering and Informatics},
  volume = {9},
  number = {5},
  pages = {2008--2011},
  issn = {2302-9285},
  doi = {10.11591/eei.v9i5.1953},
  abstract = {The emergence of the container in various cloud platforms from open stack to google cloud platform has marked the industry interest in opting for container as their cloud service solution. However, the cloud users should aware of performance overheads of different virtualization solutions in order to avoid quality of service degradation because different container platforms delivered different performances. This research evaluated how different container platforms (Docker, LXC, and LXD) impacted in running different TCP services and also measured system performance of each container compared to the native system without any container solution based on overall performance metrics. This research focuses on the three most used PaaS: FTP server, web server, and mail server. related to previous works, our evaluation results show that performance could vary between containers. In terms of system performance, LXD shows better performance while server performance result varies depending on what service is being evaluated.},
  copyright = {Copyright (c)},
  langid = {english},
  keywords = {Container,Docker,LXC,LXD,PaaS},
  file = {/Users/chakibbelgaid/Zotero/storage/ACXK9G4X/Putri et al. - 2020 - Performance analysis of multi services on containe.pdf}
}

@article{rad_introduction_2017-2,
  ids = {rad_introduction_2017-1},
  title = {An {{Introduction}} to {{Docker}} and {{Analysis}} of Its {{Performance}}},
  author = {Rad, Babak Bashari and Bhatti, Harrison John and Ahmadi, Mohammad},
  year = {2017},
  pages = {9},
  abstract = {Docker provide some facilities, which are useful for developers and administrators. It is an open platform can be used for building, distributing, and running applications in a portable, lightweight runtime and packaging tool, known as Docker Engine. It also provide Docker Hub, which is a cloud service for sharing applications. Costs can be reduced by replacing traditional virtual machine with docker container. It excellently reduces the cost of re-building the cloud development platform.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/4KHL7WBD/Rad et al. - 2017 - An Introduction to Docker and Analysis of its Perf.pdf}
}

@incollection{ranka_energy_2009,
  title = {Energy {{Efficiency}} of {{Thermal-Aware Job Scheduling Algorithms}} under {{Various Cooling Models}}},
  booktitle = {Contemporary {{Computing}}},
  author = {Varsamopoulos, Georgios and Banerjee, Ayan and Gupta, Sandeep K. S.},
  year = {2009},
  volume = {40},
  publisher = {{Springer}},
  langid = {english},
  optabstract = {One proposed technique to reduce energy consumption of data centers is thermal-aware job scheduling, i.e. job scheduling that relies on predictive thermal models to select among possible job schedules to minimize its energy needs. This paper investigates, using a more realistic linear cooling model, the energy savings of previously proposed thermal-aware job scheduling algorithms, which assume a less realistic model of constant cooling. The results show that the energy savings achieved are greater than the savings previously predicted. The contributions of this paper include: i) linear cooling models should be used in analysis and algorithm design, and ii) although the job scheduler must control the cooling equipment to realize most of the thermal-aware job schedule's savings, some savings can be still achieved without that control.},
  optaddress = {Berlin, Heidelberg},
  optdoi = {10.1007/978-3-642-03547-0{$_5$}4},
  opteditor = {Ranka, Sanjay and Aluru, Srinivas and Buyya, Rajkumar and Chung, Yeh-Ching and Dua, Sumeet and Grama, Ananth and Gupta, Sandeep K. S. and Kumar, Rajeev and Phoha, Vir V.},
  optisbn = {978-3-642-03546-3 978-3-642-03547-0},
  optpages = {568-580}
}

@article{redondo_comprehensive_2015-2,
  ids = {redondo_comprehensive_2015},
  title = {A {{Comprehensive Evaluation}} of {{Common Python Implementations}}},
  author = {Redondo, J. M. and Ortin, F.},
  year = {2015},
  month = jul,
  journal = {IEEE Software},
  volume = {32},
  number = {4},
  pages = {76--84},
  issn = {0740-7459},
  doi = {10.1109/MS.2014.104},
  abstract = {Python is a widely used general-purpose dynamic language. Owing to its popularity, many implementations exist for the two distinct Python 2 and Python 3 language versions. Researchers evaluated seven implementations of both language versions to facilitate the selection of one of them. For this purpose, they carefully selected 523 programs to execute in each implementation. They evaluated run-time performance and memory consumption and investigated each implementation's important qualitative characteristics.},
  keywords = {benchmark suite,Benchmark testing,dynamic languages,Dynamic programming,general-purpose dynamic language,high level languages,Java,JIT compilation,just-in-time compilation,memory consumption,Memory management,performance analysis,Python,Python 2 language versions,Python 3 language version,Python implementations,run-time performance,Runtime,software development,software engineering,storage management,Visual BASIC},
  note = {benchmarks link
\par
\href{http://www.reflection.uniovi.es/python}{http://www.reflection.uniovi.es/python}
\par
benchmarks link 

http://www.reflection.uniovi.es/python},
  file = {/Users/chakibbelgaid/Zotero/storage/UUCH8CTG/Redondo and Ortin - 2015 - A Comprehensive Evaluation of Common Python Implem.pdf;/Users/chakibbelgaid/Zotero/storage/AP472229/Redondo and Ortin - 2015 - A Comprehensive Evaluation of Common Python Implem.html;/Users/chakibbelgaid/Zotero/storage/GQ8CDVS5/6879048.html;/Users/chakibbelgaid/Zotero/storage/P5WZ4KZV/Redondo and Ortin - 2015 - A Comprehensive Evaluation of Common Python Implem.html}
}

@incollection{ref1,
  title = {Pearson's Correlation Coefficient},
  booktitle = {Encyclopedia of Public Health},
  year = {2008},
  publisher = {{Springer Netherlands}},
  optaddress = {Dordrecht},
  optdoi = {10.1007/978-1-4020-5614-7{$_2$}569},
  opteditor = {Kirch, Wilhelm},
  optisbn = {978-1-4020-5614-7},
  optpages = {1090\textendash 1091},
  opturl = {https://OPTdoi.org/10.1007/978-1-4020-5614-7{$_2$}569}
}

@book{refactoringBook,
  title = {Refactoring to Patterns},
  author = {Kerievsky, Joshua},
  year = {2004},
  publisher = {{Pearson Higher Education}},
  abstract = {In 1994, Design Patterns changed the landscape of object-oriented development by introducing classic solutions to recurring design problems. In 1999, Refactoring revolutionized design by introducing an effective process for improving code. With the highly anticipated Refactoring to Patterns, Joshua Kerievsky has changed our approach to design by forever uniting patterns with the evolutionary process of refactoring.This book introduces the theory and practice of pattern-directed refactorings: sequences of low-level refactorings that allow designers to safely move designs to, towards, or away from pattern implementations. Using code from real-world projects, Kerievsky documents the thinking and steps underlying over two dozen pattern-based design transformations. Along the way he offers insights into pattern differences and how to implement patterns in the simplest possible ways.Coverage includes: A catalog of twenty-seven pattern-directed refactorings, featuring real-world code examples Descriptions of twelve design smells that indicate the need for this book's refactorings General information and new insights about patterns and refactoring Detailed implementation mechanics: how low-level refactorings are combined to implement high-level patterns Multiple ways to implement the same pattern-and when to use each Practical ways to get started even if you have little experience with patterns or refactoringRefactoring to Patterns reflects three years of refinement and the insights of more than sixty software engineering thought leaders in the global patterns, refactoring, and agile development communities. Whether you're focused on legacy or ``greenfield'' development, this book will make you a better software designer by helping you learn how to make important design changes safely and effectively.},
  isbn = {0-321-21335-1}
}

@inproceedings{ribic2016aequitas,
  title = {Aequitas: {{Coordinated}} Energy Management across Parallel Applications},
  booktitle = {Proceedings of the 2016 International Conference on Supercomputing},
  author = {Ribic, Haris and Liu, Yu David},
  year = {2016},
  pages = {1--12}
}

@inproceedings{rodriguez_reducing_2017-1,
  ids = {rodriguez2017reducing},
  title = {Reducing {{Energy Consumption}} of {{Resource-Intensive Scientific Mobile Applications}} via {{Code Refactoring}}},
  booktitle = {2017 {{IEEE}}/{{ACM}} 39th {{International Conference}} on {{Software Engineering Companion}} ({{ICSE-C}})},
  author = {Rodriguez, A.},
  year = {2017},
  month = may,
  pages = {475--476},
  doi = {10.1109/ICSE-C.2017.33},
  abstract = {The advent of new computing paradigms such as Mobile Grids and Mobile-edge Clouds, and the increasing number of mobile devices with ever-growing capabilities makes them attractive to users running scientific and HPC applications. However, mobile devices still have limited capabilities when compared to non-mobile devices. More importantly, mobile devices rely on batteries for their power supply. To overcome this problem, this PhD research studies how to reduce energy consumption in mobile devices via code refactoring for such kind of applications.},
  organization = {{IEEE}},
  keywords = {Androids,Batteries,code refactoring,energy consumption,Energy consumption,energy consumption reduction,HPC applications,Humanoid robots,Java,mobile computing,mobile devices,natural sciences computing,parallel processing,resource-intensive scientific mobile applications,scientific applications,Smart phones,software maintenance,source code (software)},
  file = {/Users/chakibbelgaid/Zotero/storage/GN37S7ND/Rodriguez - 2017 - Reducing Energy Consumption of Resource-Intensive .pdf;/Users/chakibbelgaid/Zotero/storage/ACMGQNJQ/7965391.html;/Users/chakibbelgaid/Zotero/storage/DR3YNDF7/7965391.html}
}

@inproceedings{romansky_deep_2017-1,
  title = {Deep {{Green}}: {{Modelling Time-Series}} of {{Software Energy Consumption}}},
  shorttitle = {Deep {{Green}}},
  booktitle = {2017 {{IEEE International Conference}} on {{Software Maintenance}} and {{Evolution}} ({{ICSME}})},
  author = {Romansky, S. and Borle, N. C. and Chowdhury, S. and Hindle, A. and Greiner, R.},
  year = {2017},
  month = sep,
  pages = {273--283},
  doi = {10.1109/ICSME.2017.79},
  abstract = {Inefficient mobile software kills battery life. Yet, developers lack the tools necessary to detect and solve energy bugs in software. In addition, developers are usually tasked with the creation of software features and triaging existing bugs. This means that most developers do not have the time or resources to research, build, or employ energy debugging tools. We present a new method for predicting software energy consumption to help debug software energy issues. Our approach enables developers to align traces of software behavior with traces of software energy consumption. This allows developers to match run-time energy hot spots to the corresponding execution. We accomplish this by applying recent neural network models to predict time series of energy consumption given a software's behavior. We compare our time series models to prior state-of-the-art models that only predict total software energy consumption. We found that machine learning based time series based models, and LSTM based time series based models, can often be more accurate at predicting instantaneous power use and total energy consumption.},
  keywords = {battery life,deep green,energy,energy consumption,Energy consumption,energy debugging tools,Energy measurement,green mining,Hardware,learning (artificial intelligence),LSTM,machine learning,mobile computing,mobile software,modelling,neural nets,online model,power aware computing,Predictive models,profiling,program debugging,program diagnostics,run-time energy hot spots,Software,software behavior tracing,software engineering,time series,Time series analysis,time series models,Tools,total energy consumption,total software energy consumption},
  file = {/Users/chakibbelgaid/Zotero/storage/5WYNHFAP/Romansky et al. - 2017 - Deep Green Modelling Time-Series of Software Ener.pdf;/Users/chakibbelgaid/Zotero/storage/I7NBGZ24/8094428.html;/Users/chakibbelgaid/Zotero/storage/K4LL8AIF/8094428.html}
}

@article{sahin_benchmarks_2016-1,
  title = {From Benchmarks to Real Apps: {{Exploring}} the Energy Impacts of Performance-Directed Changes},
  shorttitle = {From Benchmarks to Real Apps},
  author = {Sahin, Cagri and Pollock, Lori and Clause, James},
  year = {2016},
  month = jul,
  journal = {Journal of Systems and Software},
  volume = {117},
  pages = {307--316},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2016.03.031},
  abstract = {Battery life is an increasing concern for mobile devices. Recent studies have provided initial evidence that applying performance tips is an effective mechanism for decreasing energy usage. However, the generalizability of such studies to real applications is unclear. We aim to provide deeper insights into whether mobile application developers can effectively reduce the energy consumption of their applications by applying performance tips. We conducted an empirical study to investigate the energy impacts of applying four commonly suggested performance tips to eight real Android applications. Considered performance tips are unlikely to impact energy usage in a statistically significant manner and, even when the impacts are statistically significant, the change in battery life is around 1\%. Mobile application developers cannot expect to improve the energy usage of their applications as a by product of performance improvements. Tools and techniques that specifically target energy usage are necessary for significant improvements.},
  keywords = {Android applications,Energy efficiency,Performance tips},
  file = {/Users/chakibbelgaid/Zotero/storage/FGZK8M7K/Sahin et al. - 2016 - From benchmarks to real apps Exploring the energy.pdf;/Users/chakibbelgaid/Zotero/storage/9EIR7MJF/S0164121216000893.html;/Users/chakibbelgaid/Zotero/storage/GCNTSMAC/S0164121216000893.html}
}

@inproceedings{sahin_how_2014,
  ids = {sahin_how_2014-2},
  title = {How Do Code Refactorings Affect Energy Usage?},
  booktitle = {Proceedings of the 8th {{ACM}}/{{IEEE International Symposium}} on {{Empirical Software Engineering}} and {{Measurement}} - {{ESEM}} '14},
  author = {Sahin, Cagri and Pollock, Lori and Clause, James},
  year = {2014},
  pages = {1--10},
  publisher = {{ACM Press}},
  address = {{Torino, Italy}},
  doi = {10.1145/2652524.2652538},
  abstract = {Method: We conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly-used refactorings. Results: We found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application. In addition, we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring. Conclusion: The results from this and similar studies could be used to augment IDEs to help software developers build more energy efficient software.},
  isbn = {978-1-4503-2774-9},
  langid = {english}
}

@inproceedings{sahin_how_2014-1,
  title = {How Do Code Refactorings Affect Energy Usage?},
  author = {Sahin, Cagri and Pollock, Lori and Clause, James},
  year = {2014},
  pages = {1--10},
  publisher = {{ACM Press}},
  doi = {10.1145/2652524.2652538},
  abstract = {Method: We conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly-used refactorings. Results: We found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application. In addition, we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring. Conclusion: The results from this and similar studies could be used to augment IDEs to help software developers build more energy efficient software.},
  isbn = {978-1-4503-2774-9},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/AVSGW65M/Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf}
}

@inproceedings{samir_hasan_energy_2016,
  title = {Energy {{Profiles}} of {{Java Collections Classes}}},
  booktitle = {{{ICSE}}},
  author = {{Samir Hasan} and {Rachary King} and {Munawar Hafiz}},
  year = {2016},
  abstract = {We created detailed profiles of the energy consumed by com- mon operations done on Java List, Map, and Set abstrac- tions. The results show that the alternative data types for these abstractions differ significantly in terms of energy con- sumption depending on the operations. For example, an Ar- rayList consumes less energy than a LinkedList if items are inserted at the middle or at the end, but consumes more energy than a LinkedList if items are inserted at the start of the list. To explain the results, we explored the memory usage and the bytecode executed during an operation. Ex- pensive computation tasks in the analyzed bytecode traces appeared to have an energy impact, but memory usage did not contribute. We evaluated our profiles by using them to selectively replace Collections types used in six applications and libraries. We found that choosing the wrong Collec- tions type, as indicated by our profiles, can cost even 300\% more energy than the most efficient choice. Our work shows that the usage context of a data structure and our measured energy profiles can be used to decide between alternative Collections implementations.},
  keywords = {Read}
}

@article{santos_how_2018-1,
  ids = {santos2018does},
  title = {How Does Docker Affect Energy Consumption? {{Evaluating}} Workloads in and out of {{Docker}} Containers},
  shorttitle = {How Does Docker Affect Energy Consumption?},
  author = {Santos, Eddie Antonio and McLean, Carson and Solinas, Christopher and Hindle, Abram},
  year = {2018},
  month = dec,
  journal = {Journal of Systems and Software},
  volume = {146},
  pages = {14--25},
  publisher = {{Elsevier}},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2018.07.077},
  abstract = {Context: Virtual machines provide isolation of services at the cost of hypervisors and more resource usage. This spurred the growth of systems like Docker that enable single hosts to isolate several applications, similar to VMs, within a low-overhead abstraction called containers. Motivation: Although containers tout low overhead performance, how much do they increase energy use? Methodology: This work statistically compares the energy consumption of three application workloads in Docker and on bare-metal Linux. Results: In all cases, there was a statistically significant (t-test and Wilcoxon p\,{$<$}\,.05) increase in energy consumption when running tests in Docker, mostly due to the performance of I/O system calls. Developers worried about I/O overhead could consider baremetal deployments over Docker container deployments.},
  keywords = {Cloud computing,Containerization,docker,Docker,Energy consumption,Microservice,Virtualization},
  file = {/Users/chakibbelgaid/Zotero/storage/QEGG5LGV/Santos et al. - 2018 - How does docker affect energy consumption Evaluat.pdf;/Users/chakibbelgaid/Zotero/storage/CKBCUN8V/S0164121218301456.html;/Users/chakibbelgaid/Zotero/storage/TXRPDKPU/S0164121218301456.html}
}

@article{saudrais_petit_nodate-1,
  title = {{Le petit typographe rationnel}},
  author = {Saudrais, Eddie},
  pages = {15},
  langid = {french},
  file = {/Users/chakibbelgaid/Zotero/storage/QY2NQVHZ/Saudrais - Le petit typographe rationnel.pdf}
}

@article{shepard_livelab_2011-1,
  title = {{{LiveLab}}: {{Measuring Wireless Networks}} and {{Smartphone Users}} in the {{Field}}},
  shorttitle = {{{LiveLab}}},
  author = {Shepard, Clayton and Rahmati, Ahmad and Tossell, Chad and Zhong, Lin and Kortum, Phillip},
  year = {2011},
  month = jan,
  journal = {SIGMETRICS Perform. Eval. Rev.},
  volume = {38},
  number = {3},
  pages = {15--20},
  issn = {0163-5999},
  doi = {10.1145/1925019.1925023},
  abstract = {We present LiveLab, a methodology to measure real-world smartphone usage and wireless networks with a reprogrammable indevice logger designed for long-term user studies. We discuss the challenges of privacy protection and power impact in LiveLab and offer our solutions. We present an iPhone 3GS based deployment of LiveLab with 25 users intended for one year. Early results from the data collection so far highlight the unique strengths and potential of LiveLab. We have two objectives in this position paper. First, we demonstrate the feasibility and capability of LiveLab. By sharing our experience, we seek to advocate LiveLab as a network and user measurement methodology. Second, we present our preliminary findings, and seek feedback from the community regarding what data to collect.}
}

@article{sokol_performance-benchmark_nodate-1,
  title = {{Ein Performance-Benchmark f\"ur Java-Web-Frameworks Diplomarbeit}},
  author = {Sokol, Christophe},
  pages = {24},
  langid = {german},
  file = {/Users/chakibbelgaid/Zotero/storage/Q3BVMA4F/Sokol - Ein Performance-Benchmark für Java-Web-Frameworks .pdf}
}

@article{sonnenwald2003evaluating,
  title = {Evaluating a Scientific Collaboratory: {{Results}} of a Controlled Experiment},
  author = {Sonnenwald, Diane H and Whitton, Mary C and Maglaughlin, Kelly L},
  year = {2003},
  journal = {ACM Transactions on Computer-Human Interaction (TOCHI)},
  volume = {10},
  number = {2},
  pages = {150--176},
  publisher = {{ACM New York, NY, USA}}
}

@misc{stephen_evaluate_2012,
  title = {Evaluate Collaboratory Technical Report: {{Can}} You Trust Your Experimental Results?},
  author = {Blackburn, Stephen M. and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F. and Nelson Amaral, Jos{\'e} and Tuma, Petr and Pankratius, Victor and Nystrom, Nathaniel and Moret, Philippe and Kalibera, Tomas and {al.}, et},
  year = {2012},
  month = feb,
  publisher = {{inf.usi.ch}}
}

@article{strubell_energy_2019-1,
  ids = {strubell2019energy},
  title = {Energy and {{Policy Considerations}} for {{Deep Learning}} in {{NLP}}},
  author = {Strubell, Emma and Ganesh, Ananya and McCallum, Andrew},
  year = {2019},
  month = jun,
  journal = {arXiv:1906.02243 [cs]},
  eprint = {1906.02243},
  eprinttype = {arxiv},
  primaryclass = {cs},
  abstract = {Recent progress in hardware and methodology for training neural networks has ushered in a new generation of large networks trained on abundant data. These models have obtained notable gains in accuracy across many NLP tasks. However, these accuracy improvements depend on the availability of exceptionally large computational resources that necessitate similarly substantial energy consumption. As a result these models are costly to train and develop, both financially, due to the cost of hardware and electricity or cloud compute time, and environmentally, due to the carbon footprint required to fuel modern tensor processing hardware. In this paper we bring this issue to the attention of NLP researchers by quantifying the approximate financial and environmental costs of training a variety of recently successful neural network models for NLP. Based on these findings, we propose actionable recommendations to reduce costs and improve equity in NLP research and practice.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computation and Language},
  note = {Comment: In the 57th Annual Meeting of the Association for Computational Linguistics (ACL). Florence, Italy. July 2019
\par
Comment: In the 57th Annual Meeting of the Association for Computational Linguistics (ACL). Florence, Italy. July 2019},
  file = {/Users/chakibbelgaid/Zotero/storage/GR5RNJDL/Strubell et al. - 2019 - Energy and Policy Considerations for Deep Learning.pdf;/Users/chakibbelgaid/Zotero/storage/TT2PAEY3/1906.html;/Users/chakibbelgaid/Zotero/storage/UUHJBFTL/1906.html}
}

@inproceedings{subramaniam_towards_2013-1,
  title = {Towards Energy-Proportional Computing for Enterprise-Class Server Workloads},
  author = {Subramaniam, Balaji and Feng, Wu-chun},
  year = {2013},
  pages = {15},
  publisher = {{ACM Press}},
  doi = {10.1145/2479871.2479878},
  abstract = {Massive data centers housing thousands of computing nodes have become commonplace in enterprise computing, and the power consumption of such data centers is growing at an unprecedented rate. Adding to the problem is the inability of the servers to exhibit energy proportionality, i.e., provide energy-efficient execution under all levels of utilization, which diminishes the overall energy efficiency of the data center. It is imperative that we realize effective strategies to control the power consumption of the server and improve the energy efficiency of data centers. With the advent of Intel Sandy Bridge processors, we have the ability to specify a limit on power consumption during runtime, which creates opportunities to design new power-management techniques for enterprise workloads and make the systems that they run on more energy proportional.},
  isbn = {978-1-4503-1636-1},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/4EIXBPBJ/Subramaniam and Feng - 2013 - Towards energy-proportional computing for enterpri.pdf}
}

@article{sung_canal_2018-1,
  title = {{{CANAL}}: {{A Cache Timing Analysis Framework}} via {{LLVM Transformation}}},
  author = {Sung, Chungha and Paulsen, Brandon and Wang, Chao},
  year = {2018},
  pages = {4},
  abstract = {A unified modeling framework for non-functional properties of a program is essential for research in software analysis and verification, since it reduces burdens on individual researchers to implement new approaches and compare existing approaches. We present CANAL, a framework that models the cache behaviors of a program by transforming its intermediate representation (IR) in the LLVM compiler. CANAL inserts auxiliary variables and LLVM instructions over these variables, to allow standard verification tools to handle a new class of cache timing related properties, e.g., for computing the worst-case execution time (WCET) and detecting side-channel information leaks. We demonstrate the effectiveness of CANAL using three LLVM-based verification tools: KLEE, SMACK and Crab-llvm. We also confirm the accuracy of our cache model by comparing with the CPU cycle-accurate simulation results of GEM5. CANAL is available on GitHub1 and YouTube2.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/TVKIWJ34/Sung et al. - 2018 - CANAL A Cache Timing Analysis Framework via LLVM .pdf}
}

@techreport{the_shift_project_lean_2019,
  title = {Lean {{ICT}} - {{Towards Digital Sobriety}}},
  author = {{The shift Project}},
  year = {2019},
  month = mar,
  pages = {90},
  langid = {english}
}

@incollection{tratt_chapter_2009-1,
  title = {Chapter 5 {{Dynamically Typed Languages}}},
  booktitle = {Advances in {{Computers}}},
  author = {Tratt, Laurence},
  year = {2009},
  month = jan,
  volume = {77},
  pages = {149--184},
  publisher = {{Elsevier}},
  doi = {10.1016/S0065-2458(09)01205-4},
  abstract = {Dynamically typed languages such as Python and Ruby have experienced a rapid grown in popularity in recent times. However, there is much confusion as to what makes these languages interesting relative to statically typed languages, and little knowledge of their rich history. In this chapter, I explore the general topic of dynamically typed languages, how they differ from statically typed languages, their history, and their defining features.},
  file = {/Users/chakibbelgaid/Zotero/storage/4E5UCRER/S0065245809012054.html;/Users/chakibbelgaid/Zotero/storage/DCRDHHNN/S0065245809012054.html}
}

@inproceedings{Tsantalis:ICSE:2018:RefactoringMiner,
  title = {Accurate and Efficient Refactoring Detection in Commit History},
  booktitle = {Proceedings of the 40th International Conference on Software Engineering},
  author = {Tsantalis, Nikolaos and Mansouri, Matin and Eshkevari, Laleh M. and Mazinanian, Davood and Dig, Danny},
  year = {2018},
  series = {{{ICSE}} '18},
  pages = {483--494},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3180155.3180206},
  acmid = {3180206},
  isbn = {978-1-4503-5638-1},
  keywords = {abstract syntax tree,accuracy,commit,Git,Oracle,refactoring}
}

@article{Tsantalis:TSE:2020:RefactoringMiner2.0,
  title = {{{RefactoringMiner}} 2.0},
  author = {Tsantalis, Nikolaos and Ketkar, Ameya and Dig, Danny},
  year = {2020},
  journal = {IEEE Transactions on Software Engineering},
  doi = {10.1109/TSE.2020.3007722}
}

@article{tschanz_adaptive_2002,
  title = {Adaptive Body Bias for Reducing Impacts of Die-to-Die and within-{{Die}} Parameter Variations on Microprocessor Frequency and Leakage},
  author = {Tschanz, J.W. and Kao, J.T. and Narendra, S.G. and Nair, R. and Antoniadis, D.A. and Chandrakasan, A.P. and De, V.},
  year = {2002},
  month = nov,
  journal = {IEEE Journal of Solid-State Circuits},
  volume = {37},
  number = {11},
  issn = {0018-9200},
  langid = {english},
  optabstract = {Bidirectional adaptive body bias (ABB) is used to compensate for die-to-die parameter variations by applying an optimum pMOS and nMOS body bias voltage to each die which maximizes the die frequency subject to a power constraint. Measurements on a 150-nm CMOS testchip which incorporates on-chip ABB, show that ABB reduces variation in die frequency by a factor of seven, while improving the die acceptance rate. An enhancement of this technique, that compensates for within-die parameter variations as well, increases the number of dies accepted in the highest frequency bin. ABB is therefore shown to provide bin split improvement in the presence of increasing process parameter variations.},
  optdoi = {10.1109/JSSC.2002.803949},
  optpages = {1396-1402}
}

@book{urdan_statistics_2010-1,
  title = {Statistics in {{Plain English}}, {{Third Edition}}.},
  author = {Urdan, Timothy C},
  year = {2010},
  publisher = {{Taylor \& Francis}},
  address = {{Hoboken}},
  abstract = {This inexpensive paperback provides a brief, simple overview of statistics to help readers gain a better understanding of how statistics work and how to interpret them correctly. Each chapter describes a different statistical technique, ranging from basic concepts like central tendency and describing distributions to more advanced concepts such as t tests, regression, repeated measures ANOVA, and factor analysis. Each chapter begins with a short description of the statistic and when it should be used. This is followed by a more in-depth explanation of how the statistic works. Finally, each cha.},
  isbn = {978-0-203-85117-3},
  langid = {english},
  annotation = {OCLC: 781311754},
  note = {OCLC: 781311754},
  file = {/Users/chakibbelgaid/Zotero/storage/4JK3GBJV/Urdan - 2010 - Statistics in Plain English, Third Edition..pdf}
}

@article{van_der_kouwe_benchmarking_2018-1,
  ids = {DBLP:journals/corr/abs-1801-02381,crimes},
  title = {Benchmarking {{Crimes}}: {{An Emerging Threat}} in {{Systems Security}}},
  shorttitle = {Benchmarking {{Crimes}}},
  author = {{van der Kouwe}, Erik and Andriesse, Dennis and Bos, Herbert and Giuffrida, Cristiano and Heiser, Gernot},
  year = {2018},
  month = jan,
  journal = {arXiv:1801.02381 [cs]},
  eprint = {1801.02381},
  eprinttype = {arxiv},
  primaryclass = {cs},
  abstract = {Properly benchmarking a system is a difficult and intricate task. Unfortunately, even a seemingly innocuous benchmarking mistake can compromise the guarantees provided by a given systems security defense and also put its reproducibility and comparability at risk. This threat is particularly insidious as it is generally not a result of malice and can easily go undetected by both authors and reviewers. Moreover, as modern defenses often trade off security for performance in an attempt to find an ideal design point in the performance-security space, the damage caused by benchmarking mistakes is increasingly worrisome. To analyze the magnitude of the phenomenon, we identify a set of 22 "benchmarking crimes" that threaten the validity of systems security evaluations and perform a survey of 50 defense papers published in top venues. To ensure the validity of our results, we perform the complete survey twice, with two independent readers. We find only a very small number of disagreements between readers, showing that our assessment of benchmarking crimes is highly reproducible. We show that benchmarking crimes are widespread even in papers published at tier-1 venues. We find that tier-1 papers commit an average of five benchmarking crimes and we find only a single paper in our sample that committed no benchmarking crimes. Moreover, we find that the scale of the problem is constant over time, suggesting that the community is not yet addressing it despite the problem being now more relevant than ever. This threatens the scientific process, which relies on reproducibility and comparability to ensure that published research advances the state of the art. We hope to raise awareness of these issues and provide recommendations to improve benchmarking quality and safeguard the scientific process in our community.},
  archiveprefix = {arXiv},
  bibopturl = {https://dblp.org/rec/bib/journals/corr/abs-1801-02381},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  opturl = {http://arxiv.org/abs/1801.02381},
  keywords = {Computer Science - Cryptography and Security},
  timestamp = {Mon, 13 Aug 2018 16:46:44 +0200},
  file = {/Users/chakibbelgaid/Zotero/storage/ZRL8MBQR/van der Kouwe et al. - 2018 - Benchmarking Crimes An Emerging Threat in Systems.pdf;/Users/chakibbelgaid/Zotero/storage/CUTIVI4J/1801.html;/Users/chakibbelgaid/Zotero/storage/G7PFS5HM/1801.html}
}

@inproceedings{vereecken_overall_2010-1,
  title = {Overall {{ICT}} Footprint and Green Communication Technologies},
  booktitle = {2010 4th {{International Symposium}} on {{Communications}}, {{Control}} and {{Signal Processing}} ({{ISCCSP}})},
  author = {Vereecken, W. and Heddeghem, W. Van and Colle, D. and Pickavet, M. and Demeester, P.},
  year = {2010},
  month = mar,
  pages = {1--6},
  doi = {10.1109/ISCCSP.2010.5463327},
  abstract = {Green communication technologies currently receive a lot of attention. In this paper we give an overview of the environmental issues related to communication technologies en present an estimation of the overall ICT footprint. Additionally we present some approaches on how to reduce this footprint and how ICT can assist in other sectors reducing their footprint.},
  keywords = {Carbon dioxide,Communication system control,Communications technology,Energy consumption,Energy efficiency,environmental factors,environmental issues,green communication technologies,information technology,Ores,overall ICT footprint,Process control,Recycling,Signal processing,Waste materials},
  file = {/Users/chakibbelgaid/Zotero/storage/8RDP4UKP/Vereecken et al. - 2010 - Overall ICT footprint and green communication tech.pdf;/Users/chakibbelgaid/Zotero/storage/FS6WUZS6/5463327.html;/Users/chakibbelgaid/Zotero/storage/IBJD2CH2/5463327.html}
}

@inproceedings{von2016variations,
  title = {Variations in Cpu Power Consumption},
  booktitle = {Proceedings of the 7th {{ACM}}/{{SPEC}} on International Conference on Performance Engineering},
  author = {{von Kistowski}, J{\'o}akim and Block, Hansfried and Beckett, John and Spradling, Cloyce and Lange, Klaus-Dieter and Kounev, Samuel},
  year = {2016},
  pages = {147--158}
}

@article{w_g_p_silva_evaluation_2010,
  title = {Evaluation of the Impact of Code Refactoring on Embedded Software Efficiency},
  author = {{W G P Silva} and {Lisane Brisolara} and Corr{\^e}a, Ulisses Brisolara and Carro, Luigi},
  year = {2010},
  journal = {Unpublished},
  doi = {10.13140/2.1.1481.8249},
  abstract = {The increasing complexity of embedded software and the hard timeto-market requirements, motivate to the use of object-oriented languages. However, this usage can negatively impact on energy consumption as well as on performance. Code refactoring are techniques that change the code in order to improve the software quality. This paper analyzes how the inline method refactoring, a software optimization technique, can impact on the performance and energy of embedded software written in Java. Three different applications are evaluated in order to discuss this impact.},
  langid = {english}
}

@article{wang_experimental_nodate-1,
  title = {Experimental {{Characterization}} of {{Variation}} in {{Power Consumption}} for {{Processors}} of {{Different}} Generations},
  author = {Wang, Yewan and N{\"o}rtersh{\"a}user, David and Masson, St{\'e}phane Le and Menaud, Jean-Marc},
  pages = {10},
  abstract = {Data centers are energy-hungry facilities. Building energy consumption predictive models for servers is one of the solutions to use efficiently the resources. However, physical experiments have shown that even under the same conditions, identical processors consume different amount of energy to complete the same task. While this manufacturing variability has been observed and studied before, there is lack of evidence supporting the hypotheses due to limited sampling data, especially from the thermal characteristics. In this article, we compare the power consumption among identical processors for two Intel processors series with the same TDP (Thermal Design Power) but from different generations. The observed power variation of the processors in newer generation is much greater than the older one. Then, we propose our hypotheses for the underlying causes and validate them under precisely controlled environmental conditions. The experimental results show that, with the increase of transistor densities, difference of thermal characteristics becomes larger among processors, which has non-negligible contribution to the variation of power consumption for modern processors. This observation reminds us of re-calibrating the precision of the current energy predictive models. The manufacturing variability has to be considered when building energy predictive models for homogeneous clusters.},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/BAR7YZEN/Wang et al. - Experimental Characterization of Variation in Powe.pdf}
}

@article{wang_grpc_1993,
  title = {{{GRPC}}: A Communication Cooperation Mechanism in Distributed Systems},
  shorttitle = {{{GRPC}}},
  author = {Wang, Xingwei and Zhao, Hong and Zhu, Jiakeng},
  year = {1993},
  month = jul,
  journal = {ACM SIGOPS Operating Systems Review},
  volume = {27},
  number = {3},
  pages = {75--86},
  issn = {0163-5980},
  doi = {10.1145/155870.155881},
  abstract = {RPC (Remote Procedure Call) is very popular in distributed application design. However, most existing RPC systems have some defects on parallelism and reliability and transparency, they can only support point-to-point and(or) broadcast communication. We try to bring the process group concept into RPC systems and present a new kind of communication cooperation mechanism supporting the cooperation among distributed entities in distributed systems. We call it GRPC(Group Remote Procedure Call) mechanism. According to different application background, the related GRPC mechanism are named lookup, function-convergence and update GRPC. The prototype systems of these three specific classes of GRPC mechanisms have been implemented in the local area network which consists of SUN 4 workstations. The performance evaluation on these prototype systems has been made. Practice has shown: the GRPC mechanism can not only improve the parallelism, reliability and transparency of RPC systems, but also enable RPC systems to support group communication.},
  file = {/Users/chakibbelgaid/Zotero/storage/MH7STNI4/Wang et al. - 1993 - GRPC a communication cooperation mechanism in dis.pdf}
}

@article{wang_potential_2018,
  ids = {wang2018potential},
  title = {Potential Effects on Server Power Metering and Modeling},
  author = {Wang, Yewan and N{\"o}rtersh{\"a}user, David and Le Masson, St{\'e}phane and Menaud, Jean-Marc},
  year = {2018},
  month = nov,
  journal = {Wireless Networks},
  publisher = {{Springer}},
  issn = {1022-0038, 1572-8196},
  langid = {english},
  optabstract = {Cloud datacenters are compute facilities formed by hundreds or even thousands of servers. With the increasing demand of cloud services, energy efficiency of servers in data center has become a significant issue. The knowledge of the energy consumption corresponding to hardware and software configuration is important for operators to optimize energy efficiency of a data center. We currently work on a predictive model for energy consumption of a server, with inputs as service provided, hardware material equipped (type and quantity of processor, memory and hard drive) and technical environment (energy conversion and cooling). In this article, we characterize some potential factors on the power variation of the servers, such as: original fabrication, position in the rack, voltage variation and temperature of components on motherboard. The results show that certain factors, such as original fabrication, ambient temperature and CPU temperature, have noticeable effects on the power consumption of servers. The experimental results emphasize the importance of adding these external factors into the metric, so as to build an energy predictive model adaptable in real situations.},
  optdoi = {10.1007/s11276-018-1882-1}
}

@article{wang1993grpc,
  title = {{{GRPC}}: {{A}} Communication Cooperation Mechanism in Distributed Systems},
  author = {Wang, Xingwei and Zhao, Hong and Zhu, Jiakeng},
  year = {1993},
  journal = {ACM SIGOPS Operating Systems Review},
  volume = {27},
  number = {3},
  pages = {75--86},
  publisher = {{ACM New York, NY, USA}}
}

@inproceedings{wen_watching_2018-1,
  title = {Watching for {{Software Inefficiencies}} with {{Witch}}},
  booktitle = {Proceedings of the {{Twenty-Third International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Wen, Shasha and Liu, Xu and Byrne, John and Chabbi, Milind},
  year = {2018},
  series = {{{ASPLOS}} '18},
  pages = {332--347},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3173162.3177159},
  abstract = {Inefficiencies abound in complex, layered software. A variety of inefficiencies show up as wasteful memory operations. Many existing tools instrument every load and store instruction to monitor memory, which significantly slows execution and consumes enormously extra memory. Our lightweight framework, Witch, samples consecutive accesses to the same memory location by exploiting two ubiquitous hardware features: the performance monitoring units (PMU) and debug registers. Witch performs no instrumentation. Hence, witchcraft---tools built atop Witch---can detect a variety of software inefficiencies while introducing negligible slowdown and insignificant memory consumption and yet maintaining accuracy comparable to exhaustive instrumentation tools. Witch allowed us to scale our analysis to a large number of code bases. Guided by witchcraft, we detected several performance problems in important code bases; eliminating these inefficiencies resulted in significant speedups. This article is summarized in: the morning paper an interesting/influential/important paper from the world of CS every weekday morning, as selected by Adrian Colyer},
  isbn = {978-1-4503-4911-6},
  keywords = {debug registers,PMU,profiling,sampling,software inefficiency detection},
  file = {/Users/chakibbelgaid/Zotero/storage/6MURAMU7/Wen et al. - 2018 - Watching for Software Inefficiencies with Witch.pdf}
}

@article{whitley_statistics_2002-1,
  title = {Statistics Review 1: {{Presenting}} and Summarising Data},
  shorttitle = {Statistics Review 1},
  author = {Whitley, Elise and Ball, Jonathan},
  year = {2002},
  journal = {Critical Care},
  volume = {6},
  number = {1},
  pages = {66--71},
  issn = {1364-8535},
  abstract = {The present review is the first in an ongoing guide to medical statistics, using specific examples from intensive care. The first step in any analysis is to describe and summarize the data. As well as becoming familiar with the data, this is also an opportunity to look for unusually high or low values (outliers), to check the assumptions required for statistical tests, and to decide the best way to categorize the data if this is necessary. In addition to tables and graphs, summary values are a convenient way to summarize large amounts of information. This review introduces some of these measures. It describes and gives examples of qualitative data (unordered and ordered) and quantitative data (discrete and continuous); how these types of data can be represented figuratively; the two important features of a quantitative dataset (location and variability); the measures of location (mean, median and mode); the measures of variability (range, interquartile range, standard deviation and variance); common distributions of clinical data; and simple transformations of positively skewed data.},
  pmcid = {PMC137399},
  pmid = {11940268},
  file = {/Users/chakibbelgaid/Zotero/storage/7YEEL5WN/Whitley and Ball - 2002 - Statistics review 1 Presenting and summarising da.pdf}
}

@inproceedings{williams_dynamic_2010-1,
  title = {Dynamic {{Interpretation}} for {{Dynamic Scripting Languages}}},
  booktitle = {Proceedings of the 8th {{Annual IEEE}}/{{ACM International Symposium}} on {{Code Generation}} and {{Optimization}}},
  author = {Williams, Kevin and McCandless, Jason and Gregg, David},
  year = {2010},
  series = {{{CGO}} '10},
  pages = {278--287},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1772954.1772993},
  abstract = {Dynamic scripting languages offer programmers increased flexibility by allowing properties of programs to be defined at run-time. Typically, program execution begins with an interpreter where type checks are implemented using conditional statements. Recent JIT compilers have begun removing run-time checks by specializing native code to program properties discovered at JIT time. This paper presents a novel intermediate representation for scripting languages that explicitly encodes types of variables. The dynamic representation is a flow graph, where each node is a specialized virtual instruction and each edge directs program flow based on control and type changes in the program. The interpreter thus performs specialized execution of whole programs. We present techniques for the efficient interpretation of our representation showing speed-ups of greater than 2x over static interpretation, with an average speed-up of approximately 1.3x.},
  isbn = {978-1-60558-635-9},
  keywords = {dynamic languages,interpreter optimization,type specialization},
  file = {/Users/chakibbelgaid/Zotero/storage/LUGGC6SM/Williams et al. - 2010 - Dynamic Interpretation for Dynamic Scripting Langu.pdf}
}

@article{yet2016cross,
  title = {Cross-Language Compiler Benchmarking},
  author = {Yet, Are We Fast},
  year = {2016}
}

@inproceedings{zaman_extracting_2018-1,
  title = {Extracting Implicit Programming Rules: Comparing Static and Dynamic Approaches},
  shorttitle = {Extracting Implicit Programming Rules},
  booktitle = {Proceedings of the 7th {{International Workshop}} on {{Software Mining}} - {{SoftwareMining}} 2018},
  author = {Zaman, Tarannum Shaila and Yu, Tingting},
  year = {2018},
  pages = {1--7},
  publisher = {{ACM Press}},
  address = {{Montpellier, France}},
  doi = {10.1145/3242887.3242889},
  abstract = {Programs often follow implicit programming rules, such as, function call A must be followed by function call B. Rules of such kinds are rarely documented by developers. Nevertheless, programming rules play an important role in software testing and maintenance. For example, the rules can be used as test oracles to detect violations. If a programmer can be notified of these rules before updating the source code, the chances of generating defects due to rule violations might be minimized. Prior works have used static and dynamic analysis techniques to extract implicit programming rules, but none compares the effectiveness of the two techniques. In this paper, we have undertaken an empirical study to compare the two techniques when they are being used for extracting programming rules. Our results indicate that the performance of the dynamic analysis technique depends on the number and the diversity of the traces. Moreover, the dynamic analysis technique generates more precise rules than the static analysis technique if a diverse and sufficient number of test cases are provided.},
  isbn = {978-1-4503-5975-7},
  langid = {english},
  file = {/Users/chakibbelgaid/Zotero/storage/YDKVVTZJ/Zaman and Yu - 2018 - Extracting implicit programming rules comparing s.pdf}
}

@article{zhang_extending_2020-1,
  title = {Extending {{Performance-Energy Trade-offs}} via {{Dynamic Core Scaling}}},
  author = {Zhang, W. and Zhang, H. and Lach, J.},
  year = {2020},
  journal = {IEEE Transactions on Computers},
  pages = {1--1},
  issn = {1557-9956},
  doi = {10.1109/TC.2020.3029306},
  abstract = {As transistor scaling is reaching its limit, the viable supply voltage range where DVFS can operate is shrinking, which limits its effectiveness. To extend the performance-energy trade-off capabilities in modern processors, this paper proposes dynamic core scaling (DCS) that does not rely on voltage scaling. DCS dynamically adjusts the active superscalar datapath resources so that programs run at a given percentage of their maximum speed while minimizing energy consumption at the same time. Since DCS does not need voltage scaling, it can be combined with DVFS to achieve greater energy savings. To effectively manage performance-energy trade-offs using a combination of DCS and DVFS, this paper proposes an oracle controller that demonstrates the optimal control strategy, and two practical controllers that are applicable in real implementations. Evaluations using an 8-way superscalar processor implemented in 45nm circuit show that DCS is more effective in performance-energy trade-offs than DVFS at the high performance end for a number of SPEC CPU2000 benchmarks. When used together with DVFS, DCS saves an additional 20\% of a full-size core's energy on average. At the minimum operating voltage, DVFS hits its limit, while DCS is still able to achieve an average of 46\% further energy reduction.},
  keywords = {Calibration,Energy consumption,Hardware,Pipelines,Program processors,Registers,Runtime}
}


