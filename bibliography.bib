
@book{kahraman_uncertainty_2012,
	title = {Uncertainty {Modeling} in {Knowledge} {Engineering} and {Decision} {Making} - {Proceedings} of the 10th {International} {Flins} {Conference}},
	isbn = {978-981-4417-73-0},
	abstract = {FLINS, originally an acronym for Fuzzy Logic and Intelligent Technologies in Nuclear Science, is now extended to Computational Intelligence for applied research. The contributions to the 10th of FLINS conference cover state-of-the-art research, development, and technology for computational intelligence systems, both from the foundations and the applications points-of-view.},
	language = {en},
	publisher = {World Scientific},
	author = {Kahraman, Cengiz and Bozbura, Faik Tunc and Kerre, Etienne E.},
	year = {2012},
	note = {Google-Books-ID: j9K2MkNlhqQC},
	keywords = {Computers / Intelligence (AI) \& Semantics, Computers / Machine Theory, Computers / Software Development \& Engineering / General},
}

@article{redondo_comprehensive_2015,
	title = {A {Comprehensive} {Evaluation} of {Common} {Python} {Implementations}},
	volume = {32},
	issn = {0740-7459},
	doi = {10.1109/MS.2014.104},
	abstract = {Python is a widely used general-purpose dynamic language. Owing to its popularity, many implementations exist for the two distinct Python 2 and Python 3 language versions. Researchers evaluated seven implementations of both language versions to facilitate the selection of one of them. For this purpose, they carefully selected 523 programs to execute in each implementation. They evaluated run-time performance and memory consumption and investigated each implementation's important qualitative characteristics.},
	number = {4},
	journal = {IEEE Software},
	author = {Redondo, J. M. and Ortin, F.},
	month = jul,
	year = {2015},
	keywords = {benchmark suite, Benchmark testing, dynamic languages, Dynamic programming, general-purpose dynamic language, high level languages, Java, JIT compilation, just-in-time compilation, memory consumption, Memory management, performance analysis, Python, Python 2 language versions, Python 3 language version, Python implementations, run-time performance, Runtime, software development, software engineering, storage management, Visual BASIC},
	pages = {76--84},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/P5WZ4KZV/Redondo and Ortin - 2015 - A Comprehensive Evaluation of Common Python Implem.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/UUCH8CTG/Redondo and Ortin - 2015 - A Comprehensive Evaluation of Common Python Implem.pdf:application/pdf},
}

@article{boettiger_introduction_2015,
	title = {An {Introduction} to {Docker} for {Reproducible} {Research}},
	volume = {49},
	issn = {0163-5980},
	url = {http://doi.acm.org/10.1145/2723872.2723882},
	doi = {10.1145/2723872.2723882},
	abstract = {As computational work becomes more and more integral to many aspects of scientific research, computational reproducibility has become an issue of increasing importance to computer systems researchers and domain scientists alike. Though computational reproducibility seems more straight forward than replicating physical experiments, the complex and rapidly changing nature of computer environments makes being able to reproduce and extend such work a serious challenge. In this paper, I explore common reasons that code developed for one research project cannot be successfully executed or extended by subsequent researchers. I review current approaches to these issues, including virtual machines and workflow systems, and their limitations. I then examine how the popular emerging technology Docker combines several areas from systems research - such as operating system virtualization, cross-platform portability, modular re-usable elements, versioning, and a 'DevOps' philosophy, to address these challenges. I illustrate this with several examples of Docker use with a focus on the R statistical environment.},
	number = {1},
	urldate = {2018-05-22},
	journal = {SIGOPS Oper. Syst. Rev.},
	author = {Boettiger, Carl},
	month = jan,
	year = {2015},
	pages = {71--79},
}

@misc{noauthor_watching_2018,
	title = {Watching for software inefficiencies with {Witch}},
	url = {https://blog.acolyer.org/2018/04/24/watching-for-software-inefficiencies-with-witch/},
	abstract = {Watching for software inefficiencies with Witch Wen et al., ASPLOS’18 (The link above is to the ACM Digital Library, if you don’t have membership you should still be able to access the paper …},
	language = {en},
	urldate = {2018-04-24},
	month = apr,
	year = {2018},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/BVWTJEGN/2018 - Watching for software inefficiencies with Witch.html:text/html},
}

@article{akeret_hope_2015,
	title = {{HOPE}: {A} {Python} just-in-time compiler for astrophysical computations},
	volume = {10},
	issn = {22131337},
	shorttitle = {{HOPE}},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S2213133714000687},
	doi = {10.1016/j.ascom.2014.12.001},
	abstract = {The Python programming language is becoming increasingly popular for scientific applications due to its simplicity, versatility, and the broad range of its libraries. A drawback of this dynamic language, however, is its low runtime performance which limits its applicability for large simulations and for the analysis of large data sets, as is common in astrophysics and cosmology. While various frameworks have been developed to address this limitation, most focus on covering the complete language set, and either force the user to alter the code or are not able to reach the full speed of an optimised native compiled language. In order to combine the ease of Python and the speed of C++, we developed HOPE, a specialised Python just-in-time (JIT) compiler designed for numerical astrophysical applications. HOPE focuses on a subset of the language and is able to translate Python code into C++ while performing numerical optimisation on mathematical expressions at runtime. To enable the JIT compilation, the user only needs to add a decorator to the function definition. We assess the performance of HOPE by performing a series of benchmarks and compare its execution speed with that of plain Python, C++ and the other existing frameworks. We find that HOPE improves the performance compared to plain Python by a factor of 2 to 120, achieves speeds comparable to that of C++, and often exceeds the speed of the existing solutions. We discuss the differences between HOPE and the other frameworks, as well as future extensions of its capabilities. The fully documented HOPE package is available at http://hope.phys.ethz.ch and is published under the GPLv3 license on PyPI and GitHub.},
	language = {en},
	urldate = {2018-03-27},
	journal = {Astronomy and Computing},
	author = {Akeret, J. and Gamper, L. and Amara, A. and Refregier, A.},
	month = apr,
	year = {2015},
	pages = {1--8},
	file = {Akeret et al. - 2015 - HOPE A Python just-in-time compiler for astrophys.pdf:/Users/chakibbelgaid/Zotero newone/storage/NNDPH7QC/Akeret et al. - 2015 - HOPE A Python just-in-time compiler for astrophys.pdf:application/pdf},
}

@inproceedings{abtahizadeh_how_2015,
	title = {How green are cloud patterns?},
	isbn = {978-1-4673-8590-9},
	url = {http://ieeexplore.ieee.org/document/7410295/},
	doi = {10.1109/PCCC.2015.7410295},
	abstract = {Cloud Patterns are abstract solutions to recurrent design problems in the cloud. Previous work has shown that these patterns can improve the Quality of Service (QoS) of cloud applications but their impact on energy consumption is still unknown. Yet, energy consumption is the biggest challenge that cloud computing systems (the backbone of today’s high-tech economy) face today. In fact, 10\% of the world’s electricity is now being consumed by servers, laptops, tablets and smartphones. Energy consumption has complex dependencies on the hardware platform, and the multiple software layers. The hardware, its ﬁrmware, the operating system, and the various software components used by a cloud application, all contribute to determining the energy footprint. Hence, even though increasing a data center efﬁciency will eventually improve energy efﬁciency, the internal design of cloud-based applications can be improved to lower energy consumption. In this paper, we conduct an empirical study on a RESTful multi-threaded application deployed in the cloud, to investigate the individual and the combined impact of three cloud patterns (e.g., Local Database proxy, Local Sharding Based Router and Priority Queue) on the energy consumption of cloud based applications. We measure the energy consumption using Power-API; an application programming interface (API) written in Java to monitor the energy consumed at the processlevel. Results show that cloud patterns can effectively reduce the energy consumption of a cloud application, but not in all cases. In general, there appear to be a trade-off between an improved response time of the application and the energy consumption. Developers and software architects can make use of these results to guide their design decisions.},
	language = {en},
	urldate = {2018-03-27},
	publisher = {IEEE},
	author = {Abtahizadeh, S. Amirhossein and Khomh, Foutse and Gueheneuc, Yann-Gael},
	month = dec,
	year = {2015},
	pages = {1--8},
	file = {Abtahizadeh et al. - 2015 - How green are cloud patterns.pdf:/Users/chakibbelgaid/Zotero newone/storage/QCXHHGZ5/Abtahizadeh et al. - 2015 - How green are cloud patterns.pdf:application/pdf},
}

@inproceedings{sahin_how_2014,
	title = {How do code refactorings affect energy usage?},
	isbn = {978-1-4503-2774-9},
	url = {http://dl.acm.org/citation.cfm?doid=2652524.2652538},
	doi = {10.1145/2652524.2652538},
	abstract = {Method: We conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly-used refactorings.
Results: We found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application. In addition, we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring.
Conclusion: The results from this and similar studies could be used to augment IDEs to help software developers build more energy eﬃcient software.},
	language = {en},
	urldate = {2018-03-27},
	publisher = {ACM Press},
	author = {Sahin, Cagri and Pollock, Lori and Clause, James},
	year = {2014},
	pages = {1--10},
	file = {Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf:/Users/chakibbelgaid/Zotero newone/storage/AVSGW65M/Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf:application/pdf},
}

@inproceedings{lam_numba_2015,
	title = {Numba: a {LLVM}-based {Python} {JIT} compiler},
	isbn = {978-1-4503-4005-2},
	shorttitle = {Numba},
	url = {http://dl.acm.org/citation.cfm?doid=2833157.2833162},
	doi = {10.1145/2833157.2833162},
	abstract = {Dynamic, interpreted languages, like Python, are attractive for domain-experts and scientists experimenting with new ideas. However, the performance of the interpreter is often a barrier when scaling to larger data sets. This paper presents a just-in-time compiler for Python that focuses in scientiﬁc and array-oriented computing. Starting with the simple syntax of Python, Numba compiles a subset of the language into eﬃcient machine code that is comparable in performance to a traditional compiled language. In addition, we share our experience in building a JIT compiler using LLVM[1].},
	language = {en},
	urldate = {2018-03-28},
	publisher = {ACM Press},
	author = {Lam, Siu Kwan and Pitrou, Antoine and Seibert, Stanley},
	year = {2015},
	pages = {1--6},
	file = {Lam et al. - 2015 - Numba a LLVM-based Python JIT compiler.pdf:/Users/chakibbelgaid/Zotero newone/storage/GX2BLGFY/Lam et al. - 2015 - Numba a LLVM-based Python JIT compiler.pdf:application/pdf},
}

@inproceedings{linares-vasquez_mining_2014,
	title = {Mining energy-greedy {API} usage patterns in {Android} apps: an empirical study},
	isbn = {978-1-4503-2863-0},
	shorttitle = {Mining energy-greedy {API} usage patterns in {Android} apps},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597085},
	doi = {10.1145/2597073.2597085},
	abstract = {Energy consumption of mobile applications is nowadays a hot topic, given the widespread use of mobile devices. The high demand for features and improved user experience, given the available powerful hardware, tend to increase the apps’ energy consumption. However, excessive energy consumption in mobile apps could also be a consequence of energy greedy hardware, bad programming practices, or particular API usage patterns. We present the largest to date quantitative and qualitative empirical investigation into the categories of API calls and usage patterns that—in the context of the Android development framework—exhibit particularly high energy consumption proﬁles. By using a hardware power monitor, we measure energy consumption of method calls when executing typical usage scenarios in 55 mobile apps from diﬀerent domains. Based on the collected data, we mine and analyze energy-greedy APIs and usage patterns. We zoom in and discuss the cases where either the anomalous energy consumption is unavoidable or where it is due to suboptimal usage or choice of APIs. Finally, we synthesize our ﬁndings into actionable knowledge and recipes for developers on how to reduce energy consumption while using certain categories of Android APIs and patterns.},
	language = {en},
	urldate = {2018-03-28},
	publisher = {ACM Press},
	author = {Linares-Vásquez, Mario and Bavota, Gabriele and Bernal-Cárdenas, Carlos and Oliveto, Rocco and Di Penta, Massimiliano and Poshyvanyk, Denys},
	year = {2014},
	pages = {2--11},
	file = {Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf:/Users/chakibbelgaid/Zotero newone/storage/HYQZPJP7/Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf:application/pdf},
}

@article{murri_performance_2013,
	title = {Performance of {Python} runtimes on a non-numeric scientiﬁc code},
	abstract = {The Python library FatGHol [FatGHoL] used in [Murri2012] to reckon the rational homology of the moduli space of Riemann surfaces is an example of a non-numeric scientiﬁc code: most of the processing it does is generating graphs (represented by complex Python objects) and computing their isomorphisms (a triple of Python lists; again a nested data structure). These operations are repeated many times over: for example, the spaces M0,6 and M1,4 are triangulated by 4’583’322 and 747’664 graphs, respectively.},
	language = {en},
	author = {Murri, Riccardo},
	year = {2013},
	pages = {6},
	file = {Murri - 2013 - Performance of Python runtimes on a non-numeric sc.pdf:/Users/chakibbelgaid/Zotero newone/storage/8LP2VCLF/Murri - 2013 - Performance of Python runtimes on a non-numeric sc.pdf:application/pdf},
}

@inproceedings{pinto_mining_2014,
	address = {New York, NY, USA},
	series = {{MSR} 2014},
	title = {Mining {Questions} {About} {Software} {Energy} {Consumption}},
	isbn = {978-1-4503-2863-0},
	url = {http://doi.acm.org/10.1145/2597073.2597110},
	doi = {10.1145/2597073.2597110},
	abstract = {A growing number of software solutions have been proposed to address application-level energy consumption problems in the last few years. However, little is known about how much software developers are concerned about energy consumption, what aspects of energy consumption they consider important, and what solutions they have in mind for improving energy efficiency. In this paper we present the first empirical study on understanding the views of application programmers on software energy consumption problems. Using StackOverflow as our primary data source, we analyze a carefully curated sample of more than 300 questions and 550 answers from more than 800 users. With this data, we observed a number of interesting findings. Our study shows that practitioners are aware of the energy consumption problems: the questions they ask are not only diverse -- we found 5 main themes of questions -- but also often more interesting and challenging when compared to the control question set. Even though energy consumption-related questions are popular when considering a number of different popularity measures, the same cannot be said about the quality of their answers. In addition, we observed that some of these answers are often flawed or vague. We contrast the advice provided by these answers with the state-of-the-art research on energy consumption. Our summary of software energy consumption problems may help researchers focus on what matters the most to software developers and end users.},
	urldate = {2018-03-28},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Pinto, Gustavo and Castor, Fernando and Liu, Yu David},
	year = {2014},
	keywords = {Practitioners, Q\&A, Software Energy Consumption},
	pages = {22--31},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/Q3SVE8QW/Pinto et al. - 2014 - Mining Questions About Software Energy Consumption.pdf:application/pdf},
}

@inproceedings{noureddine_preliminary_2012,
	title = {A preliminary study of the impact of software engineering on {GreenIT}},
	doi = {10.1109/GREENS.2012.6224251},
	abstract = {GreenIT has emerged as a discipline concerned with the optimization of software solutions with regards to their energy consumption. In this domain, most of state-of-the-art solutions offer limited or constraining approaches to monitor the energy consumption of a device or a process. In this paper, we therefore report on a runtime energy monitoring framework we developed to easily report on the energy consumption of system processes. Concretely, our approach adopts an OS-level library, called PowerAPI, which estimates the power consumption of processes according to different dimensions (CPU, network, etc.). In order to better understand potential energy leaks of legacy software, we use this library to study the impact of programming languages and algorithmic choices on the energy consumption. This preliminary study is based on an empirical evaluation of a eight implementations of the Towers of Hanoi problem.},
	booktitle = {2012 {First} {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	author = {Noureddine, A. and Bourdon, A. and Rouvoy, R. and Seinturier, L.},
	month = jun,
	year = {2012},
	keywords = {algorithmic choices, Energy, energy consumption, Energy consumption, energy leaks, environmental factors, Experimentation, GreenIT, Hanoi towers problem, Hardware, legacy software, Libraries, Measurement, Monitoring, OS-level library, Performance, power aware computing, Power demand, Power Model, POWERAPI, Program processors, programming languages, runtime energy monitoring framework, software engineering, software maintenance, software solutions optimization},
	pages = {21--27},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/7IE25Q7C/6224251.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/V58A29BC/Noureddine et al. - 2012 - A preliminary study of the impact of software engi.pdf:application/pdf},
}

@article{oliphant_python_2007,
	title = {Python for {Scientific} {Computing}},
	volume = {9},
	issn = {1521-9615},
	doi = {10.1109/MCSE.2007.58},
	abstract = {Python is an excellent "steering" language for scientific codes written in other languages. However, with additional basic tools, Python transforms into a high-level language suited for scientific and engineering code that's often fast enough to be immediately useful but also flexible enough to be sped up with additional extensions.},
	number = {3},
	journal = {Computing in Science Engineering},
	author = {Oliphant, T. E.},
	month = may,
	year = {2007},
	note = {Number: 3},
	keywords = {Application software, computer languages, Embedded software, high level languages, High level languages, high-level language, Internet, Libraries, Prototypes, Python, scientific codes, scientific computing, Scientific computing, scientific programming, Software standards, Standards development, steering language, Writing},
	pages = {10--20},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/FUZR4AFP/4160250.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/4I2U5KQR/Oliphant - 2007 - Python for Scientific Computing.pdf:application/pdf},
}

@article{arnold_survey_2005,
	title = {A {Survey} of {Adaptive} {Optimization} in {Virtual} {Machines}},
	volume = {93},
	issn = {0018-9219},
	doi = {10.1109/JPROC.2004.840305},
	abstract = {Virtual machines face significant performance challenges beyond those confronted by traditional static optimizers. First, portable program representations and dynamic language features, such as dynamic class loading, force the deferral of most optimizations until runtime, inducing runtime optimization overhead. Second, modular program representations preclude many forms of whole-program interprocedural optimization. Third, virtual machines incur additional costs for runtime services such as security guarantees and automatic memory management. To address these challenges, vendors have invested considerable resources into adaptive optimization systems in production virtual machines. Today, mainstream virtual machine implementations include substantial infrastructure for online monitoring and profiling, runtime compilation, and feedback-directed optimization. As a result, adaptive optimization has begun to mature as a widespread production-level technology. This paper surveys the evolution and current state of adaptive optimization technology in virtual machines.},
	number = {2},
	journal = {Proceedings of the IEEE},
	author = {Arnold, M. and Fink, S. J. and Grove, D. and Hind, M. and Sweeney, P. F.},
	month = feb,
	year = {2005},
	note = {Number: 2},
	keywords = {Adaptive optimization, adaptive optimization systems, Adaptive systems, automatic memory management, Condition monitoring, Costs, dynamic optimization, feedback directed optimization, feedback-directed optimization (FDO), Memory management, modular program representations, online monitoring, online profiling, optimisation, optimising compilers, Optimized production technology, production level technology, Production systems, Runtime, runtime compilation, Security, software performance evaluation, static optimizers, Virtual machine monitors, virtual machines, Virtual machining},
	pages = {449--466},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/XJ7XEFUK/1386662.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/K6UKJ9X8/Arnold et al. - 2005 - A Survey of Adaptive Optimization in Virtual Machi.pdf:application/pdf},
}

@inproceedings{hasan_energy_2016,
	title = {Energy {Profiles} of {Java} {Collections} {Classes}},
	doi = {10.1145/2884781.2884869},
	abstract = {We created detailed profiles of the energy consumed by common operations done on Java List, Map, and Set abstractions. The results show that the alternative data types for these abstractions differ significantly in terms of energy consumption depending on the operations. For example, an ArrayList consumes less energy than a LinkedList if items are inserted at the middle or at the end, but consumes more energy than a LinkedList if items are inserted at the start of the list. To explain the results, we explored the memory usage and the bytecode executed during an operation. Expensive computation tasks in the analyzed bytecode traces appeared to have an energy impact, but memory usage did not contribute. We evaluated our profiles by using them to selectively replace Collections types used in six applications and libraries. We found that choosing the wrong Collections type, as indicated by our profiles, can cost even 300\% more energy than the most efficient choice. Our work shows that the usage context of a data structure and our measured energy profiles can be used to decide between alternative Collections implementations.},
	booktitle = {2016 {IEEE}/{ACM} 38th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Hasan, S. and King, Z. and Hafiz, M. and Sayagh, M. and Adams, B. and Hindle, A.},
	month = may,
	year = {2016},
	keywords = {API, ArrayList, Collections, Encoding, Energy consumption, Energy measurement, Energy Profile, energy profiles, Java, Java collections classes, Java List, LinkedList, Semiconductor device measurement, Set abstractions, Software, Software engineering},
	pages = {225--236},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/CL3KSPMJ/7886906.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/M4QA9EIU/Hasan et al. - 2016 - Energy Profiles of Java Collections Classes.pdf:application/pdf},
}

@misc{httpsplusgooglecom100601164815113053596_why_2018,
	title = {Why {Are} {There} {So} {Many} {Pythons}? {A} {Python} {Implementation} {Comparison}},
	shorttitle = {Why {Are} {There} {So} {Many} {Pythons}?},
	url = {https://www.toptal.com/python/why-are-there-so-many-pythons},
	abstract = {Starting from scratch, the author of this guide examines the various Python interfaces, implementations, and their characteristics.},
	urldate = {2018-04-13},
	journal = {Toptal Engineering Blog},
	author = {{https://plus.google.com/100601164815113053596}},
	month = apr,
	year = {2018},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/XBKQMH88/why-are-there-so-many-pythons.html:text/html},
}

@article{friedley_high-performance_2009,
	title = {High-{Performance} {Code} {Generation} {Using} {CorePy}},
	language = {en},
	author = {Friedley, Andrew and Mueller, Christopher and Lumsdaine, Andrew},
	year = {2009},
	pages = {6},
	file = {Friedley et al. - 2009 - High-Performance Code Generation Using CorePy.pdf:/Users/chakibbelgaid/Zotero newone/storage/BZQHD3LH/Friedley et al. - 2009 - High-Performance Code Generation Using CorePy.pdf:application/pdf},
}

@inproceedings{wen_watching_2018,
	address = {New York, NY, USA},
	series = {{ASPLOS} '18},
	title = {Watching for {Software} {Inefficiencies} with {Witch}},
	isbn = {978-1-4503-4911-6},
	url = {http://doi.acm.org/10.1145/3173162.3177159},
	doi = {10.1145/3173162.3177159},
	abstract = {Inefficiencies abound in complex, layered software. A variety of inefficiencies show up as wasteful memory operations. Many existing tools instrument every load and store instruction to monitor memory, which significantly slows execution and consumes enormously extra memory. Our lightweight framework, Witch, samples consecutive accesses to the same memory location by exploiting two ubiquitous hardware features: the performance monitoring units (PMU) and debug registers. Witch performs no instrumentation. Hence, witchcraft---tools built atop Witch---can detect a variety of software inefficiencies while introducing negligible slowdown and insignificant memory consumption and yet maintaining accuracy comparable to exhaustive instrumentation tools. Witch allowed us to scale our analysis to a large number of code bases. Guided by witchcraft, we detected several performance problems in important code bases; eliminating these inefficiencies resulted in significant speedups.



This article is summarized in:
the morning paper

an interesting/influential/important paper from the world of CS every weekday morning, as selected by Adrian Colyer},
	urldate = {2018-04-24},
	booktitle = {Proceedings of the {Twenty}-{Third} {International} {Conference} on {Architectural} {Support} for {Programming} {Languages} and {Operating} {Systems}},
	publisher = {ACM},
	author = {Wen, Shasha and Liu, Xu and Byrne, John and Chabbi, Milind},
	year = {2018},
	keywords = {debug registers, PMU, profiling, sampling, software inefficiency detection},
	pages = {332--347},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/6MURAMU7/Wen et al. - 2018 - Watching for Software Inefficiencies with Witch.pdf:application/pdf},
}

@inproceedings{pereira_locating_2017,
	title = {Locating {Energy} {Hotspots} in {Source} {Code}},
	doi = {10.1109/ICSE-C.2017.151},
	abstract = {This paper briefly presents a new approach for helping developers identify energy hot spots in their applications. Using tests cases, and statistical methods based on Spectrum-based Fault Localization, high energy consumption is related to the system's source code and a ranking of possible energy leaks are pointed. This technique is both language independent, and context level independent. Initial studies have also shown that using this technique helped developers identify and optimize energy problems in half the time while improving the energy efficiency by 18\%.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Pereira, R.},
	month = may,
	year = {2017},
	keywords = {Conferences, Context, energy conservation, energy consumption, Energy consumption, energy hotspot location, Energy measurement, fault diagnosis, Fault Localization, Green Computing, program execution, program fault identification, Program Optimization, program testing, Software, Software engineering, software maintenance, software system, source code (software), source code components, spectrum-based energy leak localization, spectrum-based fault localization, SPELL, statistical analysis, statistical methods, Tools},
	pages = {88--90},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/GTFM9SLZ/7965265.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/58RVFUPV/Pereira - 2017 - Locating Energy Hotspots in Source Code.pdf:application/pdf},
}

@inproceedings{cruz_performance-based_2017,
	title = {Performance-{Based} {Guidelines} for {Energy} {Efficient} {Mobile} {Applications}},
	doi = {10.1109/MOBILESoft.2017.19},
	abstract = {Mobile and wearable devices are nowadays the de facto personal computers, while desktop computers are becoming less popular. Therefore, it is important for companies to deliver efficient mobile applications. As an example, Google has published a set of best practices to optimize the performance of Android applications. However, these guidelines fall short to address energy consumption. As mobile software applications operate in resource-constrained environments, guidelines to build energy efficient applications are of utmost importance. In this paper, we studied whether or not a set of best performance-based practices have an impact on the energy consumed by Android applications. In an experimental study with six popular mobile applications, we observed that the battery of the mobile device can last up to approximately an extra hour if the applications are developed with energy-aware practices. This work paves the way for a set of guidelines for energy-aware automatic refactoring techniques.},
	booktitle = {2017 {IEEE}/{ACM} 4th {International} {Conference} on {Mobile} {Software} {Engineering} and {Systems} ({MOBILESoft})},
	author = {Cruz, L. and Abreu, R.},
	month = may,
	year = {2017},
	keywords = {Android applications, Androids, Anti patterns, energy conservation, energy consumption, Energy consumption, energy efficient applications, energy efficient mobile applications, energy-aware automatic refactoring, energy-aware practices, Green Computing, Humanoid robots, Mobile applications, Mobile communication, mobile computing, Mobile Computing, mobile device battery, Mobile handsets, mobile software applications, Performance evaluation, performance-based guidelines, performance-based practices, personal computers, power aware computing, resource-constrained environments, wearable devices},
	pages = {46--57},
	annote = {the structure of the paper :

a clear abstract of what they will present
introduction :

    motivation behind : statistics about the amount of  android users - using stackoverflow to show the need of those optimizations by developers
    RQs :


    the contributions of this paper
    related work : what is used ? and why this one is different from the state of art ( in general they say : we are aware that other works have been done in this field which enhance the usefulness and the pertinence of the subject , but our  work is still new because wee covered what has not been covered by the other works relatives to this field ) 
Empirical study : we describe our methodology and explain our choices :

    the choice of the testes
the number of experimentation used in this case
the testing process
the distribution of the result ( test of shapiro wilk )
the normalized data


data analyses : we show the data and the graphs and the tables and some magic figures to blow the mind of the reader x)
discussion : here we show the results of our tests and discuss the impact in the real cases

    we answer the RQs too 


Threats of the validity :

    we show that we are aware of the uncertainty of the result and the experimentation itself due to external factors and even tho we can still take conclusions , otherwise our study has no need


Conclusion :

    remembering the impact of the subject and this study in the real world
    a brief description of the study
    adding some ideas of future works about this study


},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/JIZSQYDP/7972717.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/JA4NR4RC/Cruz and Abreu - 2017 - Performance-Based Guidelines for Energy Efficient .pdf:application/pdf},
}

@inproceedings{destefanis_statistical_2016,
	address = {New York, NY, USA},
	series = {{WETSoM} '16},
	title = {A {Statistical} {Comparison} of {Java} and {Python} {Software} {Metric} {Properties}},
	isbn = {978-1-4503-4177-6},
	url = {http://doi.acm.org/10.1145/2897695.2897697},
	doi = {10.1145/2897695.2897697},
	abstract = {This paper presents a statistical analysis of 20 opens ource object-oriented systems with the purpose of detecting differences in metrics distribution between Java and Python projects. We selected ten Java projects from the Java Qualitas Corpus and ten projects written in Python. For each system, we considered 10 class-level software metrics. We performed a best fit procedure on the empirical distributions through the log-normal distribution and the double Pareto distribution to identify differences between the two languages. Even though the statistical distributions for projects written in Java and Python may appear the same for lower values of the metric, performing the procedure with the double Pareto distribution for the Number of Local Methods metric reveals that major differences can be noticed along the queue of the distributions. On the contrary, the same analysis performed with the Number of Statements metric reveals that only the initial portion of the double Pareto distribution shows differences between the two languages. In addition, the dispersion parameter associated to the log-normal distribution fit for the total Number Of Methods can be used for distinguishing Java projects from Python projects.},
	urldate = {2018-05-07},
	booktitle = {Proceedings of the 7th {International} {Workshop} on {Emerging} {Trends} in {Software} {Metrics}},
	publisher = {ACM},
	author = {Destefanis, Giuseppe and Ortu, Marco and Porru, Simone and Swift, Stephen and Marchesi, Michele},
	year = {2016},
	pages = {22--28},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/XX3ZYP9E/Destefanis et al. - 2016 - A Statistical Comparison of Java and Python Softwa.pdf:application/pdf},
}

@article{pinto_energy_2017,
	title = {Energy {Efficiency}: {A} {New} {Concern} for {Application} {Software} {Developers}},
	volume = {60},
	issn = {0001-0782},
	shorttitle = {Energy {Efficiency}},
	url = {http://doi.acm.org/10.1145/3154384},
	doi = {10.1145/3154384},
	abstract = {Development of energy-efficient software is hindered by a lack of knowledge and a lack of tools.},
	number = {12},
	urldate = {2018-05-09},
	journal = {Commun. ACM},
	author = {Pinto, Gustavo and Castor, Fernando},
	month = nov,
	year = {2017},
	note = {Number: 12},
	pages = {68--75},
	annote = {things to extend :
use micro benchmarks , and say that each one is used to measure a specific thing (memory intensive , cpu intensive , io intesive ..etc )
 },
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/H5GHCEVR/Pinto and Castor - 2017 - Energy Efficiency A New Concern for Application S.pdf:application/pdf},
}

@article{gelenbe_impact_2015,
	title = {The {Impact} of {Information} {Technology} on {Energy} {Consumption} and {Carbon} {Emissions}},
	volume = {2015},
	issn = {1530-2180},
	url = {http://doi.acm.org/10.1145/2755977},
	doi = {10.1145/2755977},
	abstract = {In this article the authors evaluate the impact of different sectors of information and communication technologies (ICT) on energy consumption and CO2 emissions. ICT is understood to cover computer and peripheral equipment including local area networks, telecommunication equipment and networks, and data centers.},
	number = {June},
	urldate = {2018-05-09},
	journal = {Ubiquity},
	author = {Gelenbe, Erol and Caseau, Yves},
	month = jun,
	year = {2015},
	note = {Number: June},
	pages = {1:1--1:15},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/5EVHKXJC/Gelenbe and Caseau - 2015 - The Impact of Information Technology on Energy Con.pdf:application/pdf},
}

@inproceedings{manotas_empirical_2016,
	title = {An {Empirical} {Study} of {Practitioners}' {Perspectives} on {Green} {Software} {Engineering}},
	doi = {10.1145/2884781.2884810},
	abstract = {The energy consumption of software is an increasing concern as the use of mobile applications, embedded systems, and data center-based services expands. While research in green software engineering is correspondingly increasing, little is known about the current practices and perspectives of software engineers in the field. This paper describes the first empirical study of how practitioners think about energy when they write requirements, design, construct, test, and maintain their software. We report findings from a quantitative,targeted survey of 464 practitioners from ABB, Google, IBM, and Microsoft, which was motivated by and supported with qualitative data from 18 in-depth interviews with Microsoft employees. The major findings and implications from the collected data contextualize existing green software engineering research and suggest directions for researchers aiming to develop strategies and tools to help practitioners improve the energy usage of their applications.},
	booktitle = {2016 {IEEE}/{ACM} 38th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Manotas, I. and Bird, C. and Zhang, R. and Shepherd, D. and Jaspan, C. and Sadowski, C. and Pollock, L. and Clause, J.},
	month = may,
	year = {2016},
	keywords = {ABB, Conferences, data center-based services, embedded systems, Empirical Study, Encoding, energy consumption, energy usage, Google, green computing, Green products, green software engineering, Green Software Engineering, IBM, Interviews, Microsoft, mobile applications, practitioner perspective, Software, software engineering, Software engineering, Survey},
	pages = {237--248},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/2C8IF3MQ/7886907.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/K7F2JAI9/Manotas et al. - 2016 - An Empirical Study of Practitioners' Perspectives .pdf:application/pdf},
}

@inproceedings{pereira_energy_2017,
	address = {New York, NY, USA},
	series = {{SLE} 2017},
	title = {Energy {Efficiency} {Across} {Programming} {Languages}: {How} {Do} {Energy}, {Time}, and {Memory} {Relate}?},
	isbn = {978-1-4503-5525-4},
	shorttitle = {Energy {Efficiency} {Across} {Programming} {Languages}},
	url = {http://doi.acm.org/10.1145/3136014.3136031},
	doi = {10.1145/3136014.3136031},
	abstract = {This paper presents a study of the runtime, memory usage and energy consumption of twenty seven well-known software languages. We monitor the performance of such languages using ten different programming problems, expressed in each of the languages. Our results show interesting findings, such as, slower/faster languages consuming less/more energy, and how memory usage influences energy consumption. Finally, we show how to use our results to provide software engineers support to decide which language to use when energy efficiency is a concern.},
	urldate = {2018-05-14},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {International} {Conference} on {Software} {Language} {Engineering}},
	publisher = {ACM},
	author = {Pereira, Rui and Couto, Marco and Ribeiro, Francisco and Rua, Rui and Cunha, Jácome and Fernandes, João Paulo and Saraiva, João},
	year = {2017},
	keywords = {Energy Efficiency, Green Software, Language Benchmarking, Programming Languages},
	pages = {256--267},
	annote = {this paper discuss the energy consumption through memory usage however we aim to see the relation between CPU usage and energy consumption rather than memory usage},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/36CLI8YY/Pereira et al. - 2017 - Energy Efficiency Across Programming Languages Ho.pdf:application/pdf},
}

@inproceedings{williams_dynamic_2010,
	address = {New York, NY, USA},
	series = {{CGO} '10},
	title = {Dynamic {Interpretation} for {Dynamic} {Scripting} {Languages}},
	isbn = {978-1-60558-635-9},
	url = {http://doi.acm.org/10.1145/1772954.1772993},
	doi = {10.1145/1772954.1772993},
	abstract = {Dynamic scripting languages offer programmers increased flexibility by allowing properties of programs to be defined at run-time. Typically, program execution begins with an interpreter where type checks are implemented using conditional statements. Recent JIT compilers have begun removing run-time checks by specializing native code to program properties discovered at JIT time. This paper presents a novel intermediate representation for scripting languages that explicitly encodes types of variables. The dynamic representation is a flow graph, where each node is a specialized virtual instruction and each edge directs program flow based on control and type changes in the program. The interpreter thus performs specialized execution of whole programs. We present techniques for the efficient interpretation of our representation showing speed-ups of greater than 2x over static interpretation, with an average speed-up of approximately 1.3x.},
	urldate = {2018-05-18},
	booktitle = {Proceedings of the 8th {Annual} {IEEE}/{ACM} {International} {Symposium} on {Code} {Generation} and {Optimization}},
	publisher = {ACM},
	author = {Williams, Kevin and McCandless, Jason and Gregg, David},
	year = {2010},
	keywords = {dynamic languages, interpreter optimization, type specialization},
	pages = {278--287},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/LUGGC6SM/Williams et al. - 2010 - Dynamic Interpretation for Dynamic Scripting Langu.pdf:application/pdf},
}

@article{boettiger_introduction_2015-1,
	title = {An {Introduction} to {Docker} for {Reproducible} {Research}},
	volume = {49},
	issn = {0163-5980},
	url = {http://doi.acm.org/10.1145/2723872.2723882},
	doi = {10.1145/2723872.2723882},
	abstract = {As computational work becomes more and more integral to many aspects of scientific research, computational reproducibility has become an issue of increasing importance to computer systems researchers and domain scientists alike. Though computational reproducibility seems more straight forward than replicating physical experiments, the complex and rapidly changing nature of computer environments makes being able to reproduce and extend such work a serious challenge. In this paper, I explore common reasons that code developed for one research project cannot be successfully executed or extended by subsequent researchers. I review current approaches to these issues, including virtual machines and workflow systems, and their limitations. I then examine how the popular emerging technology Docker combines several areas from systems research - such as operating system virtualization, cross-platform portability, modular re-usable elements, versioning, and a 'DevOps' philosophy, to address these challenges. I illustrate this with several examples of Docker use with a focus on the R statistical environment.},
	number = {1},
	urldate = {2018-05-22},
	journal = {SIGOPS Oper. Syst. Rev.},
	author = {Boettiger, Carl},
	month = jan,
	year = {2015},
	note = {Number: 1},
	pages = {71--79},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/8K6333JJ/Boettiger - 2015 - An Introduction to Docker for Reproducible Researc.pdf:application/pdf},
}

@article{redondo_comprehensive_2015-1,
	title = {A {Comprehensive} {Evaluation} of {Common} {Python} {Implementations}},
	volume = {32},
	issn = {0740-7459},
	doi = {10.1109/MS.2014.104},
	abstract = {Python is a widely used general-purpose dynamic language. Owing to its popularity, many implementations exist for the two distinct Python 2 and Python 3 language versions. Researchers evaluated seven implementations of both language versions to facilitate the selection of one of them. For this purpose, they carefully selected 523 programs to execute in each implementation. They evaluated run-time performance and memory consumption and investigated each implementation's important qualitative characteristics.},
	number = {4},
	journal = {IEEE Software},
	author = {Redondo, J. M. and Ortin, F.},
	month = jul,
	year = {2015},
	note = {Number: 4},
	keywords = {benchmark suite, Benchmark testing, dynamic languages, Dynamic programming, general-purpose dynamic language, high level languages, Java, JIT compilation, just-in-time compilation, memory consumption, Memory management, performance analysis, Python, Python 2 language versions, Python 3 language version, Python implementations, run-time performance, Runtime, software development, software engineering, storage management, Visual BASIC},
	pages = {76--84},
	annote = {benchmarks link
http://www.reflection.uniovi.es/python},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/WPA5GT6J/6879048.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/MQS4URQF/Redondo and Ortin - 2015 - A Comprehensive Evaluation of Common Python Implem.pdf:application/pdf},
}

@article{behnel_cython_2011,
	title = {Cython: {The} {Best} of {Both} {Worlds}},
	volume = {13},
	issn = {1521-9615},
	shorttitle = {Cython},
	url = {http://ieeexplore.ieee.org/document/5582062/},
	doi = {10.1109/MCSE.2010.118},
	language = {en},
	number = {2},
	urldate = {2018-05-25},
	journal = {Computing in Science \& Engineering},
	author = {Behnel, Stefan and Bradshaw, Robert and Citro, Craig and Dalcin, Lisandro and Seljebotn, Dag Sverre and Smith, Kurt},
	month = mar,
	year = {2011},
	note = {Number: 2},
	pages = {31--39},
	file = {Behnel et al. - 2011 - Cython The Best of Both Worlds.pdf:/Users/chakibbelgaid/Zotero newone/storage/9DT728BX/Behnel et al. - 2011 - Cython The Best of Both Worlds.pdf:application/pdf},
}

@article{buytaert_statistically_nodate,
	title = {Statistically {Rigorous} {Java} {Performance} {Evaluation}},
	abstract = {Java performance is far from being trivial to benchmark because it is affected by various factors such as the Java application, its input, the virtual machine, the garbage collector, the heap size, etc. In addition, non-determinism at run-time causes the execution time of a Java program to differ from run to run. There are a number of sources of non-determinism such as Just-In-Time (JIT) compilation and optimization in the virtual machine (VM) driven by timerbased method sampling, thread scheduling, garbage collection, and various system effects.},
	language = {en},
	author = {Buytaert, Andy Georges Dries and Eeckhout, Lieven},
	pages = {20},
	file = {Buytaert and Eeckhout - Statistically Rigorous Java Performance Evaluation.pdf:/Users/chakibbelgaid/Zotero newone/storage/8YJX97JJ/Buytaert and Eeckhout - Statistically Rigorous Java Performance Evaluation.pdf:application/pdf},
}

@article{acar_software_nodate,
	title = {Software development methodology in a {Green} {IT} environment},
	language = {en},
	author = {Acar, Hayri},
	pages = {121},
	file = {Acar - Software development methodology in a Green IT env.pdf:/Users/chakibbelgaid/Zotero newone/storage/ESBSFBNB/Acar - Software development methodology in a Green IT env.pdf:application/pdf},
}

@inproceedings{almeida_enabling_2013,
	title = {Enabling {LTE}/{WiFi} coexistence by {LTE} blank subframe allocation},
	isbn = {978-1-4673-3122-7},
	url = {http://ieeexplore.ieee.org/document/6655388/},
	doi = {10.1109/ICC.2013.6655388},
	abstract = {The recent development of regulatory policies that permit the use of TV bands spectrum on a secondary basis has motivated discussion about coexistence of primary (e.g. TV broadcasts) and secondary users (e.g. WiFi users in TV spectrum). However, much less attention has been given to coexistence of different secondary wireless technologies in the TV white spaces. Lack of coordination between secondary networks may create severe interference situations, resulting in less efﬁcient usage of the spectrum. In this paper, we consider two of the most prominent wireless technologies available today, namely Long Term Evolution (LTE), and WiFi, and address some problems that arise from their coexistence in the same band. We perform exhaustive system simulations and observe that WiFi is hampered much more signiﬁcantly than LTE in coexistence scenarios. A simple coexistence scheme that reuses the concept of almost blank subframes in LTE is proposed, and it is observed that it can improve the WiFi throughput per user up to 50 times in the studied scenarios.},
	language = {en},
	urldate = {2018-06-01},
	publisher = {IEEE},
	author = {Almeida, Erika and Cavalcante, Andre M. and Paiva, Rafael C. D. and Chaves, Fabiano S. and Abinader, Fuad M. and Vieira, Robson D. and Choudhury, Sayantan and Tuomaala, Esa and Doppler, Klaus},
	month = jun,
	year = {2013},
	pages = {5083--5088},
	file = {Almeida et al. - 2013 - Enabling LTEWiFi coexistence by LTE blank subfram.pdf:/Users/chakibbelgaid/Zotero newone/storage/UIGCADH8/Almeida et al. - 2013 - Enabling LTEWiFi coexistence by LTE blank subfram.pdf:application/pdf},
}

@misc{noauthor_enseignements_2018,
	title = {Enseignements - {Pierre} {Boulet} - {Université} de {Lille}},
	url = {https://pro.univ-lille.fr/pierre-boulet/enseignements/#descr},
	urldate = {2018-06-01},
	month = jun,
	year = {2018},
	file = {Enseignements - Pierre Boulet - Université de Lille:/Users/chakibbelgaid/Zotero newone/storage/6YKZRRXV/enseignements.html:text/html},
}

@article{boulet_principes_nodate,
	title = {Principes et outils informatiques},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {4},
	file = {Boulet - Principes et outils informatiques.pdf:/Users/chakibbelgaid/Zotero newone/storage/8IN2UFPQ/Boulet - Principes et outils informatiques.pdf:application/pdf},
}

@article{boulet_construire_nodate,
	title = {Construire une argumentation},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {4},
	file = {Boulet - Construire une argumentation.pdf:/Users/chakibbelgaid/Zotero newone/storage/GJJEESVX/Boulet - Construire une argumentation.pdf:application/pdf},
}

@article{boulet_structuration_nodate,
	title = {Structuration des documents},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {4},
	file = {Boulet - Structuration des documents.pdf:/Users/chakibbelgaid/Zotero newone/storage/C7Z854AX/Boulet - Structuration des documents.pdf:application/pdf},
}

@misc{noauthor_scientific_2018,
	title = {Scientific english},
	url = {https://xmindshare.s3.amazonaws.com/preview/s6bQ-ZenrdCi-25363.png},
	urldate = {2018-06-01},
	month = jun,
	year = {2018},
	file = {s6bQ-ZenrdCi-25363.png 1 868×3 969 pixels:/Users/chakibbelgaid/Zotero newone/storage/NGLZYHTH/s6bQ-ZenrdCi-25363.html:text/html},
}

@article{boulet_typographie_nodate,
	title = {Typographie générale},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {4},
	file = {Boulet - Typographie générale.pdf:/Users/chakibbelgaid/Zotero newone/storage/MKZBSR3J/Boulet - Typographie générale.pdf:application/pdf},
}

@article{saudrais_petit_nodate,
	title = {Le petit typographe rationnel},
	language = {fr},
	author = {Saudrais, Eddie},
	pages = {15},
	file = {Saudrais - Le petit typographe rationnel.pdf:/Users/chakibbelgaid/Zotero newone/storage/QY2NQVHZ/Saudrais - Le petit typographe rationnel.pdf:application/pdf},
}

@article{boulet_typographie_nodate-1,
	title = {Typographie scientifique},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {4},
	file = {Boulet - Typographie scientifique.pdf:/Users/chakibbelgaid/Zotero newone/storage/GYPHLZIM/Boulet - Typographie scientifique.pdf:application/pdf},
}

@article{boulet_illustrations_nodate,
	title = {Illustrations graphiques},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {4},
	file = {Boulet - Illustrations graphiques.pdf:/Users/chakibbelgaid/Zotero newone/storage/4AE8UJS4/Boulet - Illustrations graphiques.pdf:application/pdf},
}

@article{boulet_presentations_nodate,
	title = {Présentations orales : préparation},
	language = {fr},
	author = {Boulet, Pierre},
	pages = {2},
	file = {Boulet - Présentations orales  préparation.pdf:/Users/chakibbelgaid/Zotero newone/storage/P8BZQ76Z/Boulet - Présentations orales  préparation.pdf:application/pdf},
}

@article{sung_canal_2018,
	title = {{CANAL}: {A} {Cache} {Timing} {Analysis} {Framework} via {LLVM} {Transformation}},
	abstract = {A unified modeling framework for non-functional properties of a program is essential for research in software analysis and verification, since it reduces burdens on individual researchers to implement new approaches and compare existing approaches. We present CANAL, a framework that models the cache behaviors of a program by transforming its intermediate representation (IR) in the LLVM compiler. CANAL inserts auxiliary variables and LLVM instructions over these variables, to allow standard verification tools to handle a new class of cache timing related properties, e.g., for computing the worst-case execution time (WCET) and detecting side-channel information leaks. We demonstrate the effectiveness of CANAL using three LLVM-based verification tools: KLEE, SMACK and Crab-llvm. We also confirm the accuracy of our cache model by comparing with the CPU cycle-accurate simulation results of GEM5. CANAL is available on GitHub1 and YouTube2.},
	language = {en},
	author = {Sung, Chungha and Paulsen, Brandon and Wang, Chao},
	year = {2018},
	pages = {4},
	file = {Sung et al. - 2018 - CANAL A Cache Timing Analysis Framework via LLVM .pdf:/Users/chakibbelgaid/Zotero newone/storage/TVKIWJ34/Sung et al. - 2018 - CANAL A Cache Timing Analysis Framework via LLVM .pdf:application/pdf},
}

@inproceedings{afridi_empirical_2017,
	title = {Empirical investigation of correlation between rewards and crowdsource-based software developers},
	doi = {10.1109/ICSE-C.2017.149},
	abstract = {Numerous reward system practices are adopted in software development companies in order to motivate their developers to perform at best level and align the management and developer's interest. However, due to lack of a central mechanism for team formation on crowdsourcing-based software development platform, it is difficult for managers to adopt effective reward system strategies in order to align the developer's interest. In order to address this issue, we exploit an approach, to empirically investigate the existing reward system practices, adopted on the crowdsourcing-based software development platforms, to motivate their developers and their perception. Subsequently, we implement a crawler to mine the characteristics of completed tasks and related reward information from the TopCoder platform of Tech Platform Inc (TPI). The promising results suggest the applicability of the proposed approach in order, 1) to investigate the reward system practices across the crowdsourcing-based platforms and, 2) to help the managers in formulating and implementing an effective reward system to incentivize their developers.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Afridi, H. G.},
	month = may,
	year = {2017},
	keywords = {Companies, Context, Correlation, crawler, crowdsourcing, Crowdsourcing, crowdsourcing-based software development platform, data mining, Developers, Open source software, Regression, Reward System, reward system strategies, software development companies, software engineering, TopCoder},
	pages = {80--81},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/QL7W66Q7/7965262.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/T5K4ZNRC/Afridi - 2017 - Empirical investigation of correlation between rew.pdf:application/pdf},
}

@inproceedings{chekam_empirical_2017,
	title = {An {Empirical} {Study} on {Mutation}, {Statement} and {Branch} {Coverage} {Fault} {Revelation} {That} {Avoids} the {Unreliable} {Clean} {Program} {Assumption}},
	doi = {10.1109/ICSE.2017.61},
	abstract = {Many studies suggest using coverage concepts, such as branch coverage, as the starting point of testing, while others as the most prominent test quality indicator. Yet the relationship between coverage and fault-revelation remains unknown, yielding uncertainty and controversy. Most previous studies rely on the Clean Program Assumption, that a test suite will obtain similar coverage for both faulty and fixed ('clean') program versions. This assumption may appear intuitive, especially for bugs that denote small semantic deviations. However, we present evidence that the Clean Program Assumption does not always hold, thereby raising a critical threat to the validity of previous results. We then conducted a study using a robust experimental methodology that avoids this threat to validity, from which our primary finding is that strong mutation testing has the highest fault revelation of four widely-used criteria. Our findings also revealed that fault revelation starts to increase significantly only once relatively high levels of coverage are attained.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Chekam, T. T. and Papadakis, M. and Traon, Y. Le and Harman, M.},
	month = may,
	year = {2017},
	keywords = {branch coverage fault revelation, code coverage, Correlation, Java, mutation testing, Mutation testing, program testing, real faults, Robustness, semantic deviations, software fault tolerance, software quality, Standards, test adequacy, test effectiveness, test quality indicator, Testing, Tools, unreliable clean program assumption avoidance},
	pages = {597--608},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/EXS2QKSM/7985697.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/764HWRHE/Chekam et al. - 2017 - An Empirical Study on Mutation, Statement and Bran.pdf:application/pdf},
}

@inproceedings{fernandes_assisting_2017,
	title = {Assisting {Non}-{Specialist} {Developers} to {Build} {Energy}-{Efficient} {Software}},
	doi = {10.1109/ICSE-C.2017.133},
	abstract = {In this paper we introduce CECOTOOL, a tool that analyzes the energy behavior of alternative collection implementations and provides potentially useful recommendations about good implementation options. We applied it to two real-world software systems from the DaCapo suite [1], Xalan and Tomcat. With no prior knowledge of the application domains, we were able to reduce the energy consumption up to 4.37\%.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Fernandes, B. and Pinto, G. and Castor, F.},
	month = may,
	year = {2017},
	keywords = {application domains, Benchmark testing, CECOTOOL, DaCapo suite, Data structures, energy behavior, energy conservation, energy consumption, Energy consumption, energy-efficient software, Java, nonspecialist developers, power aware computing, software engineering, software systems, Software systems, Tomcat, Tools, Xalan},
	pages = {158--160},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/VNKGLSSB/7965288.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/K4VATVGZ/Fernandes et al. - 2017 - Assisting Non-Specialist Developers to Build Energ.pdf:application/pdf},
}

@inproceedings{jabbarvand_advancing_2017,
	title = {Advancing {Energy} {Testing} of {Mobile} {Applications}},
	doi = {10.1109/ICSE-C.2017.45},
	abstract = {The rising popularity of mobile apps deployed on battery-constrained devices has motivated the need for effective energy-aware testing techniques. However, currently there is a lack of test generation tools for exercising the energy properties of apps. Automated test generation is not useful without tools that help developers to measure the quality of the tests. Additionally, the collection of tests generated for energy testing could be quite large, as it may involve a test suite that covers all the energy hotspots under different use cases. Thereby, there is a need for techniques to manage the size of test suite, while maintaining its effectiveness in revealing energy defects. Our research plan to advance energy testing for mobile applications include various techniques for energy-aware test generation, energy-aware test-suite adequacy assessment, and energy-aware test-suite minimization.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Jabbarvand, R. and Malek, S.},
	month = may,
	year = {2017},
	keywords = {Android, Androids, battery-constrained devices, Energy Consumption, energy defects, Energy measurement, energy-aware test generation, energy-aware test-suite adequacy assessment, energy-aware test-suite minimization, energy-aware testing techniques, Green Software Engineering, Humanoid robots, Minimization, mobile applications, Mobile communication, mobile computing, Mutation Testing, power aware computing, program testing, Software Testing, Test suite Minimization, Testing, Tools},
	pages = {491--492},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/35QJPWNG/7965399.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/2CIQK3JK/Jabbarvand and Malek - 2017 - Advancing Energy Testing of Mobile Applications.pdf:application/pdf},
}

@inproceedings{nucci_petra_2017,
	title = {{PETrA}: {A} {Software}-{Based} {Tool} for {Estimating} the {Energy} {Profile} of {Android} {Applications}},
	shorttitle = {{PETrA}},
	doi = {10.1109/ICSE-C.2017.18},
	abstract = {Energy efficiency is a vital characteristic of any mobile application, and indeed is becoming an important factor for user satisfaction. For this reason, in recent years several approaches and tools for measuring the energy consumption of mobile devices have been proposed. Hardware-based solutions are highly precise, but at the same time they require costly hardware toolkits. Model-based techniques require a possibly difficult calibration of the parameters needed to correctly create a model on a specific hardware device. Finally, software-based solutions are easier to use, but they are possibly less precise than hardware-based solution. In this demo, we present PETrA, a novel software-based tool for measuring the energy consumption of Android apps. With respect to other tools, PETrA is compatible with all the smartphones with Android 5.0 or higher, not requiring any device specific energy profile. We also provide evidence that our tool is able to perform similarly to hardware-based solutions.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Nucci, D. Di and Palomba, F. and Prota, A. and Panichella, A. and Zaidman, A. and Lucia, A. De},
	month = may,
	year = {2017},
	keywords = {Android (operating system), Android 5.0, Android applications, Androids, energy conservation, energy consumption, Energy consumption, Energy Consumption, energy consumption measurement, energy efficiency, Energy measurement, energy profile estimation, Estimation, Hardware, hardware device, hardware toolkits, hardware-based solutions, Humanoid robots, mobile application, Mobile Apps, mobile computing, mobile devices, model-based techniques, parameter calibration, PETrA, power aware computing, smart phones, smartphones, software tools, software-based solutions, software-based tool, Tools, user satisfaction},
	pages = {3--6},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/2STL2UFZ/7965243.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/H5IT28V7/Nucci et al. - 2017 - PETrA A Software-Based Tool for Estimating the En.pdf:application/pdf},
}

@inproceedings{rodriguez_reducing_2017,
	title = {Reducing {Energy} {Consumption} of {Resource}-{Intensive} {Scientific} {Mobile} {Applications} via {Code} {Refactoring}},
	doi = {10.1109/ICSE-C.2017.33},
	abstract = {The advent of new computing paradigms such as Mobile Grids and Mobile-edge Clouds, and the increasing number of mobile devices with ever-growing capabilities makes them attractive to users running scientific and HPC applications. However, mobile devices still have limited capabilities when compared to non-mobile devices. More importantly, mobile devices rely on batteries for their power supply. To overcome this problem, this PhD research studies how to reduce energy consumption in mobile devices via code refactoring for such kind of applications.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Rodriguez, A.},
	month = may,
	year = {2017},
	keywords = {Androids, Batteries, code refactoring, energy consumption, Energy consumption, energy consumption reduction, HPC applications, Humanoid robots, Java, mobile computing, mobile devices, natural sciences computing, parallel processing, resource-intensive scientific mobile applications, scientific applications, Smart phones, software maintenance, source code (software)},
	pages = {475--476},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/ACMGQNJQ/7965391.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/GN37S7ND/Rodriguez - 2017 - Reducing Energy Consumption of Resource-Intensive .pdf:application/pdf},
}

@inproceedings{chen_empirical_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {An {Empirical} {Comparison} of {Compiler} {Testing} {Techniques}},
	isbn = {978-1-4503-3900-1},
	url = {http://doi.acm.org/10.1145/2884781.2884878},
	doi = {10.1145/2884781.2884878},
	abstract = {Compilers, as one of the most important infrastructure of today's digital world, are expected to be trustworthy. Different testing techniques are developed for testing compilers automatically. However, it is unknown so far how these testing techniques compared to each other in terms of testing effectiveness: how many bugs a testing technique can find within a time limit. In this paper, we conduct a systematic and comprehensive empirical comparison of three compiler testing techniques, namely, Randomized Differential Testing (RDT), a variant of RDT---Different Optimization Levels (DOL), and Equivalence Modulo Inputs (EMI). Our results show that DOL is more effective at detecting bugs related to optimization, whereas RDT is more effective at detecting other types of bugs, and the three techniques can complement each other to a certain degree. Furthermore, in order to understand why their effectiveness differs, we investigate three factors that influence the effectiveness of compiler testing, namely, efficiency, strength of test oracles, and effectiveness of generated test programs. The results indicate that all the three factors are statistically significant, and efficiency has the most significant impact.},
	urldate = {2018-06-07},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Chen, Junjie and Hu, Wenxiang and Hao, Dan and Xiong, Yingfei and Zhang, Hongyu and Zhang, Lu and Xie, Bing},
	year = {2016},
	pages = {180--190},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/ITGNTF7F/Chen et al. - 2016 - An Empirical Comparison of Compiler Testing Techni.pdf:application/pdf},
}

@inproceedings{jagroep_software_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {Software {Energy} {Profiling}: {Comparing} {Releases} of a {Software} {Product}},
	isbn = {978-1-4503-4205-6},
	shorttitle = {Software {Energy} {Profiling}},
	url = {http://doi.acm.org/10.1145/2889160.2889216},
	doi = {10.1145/2889160.2889216},
	abstract = {In the quest for energy efficiency of Information and Communication Technology, so far research has mostly focused on the role of hardware. However, as hardware technology becomes more sophisticated, the role of software becomes crucial. Recently, the impact of software on energy consumption has been acknowledged as significant by researchers in software engineering. In spite of that, measuring the energy consumption of software has proven to be a challenge, due to the large number of variables that need to be controlled to obtain reliable measurements. Due to cost and time constraints, many software product organizations are unable to effectively measure the energy consumption of software. This prevents them to be in control over the energy efficiency of their products. In this paper, we propose a software energy profiling method to reliably compare the energy consumed by a software product across different releases, from the perspective of a software organization. Our method allows to attribute differences in energy consumption to changes in the software. We validate our profiling method through an empirical experiment on two consecutive releases of a commercial software product. We demonstrate how the method can be applied by organizations and provide an analysis of the software related changes in energy consumption. Our results show that, despite a lack of precise measurements, energy consumption differences between releases of a software product can be quantified down to the level of individual processes. Additionally, the results provide insights on how specific software changes might affect energy consumption.},
	urldate = {2018-06-07},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} {Companion}},
	publisher = {ACM},
	author = {Jagroep, Erik A. and van der Werf, Jan Martijn and Brinkkemper, Sjaak and Procaccianti, Giuseppe and Lago, Patricia and Blom, Leen and van Vliet, Rob},
	year = {2016},
	keywords = {energy efficiency, profiling, software architecture, software product},
	pages = {523--532},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/SF4DNNL7/Jagroep et al. - 2016 - Software Energy Profiling Comparing Releases of a.pdf:application/pdf},
}

@inproceedings{imminni_spyse_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {{SPYSE}: {A} {Semantic} {Search} {Engine} for {Python} {Packages} and {Modules}},
	isbn = {978-1-4503-4205-6},
	shorttitle = {{SPYSE}},
	url = {http://doi.acm.org/10.1145/2889160.2889174},
	doi = {10.1145/2889160.2889174},
	abstract = {Code reuse is a common practice among software developers, whether novices or experts. Developers often rely on online resources in order to find code to reuse. For Python, the Python Package Index (PyPI) contains all packages developed for the community and is the largest catalog of reusable, open source packages developers can consult. While a valuable resource, the state of the art PyPI search has very limited capabilities, making it hard for developers to find useful, high quality Python code to use for their task at hand. We introduce SPYSE (Semantic PYthon Search Engine), a web-based search engine that overcomes the limitations of the state of the art, making it easier for developers to find useful code. The power of SPYSE lays in the combination of three different aspects meant to provide developers with relevant, and at the same time high quality code: code semantics, popularity, and code quality. SPYSE also allows searching for modules, in addition to packages, which opens new reuse opportunities for developers, currently not supported. TOOL URL: https://pypi.compgeom.com VIDEO URL: https://youtu.be/Praglw-vS50},
	urldate = {2018-06-07},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} {Companion}},
	publisher = {ACM},
	author = {Imminni, Shiva Krishna and Hasan, Mir Anamul and Duckett, Michael and Sachdeva, Puneet and Karmakar, Sudipta and Kumar, Piyush and Haiduc, Sonia},
	year = {2016},
	keywords = {code reuse, Python, recommender systems, search engine},
	pages = {625--628},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/WKNXRPRS/Imminni et al. - 2016 - SPYSE A Semantic Search Engine for Python Package.pdf:application/pdf},
}

@inproceedings{noureddine_optimising_2015,
	title = {Optimising {Energy} {Consumption} of {Design} {Patterns}},
	volume = {2},
	doi = {10.1109/ICSE.2015.208},
	abstract = {Software design patterns are widely used in software engineering to enhance productivity and maintainability.However, recent empirical studies revealed the high energy overhead in these patterns. Our vision is to automatically detect and transform design patterns during compilation for better energy efficiency without impacting existing coding practices. In this paper, we propose compiler transformations for two design patterns, Observer and Decorator, and perform an initial evaluation of their energy efficiency.},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} {International} {Conference} on {Software} {Engineering}},
	author = {Noureddine, A. and Rajan, A.},
	month = may,
	year = {2015},
	keywords = {coding practices, compilation, compiler transformations, Computers, Energy consumption, energy consumption optimisation, energy efficiency, maintainability, Observers, Optimization, power aware computing, program compilers, Software, software design patterns, software engineering, Software engineering, software maintenance, Transforms},
	pages = {623--626},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/VVFMGX6Q/7203028.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/JIJNR8XA/Noureddine and Rajan - 2015 - Optimising Energy Consumption of Design Patterns.pdf:application/pdf},
}

@inproceedings{procaccianti_green_2015,
	title = {The {Green} {Lab}: {Experimentation} in {Software} {Energy} {Efficiency}},
	volume = {2},
	shorttitle = {The {Green} {Lab}},
	doi = {10.1109/ICSE.2015.297},
	abstract = {Software energy efficiency is a research topic where experimentation is widely adopted. Nevertheless, current studies and research approaches struggle to find generalizable findings that can be used to build a consistent knowledge base for energy-efficient software. To this end, we will discuss how to combine the traditional hypothesis-driven (top-down) approach with a bottom-up discovery approach. In this technical briefing, participants will learn the challenges that characterize the research in software energy efficiency. They will experience the complexity in this field and its implications for experimentation.},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} {International} {Conference} on {Software} {Engineering}},
	author = {Procaccianti, G. and Lago, P. and Vetrò, A. and Fernández, D. M. and Wieringa, R.},
	month = may,
	year = {2015},
	keywords = {bottom-up discovery approach, Complexity theory, Conferences, Empirical Methods, energy conservation, Energy consumption, Energy Efficiency, Energy measurement, green computing, green laboratory, hypothesis-driven approach, Software, software energy efficiency, software engineering, Software engineering, Software Engineering, Software measurement},
	pages = {941--942},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/H495GW4R/7203119.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/JYNPTIT8/Procaccianti et al. - 2015 - The Green Lab Experimentation in Software Energy .pdf:application/pdf},
}

@inproceedings{ardito_energy_2013,
	title = {Energy aware self-adaptation in mobile systems},
	doi = {10.1109/ICSE.2013.6606736},
	abstract = {The increasing proliferation of mobile handsets, and the migration of the information access paradigm to mobile platforms, leads researchers to study the energy consumption of this class of devices. The literature still lacks metrics and tools that allow software developers to easily measure and optimize the energy efficiency of their code. Energy efficiency can definitely improve user experience increasing battery life. This paper aims to describe a technique to adapt the execution of a mobile application, based on the actual energy consumption of the device, without using external equipment.},
	booktitle = {2013 35th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Ardito, L.},
	month = may,
	year = {2013},
	keywords = {Android, Batteries, battery life, Context-Awareness, energy aware self-adaptation, Energy Aware Software, Energy Awareness, Energy consumption, Energy efficiency, energy efficiency optimization, information access paradigm, mobile application, Mobile communication, mobile computing, mobile handsets, mobile platforms, mobile systems, optimisation, power aware computing, Self-Adaptation, Smart phones, Software},
	pages = {1435--1437},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/9G3FDPR7/6606736.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/FVGF2GA7/Ardito - 2013 - Energy aware self-adaptation in mobile systems.pdf:application/pdf},
}

@misc{noauthor_energy_2018,
	title = {Energy {Efficiency} of {Java} {Programming} {Language} - {ProQuest}},
	url = {https://search.proquest.com/openview/e7295f20d24f20391922e9baf5e835a8/1?pq-origsite=gscholar&cbl=18750&diss=y},
	language = {en},
	urldate = {2018-06-19},
	month = jun,
	year = {2018},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/7QII69FG/1.html:text/html},
}

@phdthesis{colmant_multi-dimensional_2016,
	type = {phdthesis},
	title = {Multi-{Dimensional} {Analysis} of {Software} {Power} {Consumptions} in {Multi}-{Core} {Architectures}},
	url = {https://tel.archives-ouvertes.fr/tel-01403559/document},
	abstract = {Energy-efficient computing is becoming increasingly important. Among the reasons, one can mention the massive consumption of large data centers that consume as much as 180,000 homes. This trend, combined with environmental concerns, makes energy efficiency a prime technological and societal challenge. Currently, widely used power distribution units (PDUs) are often shared amongst nodes to deliver aggregated power consumption reports, in the range of hours and minutes. However, in order to improve the energy efficiency of software systems, we need to support process-level power estimation in real-time, which goes beyond the capacity of a PDUs. In particular, the CPU is considered by the research community as the major power consumer within a node and draws attention while trying to model the system power consumption. Over the last few years, a dozen of ad hoc power models have been proposed to cope with the wide diversity and the growing complexity of modern CPU architectures. In this thesis, we rather propose PowerAPI for learning power models and building software-defined power meters that provide accurate power estimation on modern architectures. With the emergence of cloud computing, we propose BitWatts and WattsKit for leveraging software power estimation in VMs and clusters. A finer level of estimation may be required to further evaluate the effectiveness of the software optimizations and we therefore propose codEnergy for helping developers to understand how the energy is really consumed by a software. We deeply assessed all above approaches, thus demonstrating the usefulness of PowerAPI to better understand the software power consumption on modern architectures.},
	language = {en},
	urldate = {2018-06-20},
	school = {Université Lille 1 - Sciences et Technologies},
	author = {Colmant, Maxime},
	month = nov,
	year = {2016},
	file = {Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/468DW7ED/Colmant - 2016 - Multi-Dimensional Analysis of Software Power Consu.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/TCHAYPAL/tel-01403559.html:text/html},
}

@inproceedings{vereecken_overall_2010,
	title = {Overall {ICT} footprint and green communication technologies},
	doi = {10.1109/ISCCSP.2010.5463327},
	abstract = {Green communication technologies currently receive a lot of attention. In this paper we give an overview of the environmental issues related to communication technologies en present an estimation of the overall ICT footprint. Additionally we present some approaches on how to reduce this footprint and how ICT can assist in other sectors reducing their footprint.},
	booktitle = {2010 4th {International} {Symposium} on {Communications}, {Control} and {Signal} {Processing} ({ISCCSP})},
	author = {Vereecken, W. and Heddeghem, W. Van and Colle, D. and Pickavet, M. and Demeester, P.},
	month = mar,
	year = {2010},
	keywords = {Carbon dioxide, Communication system control, Communications technology, Energy consumption, Energy efficiency, environmental factors, environmental issues, green communication technologies, information technology, Ores, overall ICT footprint, Process control, Recycling, Signal processing, Waste materials},
	pages = {1--6},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/IBJD2CH2/5463327.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/8RDP4UKP/Vereecken et al. - 2010 - Overall ICT footprint and green communication tech.pdf:application/pdf},
}

@article{ni_review_2017,
	title = {A review of air conditioning energy performance in data centers},
	volume = {67},
	issn = {1364-0321},
	url = {http://www.sciencedirect.com/science/article/pii/S136403211630541X},
	doi = {10.1016/j.rser.2016.09.050},
	abstract = {During the last years, many countries are experiencing rapid expansions in the number and size of data centers to keep pace with their internet and cloud computing needs. High energy consumption of the data center has gradually attracted public attention. However, there are no common efficiency standards governing the design or operation of data centers and the associated air conditioning systems. And the statistical research on air conditioning energy performance is still sorely lacking. This paper presents a summary of 100 data centers air conditioning energy performance. Energy efficiency metrics and benchmarks are also provided so that operators can use these information to track the performance of and identify opportunities to reduce energy use of air conditioning systems in their data centers. The collected data from articles and reports show that the average of HVAC system effectiveness index is 1.44. More than half of the data centers’ air conditioning systems are inefficient. In total, HVAC systems account for about 38\% of facility energy consumption. The range for this usage was 21\% for the most efficient system and 61\% for the least efficient system. Moreover it would be necessary to review some currently available energy efficiency strategies such as economizer cycles, airflow optimization, energy management, and simulations tools.},
	urldate = {2018-06-21},
	journal = {Renewable and Sustainable Energy Reviews},
	author = {Ni, Jiacheng and Bai, Xuelian},
	month = jan,
	year = {2017},
	keywords = {Air conditioning, Data center, Energy efficiency, Energy performance},
	pages = {625--640},
	file = {ScienceDirect Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/8YCUD7CT/Ni and Bai - 2017 - A review of air conditioning energy performance in.pdf:application/pdf;ScienceDirect Snapshot:/Users/chakibbelgaid/Zotero newone/storage/BI6KY2MR/S136403211630541X.html:text/html},
}

@article{noauthor_epa_2007,
	title = {{EPA} {Report} to {Congress} on {Server} and {Data} {Center} {Energy} {Efficiency}},
	language = {en},
	year = {2007},
	pages = {13},
	file = {2007 - EPA Report to Congress on Server and Data Center E.pdf:/Users/chakibbelgaid/Zotero newone/storage/926X88QN/2007 - EPA Report to Congress on Server and Data Center E.pdf:application/pdf},
}

@misc{noauthor_survey_2018,
	title = {A survey on techniques for improving the energy efficiency of large-scale distributed systems},
	url = {https://dl.acm.org/citation.cfm?id=2532637},
	urldate = {2018-06-21},
	month = jun,
	year = {2018},
	file = {A survey on techniques for improving the energy efficiency of large-scale distributed systems:/Users/chakibbelgaid/Zotero newone/storage/9MYT85PG/citation.html:text/html},
}

@article{orgerie_survey_2014,
	title = {A survey on techniques for improving the energy efficiency of large-scale distributed systems},
	volume = {46},
	issn = {03600300},
	url = {http://dl.acm.org/citation.cfm?doid=2597757.2532637},
	doi = {10.1145/2532637},
	language = {en},
	number = {4},
	urldate = {2018-06-21},
	journal = {ACM Computing Surveys},
	author = {Orgerie, Anne-Cecile and Assuncao, Marcos Dias de and Lefevre, Laurent},
	month = mar,
	year = {2014},
	note = {Number: 4},
	pages = {1--31},
	file = {Orgerie et al. - 2014 - A survey on techniques for improving the energy ef.pdf:/Users/chakibbelgaid/Zotero newone/storage/2NIWT9N3/Orgerie et al. - 2014 - A survey on techniques for improving the energy ef.pdf:application/pdf},
}

@inproceedings{mcintire_etop-sensor_2007,
	title = {etop-{Sensor} {Network} {Application} {Energy} {Profiling} on the {LEAP2} {Platform}},
	doi = {10.1109/IPSN.2007.4379734},
	abstract = {A broad range of embedded networked sensor (ENS) systems for critical environmental monitoring applications now require complex, high peak power dissipating sensor devices, as well as on-demand high performance computing and high bandwidth communication. Embedded computing demands for these new platforms include support for computationally intensive image and signal processing as well as optimization and statistical computing. To meet these new requirements while maintaining critical support for low energy operation, a new multiprocessor node hardware and software architecture, low power energy aware Processing (LEAP), has been developed. The LEAP architecture integrates fine-grained energy dissipation monitoring and sophisticated power control scheduling for all subsystems including sensor subsystems. The LEAP2 platform is a second generation LEAP system with even higher resolution energy monitoring as well as the unique ability to do per process and per application energy profiling via a dedicated high performance ASIC. Our demonstration will highlight this profiling capability through a custom monitoring application named etop.},
	booktitle = {2007 6th {International} {Symposium} on {Information} {Processing} in {Sensor} {Networks}},
	author = {McIntire, D. and Stathopoulos, T. and Kaiser, W.},
	month = apr,
	year = {2007},
	keywords = {Algorithms, Bandwidth, Computer architecture, Design, Embedded computing, Embedded wireless networked sensor, Energy dissipation, energy profiling, energy-aware multiprocessor platform, Experimentation, Hardware, High performance computing, Management, Measurement, Monitoring, Performance, power aware applications, Reliability, Sensor systems and applications, Signal processing, Software architecture},
	pages = {576--577},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/Y6KK724A/4379734.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/5QV4U78K/McIntire et al. - 2007 - etop-Sensor Network Application Energy Profiling o.pdf:application/pdf},
}

@inproceedings{hindle_greenminer_2014,
	address = {New York, NY, USA},
	series = {{MSR} 2014},
	title = {{GreenMiner}: {A} {Hardware} {Based} {Mining} {Software} {Repositories} {Software} {Energy} {Consumption} {Framework}},
	isbn = {978-1-4503-2863-0},
	shorttitle = {{GreenMiner}},
	url = {http://doi.acm.org/10.1145/2597073.2597097},
	doi = {10.1145/2597073.2597097},
	abstract = {Green Mining is a field of MSR that studies software energy consumption and relies on software performance data. Unfortunately there is a severe lack of publicly available software power use performance data. This means that green mining researchers must generate this data themselves by writing tests, building multiple revisions of a product, and then running these tests multiple times (10+) for each software revision while measuring power use. Then, they must aggregate these measurements to estimate the energy consumed by the tests for each software revision. This is time consuming and is made more difficult by the constraints of mobile devices and their OSes. In this paper we propose, implement, and demonstrate Green Miner: the first dedicated hardware mining software repositories testbed. The Green Miner physically measures the energy consumption of mobile devices (Android phones) and automates the testing of applications, and the reporting of measurements back to developers and researchers. The Green Miner has already produced valuable results for commercial Android application developers, and has been shown to replicate other power studies' results.},
	urldate = {2018-06-22},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Hindle, Abram and Wilson, Alex and Rasmussen, Kent and Barlow, E. Jed and Campbell, Joshua Charles and Romansky, Stephen},
	year = {2014},
	keywords = {Android, Software Change, Software Energy Consumption},
	pages = {12--21},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/I8NZXEJT/Hindle et al. - 2014 - GreenMiner A Hardware Based Mining Software Repos.pdf:application/pdf},
}

@incollection{liu_data-oriented_2015,
	address = {Berlin, Heidelberg},
	title = {Data-{Oriented} {Characterization} of {Application}-{Level} {Energy} {Optimization}},
	volume = {9033},
	isbn = {978-3-662-46674-2 978-3-662-46675-9},
	url = {http://link.springer.com/10.1007/978-3-662-46675-9_21},
	abstract = {Empowering application programmers to make energy-aware decisions is a critical dimension in improving energy eﬃciency of computer systems. Despite the growing interest in designing software development processes, frameworks, and programming models to facilitate application-level energy management, little is empirically known on how application-level features impact energy management. In this paper, we illuminate the optimization space of application-level energy management, from a novel data-oriented perspective. First, we study the varying energy impacts of alternative data management choices by programmers, such as data access patterns, data precision choices, and data organization. Second, we attempt to build a bridge between application-level energy management and hardware-level energy management, by elucidating how various application-level features respond to Dynamic Voltage and Frequency Scaling (DVFS), arguably the most classic hardware-based energy management approach. Finally, we apply our ﬁndings to real-world applications, demonstrating their potential for greater energy savings. The empirical study is particularly relevant in the Big Data era, where dataintensive applications are large energy consumers, and their energy eﬃciency is strongly correlated to how data are maintained and handled in programs.},
	language = {en},
	urldate = {2018-06-22},
	booktitle = {Fundamental {Approaches} to {Software} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Liu, Kenan and Pinto, Gustavo and Liu, Yu David},
	editor = {Egyed, Alexander and Schaefer, Ina},
	year = {2015},
	doi = {10.1007/978-3-662-46675-9_21},
	pages = {316--331},
	file = {Liu et al. - 2015 - Data-Oriented Characterization of Application-Leve.pdf:/Users/chakibbelgaid/Zotero newone/storage/37WXZYGG/Liu et al. - 2015 - Data-Oriented Characterization of Application-Leve.pdf:application/pdf},
}

@inproceedings{subramaniam_towards_2013,
	title = {Towards energy-proportional computing for enterprise-class server workloads},
	isbn = {978-1-4503-1636-1},
	url = {http://dl.acm.org/citation.cfm?doid=2479871.2479878},
	doi = {10.1145/2479871.2479878},
	abstract = {Massive data centers housing thousands of computing nodes have become commonplace in enterprise computing, and the power consumption of such data centers is growing at an unprecedented rate. Adding to the problem is the inability of the servers to exhibit energy proportionality, i.e., provide energy-eﬃcient execution under all levels of utilization, which diminishes the overall energy eﬃciency of the data center. It is imperative that we realize eﬀective strategies to control the power consumption of the server and improve the energy eﬃciency of data centers. With the advent of Intel Sandy Bridge processors, we have the ability to specify a limit on power consumption during runtime, which creates opportunities to design new power-management techniques for enterprise workloads and make the systems that they run on more energy proportional.},
	language = {en},
	urldate = {2018-06-22},
	publisher = {ACM Press},
	author = {Subramaniam, Balaji and Feng, Wu-chun},
	year = {2013},
	pages = {15},
	file = {Subramaniam and Feng - 2013 - Towards energy-proportional computing for enterpri.pdf:/Users/chakibbelgaid/Zotero newone/storage/4EIXBPBJ/Subramaniam and Feng - 2013 - Towards energy-proportional computing for enterpri.pdf:application/pdf},
}

@article{lawall_coccinelle_nodate,
	title = {Coccinelle: {Practical} {Program} {Transformation} for the {Linux} {Kernel}},
	language = {en},
	journal = {critical infrastructure},
	author = {Lawall, Julia},
	pages = {64},
	file = {Lawall - Coccinelle Practical Program Transformation for t.pdf:/Users/chakibbelgaid/Zotero newone/storage/FUN4GE8U/Lawall - Coccinelle Practical Program Transformation for t.pdf:application/pdf},
}

@article{lawall_coccinelle_nodate-1,
	title = {Coccinelle {Features}},
	language = {en},
	author = {Lawall, Julia},
	pages = {27},
	file = {Lawall - Coccinelle Features.pdf:/Users/chakibbelgaid/Zotero newone/storage/29RFM95P/Lawall - Coccinelle Features.pdf:application/pdf},
}

@article{lawall_introduction_nodate,
	title = {Introduction to {Coccinelle}},
	language = {en},
	author = {Lawall, Julia},
	pages = {45},
	file = {Lawall - Introduction to Coccinelle.pdf:/Users/chakibbelgaid/Zotero newone/storage/Z4UDF99X/Lawall - Introduction to Coccinelle.pdf:application/pdf},
}

@article{ortin_hybrid_2014,
	title = {A hybrid class- and prototype-based object model to support language-neutral structural intercession},
	volume = {56},
	issn = {0950-5849},
	url = {http://www.sciencedirect.com/science/article/pii/S0950584913001778},
	doi = {10.1016/j.infsof.2013.09.002},
	abstract = {Context
Dynamic languages have turned out to be suitable for developing specific applications where runtime adaptability is an important issue. Although .Net and Java platforms have gradually incorporated features to improve their support of dynamic languages, they do not provide intercession for every object or class. This limitation is mainly caused by the rigid class-based object model these platforms implement, in contrast to the flexible prototype-based model used by most dynamic languages.
Objective
Our approach is to provide intercession for any object or class by defining a hybrid class- and prototype-based object model that efficiently incorporates structural intercession into the object model implemented by the widespread .Net and Java platforms.
Method
In a previous work, we developed and evaluated an extension of a shared-source implementation of the .Net platform. In this work, we define the formal semantics of the proposed reflective model, and modify the existing implementation to include the hybrid model. Finally, we assess its runtime performance and memory consumption, comparing it to existing approaches.
Results
Our platform shows a competitive runtime performance compared to 9 widespread systems. On average, it performs 73\% and 61\% better than the second fastest system for short- and long-running applications, respectively. Besides, it is the JIT-compiler approach that consumes less average memory. The proposed approach of including a hybrid object-model into the virtual machine involves a 444\% performance improvement (and 65\% less memory consumption) compared to the existing alternative of creating an extra software layer (the DLR). When none of the new features are used, our platform requires 12\% more execution time and 13\% more memory than the original .Net implementation.
Conclusion
Our proposed hybrid class- and prototype-based object model supports structural intercession for any object or class. It can be included in existing JIT-compiler class-based platforms to support common dynamic languages, providing competitive runtime performance and low memory consumption.},
	number = {2},
	urldate = {2018-07-02},
	journal = {Information and Software Technology},
	author = {Ortin, Francisco and Labrador, Miguel A. and Redondo, Jose M.},
	month = feb,
	year = {2014},
	note = {Number: 2},
	keywords = {Duck typing, Dynamic languages, Prototype-based object model, Reflection, Structural intercession, Virtual machine},
	pages = {199--219},
	file = {ScienceDirect Snapshot:/Users/chakibbelgaid/Zotero newone/storage/8P2M47MJ/S0950584913001778.html:text/html},
}

@incollection{tratt_chapter_2009,
	title = {Chapter 5 {Dynamically} {Typed} {Languages}},
	volume = {77},
	url = {http://www.sciencedirect.com/science/article/pii/S0065245809012054},
	abstract = {Dynamically typed languages such as Python and Ruby have experienced a rapid grown in popularity in recent times. However, there is much confusion as to what makes these languages interesting relative to statically typed languages, and little knowledge of their rich history. In this chapter, I explore the general topic of dynamically typed languages, how they differ from statically typed languages, their history, and their defining features.},
	urldate = {2018-07-02},
	booktitle = {Advances in {Computers}},
	publisher = {Elsevier},
	author = {Tratt, Laurence},
	month = jan,
	year = {2009},
	doi = {10.1016/S0065-2458(09)01205-4},
	pages = {149--184},
	file = {ScienceDirect Snapshot:/Users/chakibbelgaid/Zotero newone/storage/4E5UCRER/S0065245809012054.html:text/html},
}

@article{paulson_developers_2007,
	title = {Developers shift to dynamic programming languages},
	volume = {40},
	issn = {0018-9162},
	doi = {10.1109/MC.2007.53},
	abstract = {Software developers are always looking for ways to boost their effectiveness and productivity and perform complex jobs more quickly and easily, particularly as projects have become increasingly large and complex. Programmers want to shed unneeded complexity and outdated methodologies and move to approaches that focus on making programming simpler and faster. With this in mind, many developers are increasingly using dynamic languages such as JavaScript, Perl, Python, and Ruby. Although software experts disagree on the exact definition, a dynamic language basically enables programs that can change their code and logical structures at runtime, adding variable types, module names, classes, and functions as they are running. These languages frequently are interpreted and generally check typing at runtime},
	number = {2},
	journal = {Computer},
	author = {Paulson, L. D.},
	month = feb,
	year = {2007},
	note = {Number: 2},
	keywords = {Application software, C++ language, Computer languages, Dynamic programming, dynamic programming languages, Error correction, Java, JavaScript, Memory management, Mission critical systems, parallel languages, Perl, PHP, Programming profession, Python, Ruby, Runtime, software developers, Testing},
	pages = {12--15},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/GW3NQDCX/4085614.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/ISMKEXML/Paulson - 2007 - Developers shift to dynamic programming languages.pdf:application/pdf},
}

@inproceedings{deutsch_efficient_1984,
	address = {New York, NY, USA},
	series = {{POPL} '84},
	title = {Efficient {Implementation} of the {Smalltalk}-80 {System}},
	isbn = {978-0-89791-125-2},
	url = {http://doi.acm.org/10.1145/800017.800542},
	doi = {10.1145/800017.800542},
	abstract = {The Smalltalk-80* programming language includes dynamic storage allocation, full upward funargs, and universally polymorphic procedures; the Smalltalk-80 programming system features interactive execution with incremental compilation, and implementation portability. These features of modern programming systems are among the most difficult to implement efficiently, even individually. A new implementation of the Smalltalk-80 system, hosted on a small microprocessor-based computer, achieves high performance while retaining complete (object code) compatibility with existing implementations. This paper discusses the most significant optimization techniques developed over the course of the project, many of which are applicable to other languages. The key idea is to represent certain runtime state (both code and data) in more than one form, and to convert between forms when needed.},
	urldate = {2018-07-02},
	booktitle = {Proceedings of the 11th {ACM} {SIGACT}-{SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Deutsch, L. Peter and Schiffman, Allan M.},
	year = {1984},
	pages = {297--302},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/8L7AZLJM/Deutsch and Schiffman - 1984 - Efficient Implementation of the Smalltalk-80 Syste.pdf:application/pdf},
}

@inproceedings{bolz_tracing_2009,
	address = {New York, NY, USA},
	series = {{ICOOOLPS} '09},
	title = {Tracing the {Meta}-level: {PyPy}'s {Tracing} {JIT} {Compiler}},
	isbn = {978-1-60558-541-3},
	shorttitle = {Tracing the {Meta}-level},
	url = {http://doi.acm.org/10.1145/1565824.1565827},
	doi = {10.1145/1565824.1565827},
	abstract = {We attempt to apply the technique of Tracing JIT Compilers in the context of the PyPy project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing JIT compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing JIT to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing JIT compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two PyPy interpreters: one is a small example, and the other one is the full Python interpreter.},
	urldate = {2018-07-02},
	booktitle = {Proceedings of the 4th {Workshop} on the {Implementation}, {Compilation}, {Optimization} of {Object}-{Oriented} {Languages} and {Programming} {Systems}},
	publisher = {ACM},
	author = {Bolz, Carl Friedrich and Cuni, Antonio and Fijalkowski, Maciej and Rigo, Armin},
	year = {2009},
	pages = {18--25},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/P7QBGTBN/Bolz et al. - 2009 - Tracing the Meta-level PyPy's Tracing JIT Compile.pdf:application/pdf},
}

@article{murri_performance_2014,
	title = {Performance of {Python} runtimes on a non-numeric scientific code},
	url = {http://arxiv.org/abs/1404.6388},
	abstract = {The Python library FatGHol FatGHoL used in Murri2012 to reckon the rational homology of the moduli space of Riemann surfaces is an example of a non-numeric scientific code: most of the processing it does is generating graphs (represented by complex Python objects) and computing their isomorphisms (a triple of Python lists; again a nested data structure). These operations are repeated many times over: for example, the spaces and are triangulated by 4'583'322 and 747'664 graphs, respectively. This is an opportunity for every Python runtime to prove its strength in optimization. The purpose of this experiment was to assess the maturity of alternative Python runtimes, in terms of: compatibility with the language as implemented in CPython 2.7, and performance speedup. This paper compares the results and experiences from running FatGHol with different Python runtimes: CPython 2.7.5, PyPy 2.1, Cython 0.19, Numba 0.11, Nuitka 0.4.4 and Falcon.},
	urldate = {2018-07-02},
	journal = {arXiv:1404.6388 [cs]},
	author = {Murri, Riccardo},
	month = apr,
	year = {2014},
	note = {arXiv: 1404.6388},
	keywords = {Computer Science - Mathematical Software, Computer Science - Programming Languages},
	annote = {Comment: Part of the Proceedings of the 6th European Conference on Python in Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)},
	file = {arXiv\:1404.6388 PDF:/Users/chakibbelgaid/Zotero newone/storage/CLERKQPI/Murri - 2014 - Performance of Python runtimes on a non-numeric sc.pdf:application/pdf;arXiv.org Snapshot:/Users/chakibbelgaid/Zotero newone/storage/GE45XHDB/1404.html:text/html},
}

@article{shepard_livelab_2011,
	title = {{LiveLab}: {Measuring} {Wireless} {Networks} and {Smartphone} {Users} in the {Field}},
	volume = {38},
	issn = {0163-5999},
	shorttitle = {{LiveLab}},
	url = {http://doi.acm.org/10.1145/1925019.1925023},
	doi = {10.1145/1925019.1925023},
	abstract = {We present LiveLab, a methodology to measure real-world smartphone usage and wireless networks with a reprogrammable indevice logger designed for long-term user studies. We discuss the challenges of privacy protection and power impact in LiveLab and offer our solutions. We present an iPhone 3GS based deployment of LiveLab with 25 users intended for one year. Early results from the data collection so far highlight the unique strengths and potential of LiveLab. We have two objectives in this position paper. First, we demonstrate the feasibility and capability of LiveLab. By sharing our experience, we seek to advocate LiveLab as a network and user measurement methodology. Second, we present our preliminary findings, and seek feedback from the community regarding what data to collect.},
	number = {3},
	urldate = {2018-07-08},
	journal = {SIGMETRICS Perform. Eval. Rev.},
	author = {Shepard, Clayton and Rahmati, Ahmad and Tossell, Chad and Zhong, Lin and Kortum, Phillip},
	month = jan,
	year = {2011},
	note = {Number: 3},
	pages = {15--20},
}

@article{procaccianti_empirical_2016,
	title = {Empirical evaluation of two best practices for energy-efficient software development},
	volume = {117},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121216000777},
	doi = {10.1016/j.jss.2016.02.035},
	abstract = {Background. Energy efficiency is an increasingly important property of software. A large number of empirical studies have been conducted on the topic. However, current state-of-the-Art does not provide empirically-validated guidelines for developing energy-efficient software. Aim. This study aims at assessing the impact, in terms of energy savings, of best practices for achieving software energy efficiency, elicited from previous work. By doing so, it identifies which resources are affected by the practices and the possible trade-offs with energy consumption. Method. We performed an empirical experiment in a controlled environment, where we applied two different Green Software practices to two software applications, namely query optimization in MySQL Server and usage of “sleep” instruction in the Apache web server. We then performed a comparison of the energy consumption at system-level and at resource-level, before and after applying the practice. Results. Our results show that both practices are effective in improving software energy efficiency, reducing consumption up to 25\%. We observe that after applying the practices, resource usage is more energy-proportional i.e., increasing CPU usage increases energy consumption in an almost linear way. We also provide our reflections on empirical experimentation in software energy efficiency. Conclusions. Our contribution shows that significant improvements in software energy efficiency can be gained by applying best practices during design and development. Future work will be devoted to further validate best practices, and to improve their reusability.},
	urldate = {2018-09-06},
	journal = {Journal of Systems and Software},
	author = {Procaccianti, Giuseppe and Fernández, Héctor and Lago, Patricia},
	month = jul,
	year = {2016},
	keywords = {Best practices, Energy efficiency, Software engineering},
	pages = {185--198},
	file = {ScienceDirect Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/URFCAUSA/Procaccianti et al. - 2016 - Empirical evaluation of two best practices for ene.pdf:application/pdf;ScienceDirect Snapshot:/Users/chakibbelgaid/Zotero newone/storage/ETR782KY/S0164121216000777.html:text/html},
}

@article{sahin_benchmarks_2016,
	title = {From benchmarks to real apps: {Exploring} the energy impacts of performance-directed changes},
	volume = {117},
	issn = {0164-1212},
	shorttitle = {From benchmarks to real apps},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121216000893},
	doi = {10.1016/j.jss.2016.03.031},
	abstract = {Battery life is an increasing concern for mobile devices. Recent studies have provided initial evidence that applying performance tips is an effective mechanism for decreasing energy usage. However, the generalizability of such studies to real applications is unclear. We aim to provide deeper insights into whether mobile application developers can effectively reduce the energy consumption of their applications by applying performance tips. We conducted an empirical study to investigate the energy impacts of applying four commonly suggested performance tips to eight real Android applications. Considered performance tips are unlikely to impact energy usage in a statistically significant manner and, even when the impacts are statistically significant, the change in battery life is around 1\%. Mobile application developers cannot expect to improve the energy usage of their applications as a by product of performance improvements. Tools and techniques that specifically target energy usage are necessary for significant improvements.},
	urldate = {2018-09-06},
	journal = {Journal of Systems and Software},
	author = {Sahin, Cagri and Pollock, Lori and Clause, James},
	month = jul,
	year = {2016},
	keywords = {Android applications, Energy efficiency, Performance tips},
	pages = {307--316},
	file = {ScienceDirect Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/FGZK8M7K/Sahin et al. - 2016 - From benchmarks to real apps Exploring the energy.pdf:application/pdf;ScienceDirect Snapshot:/Users/chakibbelgaid/Zotero newone/storage/GCNTSMAC/S0164121216000893.html:text/html},
}

@article{mccullough_evaluating_nodate,
	title = {Evaluating the {Effectiveness} of {Model}-{Based} {Power} {Characterization}},
	abstract = {Accurate power characterization is important in computing platforms for several reasons ranging from poweraware adaptation to power provisioning. Power characterization is typically obtained through either direct measurements enabled by physical instrumentation or modeling based on hardware performance counters. We show, however, that linear-regression based modeling techniques commonly used in the literature work well only in restricted settings. These techniques frequently exhibit high prediction error in modern computing platforms due to inherent complexities such as multiple cores, hidden device states, and large dynamic power components.},
	language = {en},
	author = {McCullough, John C and Agarwal, Yuvraj and Chandrashekar, Jaideep and Kuppuswamy, Sathyanarayan and Snoeren, Alex C and Gupta, Rajesh K},
	pages = {14},
	file = {McCullough et al. - Evaluating the Effectiveness of Model-Based Power .pdf:/Users/chakibbelgaid/Zotero newone/storage/74KK3WLU/McCullough et al. - Evaluating the Effectiveness of Model-Based Power .pdf:application/pdf},
}

@inproceedings{chowdhury_client-side_2016,
	title = {Client-{Side} {Energy} {Efficiency} of {HTTP}/2 for {Web} and {Mobile} {App} {Developers}},
	volume = {1},
	doi = {10.1109/SANER.2016.77},
	abstract = {Recent technological advancements have enabled mobile devices to provide mobile users with substantial capability and accessibility. Energy is evidently one of the most critical resources for such devices, in spite of the substantial gain in popularity of mobile devices, such as smart phones, their utility is severely constrained by the bounded battery capacity. Mobile users are very interested in accessing the Internet although it is one of the most expensive operations in terms of energy and cost. HTTP/2 has been proposed and accepted as the new standard for supporting the World Wide Web. HTTP/2 is expected to offer better performance, such as reduced page load time. Consequently, from the mobile users point of view, the question arises:does HTTP/2 offer improved energy consumption performance achieving longer battery life?In this paper, we compare the energy consumption of HTTP/2 with its predecessor (i.e., HTTP/1.1) using a variety of realworld and synthetic test scenarios. We also investigate how Transport Layer Security (TLS) impacts the energy consumption of the mobile devices. Our study suggests that Round Trip Time (RTT) is one of the biggest factors in deciding how advantageous HTTP/2 is compared to HTTP/1.1. We conclude that for networks with higher RTTs, HTTP/2 has better energy consumption performance than HTTP/1.1.},
	booktitle = {2016 {IEEE} 23rd {International} {Conference} on {Software} {Analysis}, {Evolution}, and {Reengineering} ({SANER})},
	author = {Chowdhury, S. A. and Sapra, V. and Hindle, A.},
	month = mar,
	year = {2016},
	keywords = {Android applications, Energy consumption, GreenMining, HTTP/2 client-side energy efficiency, improving energy consumption, Internet, Mining software repositories, mobile app developers, Mobile communication, mobile computing, mobile device energy consumption, Modeling energy consumption, power aware computing, Protocols, reduced page load time, round trip time, Servers, smart phone battery capacity, Smart phones, Software energy, transport layer security, Web developers, World Wide Web},
	pages = {529--540},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/HG9QLISW/7476672.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/KQEAIZQG/Chowdhury et al. - 2016 - Client-Side Energy Efficiency of HTTP2 for Web an.pdf:application/pdf},
}

@phdthesis{boussaa_automatic_2017,
	type = {phdthesis},
	title = {Automatic non-functional testing and tuning of configurable generators},
	url = {https://tel.archives-ouvertes.fr/tel-01598821/document},
	abstract = {Generative software development has paved the way for the creation of multiple generators (code generators and compilers) that serve as a basis for automatically producing code to a broad range of software and hardware platforms. With full automatic code generation, users are able to rapidly synthesize software artifacts for various software platforms. In addition, they can easily customize the generated code for the target hardware platform since modern generators (i.e., C compilers) become highly configurable, offering numerous configuration options that the user can apply. Consequently, the quality of generated software becomes highly correlated to the configuration settings as well as to the generator itself. In this context, it is crucial to verify the correct behavior of generators. Numerous approaches have been proposed to verify the functional outcome of generated code but few of them evaluate the non-functional properties of automatically generated code, namely the performance and resource usage properties. This thesis addresses three problems : (1) Non-functional testing of generators: We benefit from the existence of multiple code generators with comparable functionality (i.e., code generator families) to automatically test the generated code. We leverage the metamorphic testing approach to detect non-functional inconsistencies in code generator families by defining metamorphic relations as test oracles. We define the metamorphic relation as a comparison between the variations of performance and resource usage of code, generated from the same code generator family. We evaluate our approach by analyzing the performance of HAXE, a popular code generator family. Experimental results show that our approach is able to automatically detect several inconsistencies that reveal real issues in this family of code generators. (2) Generators auto-tuning: We exploit the recent advances in search-based software engineering in order to provide an effective approach to tune generators (i.e., through optimizations) according to user's non-functional requirements (i.e., performance and resource usage). We also demonstrate that our approach can be used to automatically construct optimization levels that represent optimal trade-offs between multiple non-functional properties such as execution time and resource usage requirements. We evaluate our approach by verifying the optimizations performed by the GCC compiler. Our experimental results show that our approach is able to auto-tune compilers and construct optimizations that yield to better performance results than standard optimization levels. (3) Handling the diversity of software and hardware platforms in software testing: Running tests and evaluating the resource usage in heterogeneous environments is tedious. To handle this problem, we benefit from the recent advances in lightweight system virtualization, in particular container-based virtualization, in order to offer effective support for automatically deploying, executing, and monitoring code in heterogeneous environment, and collect non-functional metrics (e.g., memory and CPU consumptions). This testing infrastructure serves as a basis for evaluating the experiments conducted in the two first contributions.},
	language = {en},
	urldate = {2018-10-08},
	school = {Université Rennes 1},
	author = {Boussaa, Mohamed},
	month = sep,
	year = {2017},
	file = {Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/3CNKK37G/Boussaa - 2017 - Automatic non-functional testing and tuning of con.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/2WAMCY43/tel-01619139.html:text/html},
}

@misc{noauthor_holistic_2018,
	title = {A {Holistic} {Evaluation} of {Docker} {Containers} for {Interfering} {Microservices} - {IEEE} {Conference} {Publication}},
	url = {https://ieeexplore.ieee.org/document/8456398},
	urldate = {2018-10-18},
	month = oct,
	year = {2018},
	file = {A Holistic Evaluation of Docker Containers for Interfering Microservices - IEEE Conference Publication:/Users/chakibbelgaid/Zotero newone/storage/D6V3MCGM/8456398.html:text/html},
}

@article{santos_how_2018-1,
	title = {How does docker affect energy consumption? {Evaluating} workloads in and out of {Docker} containers},
	volume = {146},
	issn = {0164-1212},
	shorttitle = {How does docker affect energy consumption?},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121218301456},
	doi = {10.1016/j.jss.2018.07.077},
	abstract = {Context: Virtual machines provide isolation of services at the cost of hypervisors and more resource usage. This spurred the growth of systems like Docker that enable single hosts to isolate several applications, similar to VMs, within a low-overhead abstraction called containers. Motivation: Although containers tout low overhead performance, how much do they increase energy use? Methodology: This work statistically compares the energy consumption of three application workloads in Docker and on bare-metal Linux. Results: In all cases, there was a statistically significant (t-test and Wilcoxon p {\textless} .05) increase in energy consumption when running tests in Docker, mostly due to the performance of I/O system calls. Developers worried about I/O overhead could consider baremetal deployments over Docker container deployments.},
	urldate = {2018-10-23},
	journal = {Journal of Systems and Software},
	author = {Santos, Eddie Antonio and McLean, Carson and Solinas, Christopher and Hindle, Abram},
	month = dec,
	year = {2018},
	keywords = {Cloud computing, Containerization, docker, Docker, Energy consumption, Microservice, Virtualization},
	pages = {14--25},
	file = {Santos et al. - 2018 - How does docker affect energy consumption Evaluat.pdf:/Users/chakibbelgaid/Zotero newone/storage/QEGG5LGV/Santos et al. - 2018 - How does docker affect energy consumption Evaluat.pdf:application/pdf;ScienceDirect Snapshot:/Users/chakibbelgaid/Zotero newone/storage/CKBCUN8V/S0164121218301456.html:text/html},
}

@misc{noauthor_pypl_2018,
	title = {{PYPL} {PopularitY} of {Programming} {Language} index},
	url = {https://pypl.github.io/PYPL.html},
	abstract = {PYPL popularity of programming language},
	language = {en},
	urldate = {2018-10-23},
	month = oct,
	year = {2018},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/TASCBWVV/PYPL.html:text/html},
}

@article{pang_what_nodate,
	title = {What {Programming} {Languages} {Do} {Developers} {Use}? {A} {Theory} of {Static} vs {Dynamic} {Language} {Choice}},
	abstract = {We know very little about why developers do what they do. Lab studies are all very well, but often their results (e.g. that static type systems make development faster) seem contradicted by practice (e.g. developers choosing JavaScript or Python rather than Java or C\#). In this paper we build a ﬁrst cut of a theory of why developers do what they do with a focus on the domain of static versus dynamic programming languages. We used a qualitative research method – Grounded Theory, to interview a number of developers (n=15) about their experience using static and dynamic languages, and constructed a Grounded Theory of their programming language choices.},
	language = {en},
	author = {Pang, Aaron and Anslow, Craig and Noble, James},
	pages = {9},
	file = {Pang et al. - What Programming Languages Do Developers Use A Th.pdf:/Users/chakibbelgaid/Zotero newone/storage/XI73MUQT/Pang et al. - What Programming Languages Do Developers Use A Th.pdf:application/pdf},
}

@misc{noauthor_which_2018,
	title = {Which benchmark programs are faster? {\textbar} {Computer} {Language} {Benchmarks} {Game}},
	url = {https://benchmarksgame-team.pages.debian.net/benchmarksgame/},
	urldate = {2018-10-23},
	month = oct,
	year = {2018},
	file = {Which benchmark programs are faster? | Computer Language Benchmarks Game:/Users/chakibbelgaid/Zotero newone/storage/H6RHNVCB/benchmarksgame.html:text/html},
}

@inproceedings{romansky_deep_2017,
	title = {Deep {Green}: {Modelling} {Time}-{Series} of {Software} {Energy} {Consumption}},
	shorttitle = {Deep {Green}},
	doi = {10.1109/ICSME.2017.79},
	abstract = {Inefficient mobile software kills battery life. Yet, developers lack the tools necessary to detect and solve energy bugs in software. In addition, developers are usually tasked with the creation of software features and triaging existing bugs. This means that most developers do not have the time or resources to research, build, or employ energy debugging tools. We present a new method for predicting software energy consumption to help debug software energy issues. Our approach enables developers to align traces of software behavior with traces of software energy consumption. This allows developers to match run-time energy hot spots to the corresponding execution. We accomplish this by applying recent neural network models to predict time series of energy consumption given a software's behavior. We compare our time series models to prior state-of-the-art models that only predict total software energy consumption. We found that machine learning based time series based models, and LSTM based time series based models, can often be more accurate at predicting instantaneous power use and total energy consumption.},
	booktitle = {2017 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	author = {Romansky, S. and Borle, N. C. and Chowdhury, S. and Hindle, A. and Greiner, R.},
	month = sep,
	year = {2017},
	keywords = {battery life, deep green, energy, energy consumption, Energy consumption, energy debugging tools, Energy measurement, green mining, Hardware, learning (artificial intelligence), LSTM, machine learning, mobile computing, mobile software, modelling, neural nets, online model, power aware computing, Predictive models, profiling, program debugging, program diagnostics, run-time energy hot spots, Software, software behavior tracing, software engineering, time series, Time series analysis, time series models, Tools, total energy consumption, total software energy consumption},
	pages = {273--283},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/K4LL8AIF/8094428.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/5WYNHFAP/Romansky et al. - 2017 - Deep Green Modelling Time-Series of Software Ener.pdf:application/pdf},
}

@book{padala_virtualization_2018,
	title = {Virtualization of {Data} {Centers} : study on {Server} {Energy} {Consumption} {Performance}},
	shorttitle = {Virtualization of {Data} {Centers}},
	url = {http://urn.kb.se/resolve?urn=urn:nbn:se:bth-16011},
	abstract = {DiVA portal is a finding tool for research publications and student theses written at the following 47 universities and research institutions.},
	language = {eng},
	urldate = {2018-11-19},
	author = {Padala, Praneel Reddy},
	year = {2018},
	file = {Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/XQKGE4NN/Padala - 2018 - Virtualization of Data Centers  study on Server E.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/E7A8GYT9/record.html:text/html},
}

@article{avgerinou_trends_2017,
	title = {Trends in {Data} {Centre} {Energy} {Consumption} under the {European} {Code} of {Conduct} for {Data} {Centre} {Energy} {Efficiency}},
	volume = {10},
	copyright = {http://creativecommons.org/licenses/by/3.0/},
	url = {https://www.mdpi.com/1996-1073/10/10/1470},
	doi = {10.3390/en10101470},
	abstract = {Climate change is recognised as one of the key challenges humankind is facing. The Information and Communication Technology (ICT) sector including data centres generates up to 2\% of the global CO2 emissions, a number on par to the aviation sector contribution, and data centres are estimated to have the fastest growing carbon footprint from across the whole ICT sector, mainly due to technological advances such as the cloud computing and the rapid growth of the use of Internet services. There are no recent estimations of the total energy consumption of the European data centre and of their energy efficiency. The aim of this paper is to evaluate, analyse and present the current trends in energy consumption and efficiency in data centres in the European Union using the data submitted by companies participating in the European Code of Conduct for Data Centre Energy Efficiency programme, a voluntary initiative created in 2008 in response to the increasing energy consumption in data centres and the need to reduce the related environmental, economic and energy supply security impacts. The analysis shows that the average Power Usage Effectiveness (PUE) of the facilities participating in the programme is declining year after year. This confirms that voluntary approaches could be effective in addressing climate and energy issue.},
	language = {en},
	number = {10},
	urldate = {2018-11-19},
	journal = {Energies},
	author = {Avgerinou, Maria and Bertoldi, Paolo and Castellazzi, Luca},
	month = sep,
	year = {2017},
	note = {Number: 10},
	keywords = {Data Centre Energy Efficiency, energy efficiency policies, PUE, voluntary agreements},
	pages = {1470},
	file = {Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/9DNAALQ5/Avgerinou et al. - 2017 - Trends in Data Centre Energy Consumption under the.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/XV5UKX3J/1470.html:text/html},
}

@article{dayarathna_data_2016,
	title = {Data {Center} {Energy} {Consumption} {Modeling}: {A} {Survey}},
	volume = {18},
	issn = {1553-877X},
	shorttitle = {Data {Center} {Energy} {Consumption} {Modeling}},
	doi = {10.1109/COMST.2015.2481183},
	abstract = {Data centers are critical, energy-hungry infrastructures that run large-scale Internet-based services. Energy consumption models are pivotal in designing and optimizing energy-efficient operations to curb excessive energy consumption in data centers. In this paper, we survey the state-of-the-art techniques used for energy consumption modeling and prediction for data centers and their components. We conduct an in-depth study of the existing literature on data center power modeling, covering more than 200 models. We organize these models in a hierarchical structure with two main branches focusing on hardware-centric and software-centric power models. Under hardware-centric approaches we start from the digital circuit level and move on to describe higher-level energy consumption models at the hardware component level, server level, data center level, and finally systems of systems level. Under the software-centric approaches we investigate power models developed for operating systems, virtual machines and software applications. This systematic approach allows us to identify multiple issues prevalent in power modeling of different levels of data center systems, including: i) few modeling efforts targeted at power consumption of the entire data center ii) many state-of-the-art power models are based on a few CPU or server metrics, and iii) the effectiveness and accuracy of these power models remain open questions. Based on these observations, we conclude the survey by describing key challenges for future research on constructing effective and accurate data center power models.},
	number = {1},
	journal = {IEEE Communications Surveys Tutorials},
	author = {Dayarathna, M. and Wen, Y. and Fan, R.},
	year = {2016},
	note = {Number: 1},
	keywords = {cloud computing, Cloud Computing, Computational modeling, computer centres, Data center, Data Center, data center energy consumption modeling, data center power modeling, Data models, digital circuit level, energy consumption, Energy consumption, energy consumption modeling, Energy Consumption Modeling, energy efficiency, Energy Efficiency, energy-efficient operations, energy-hungry infrastructures, hardware component level, hardware-centric power models, hierarchical structure, Internet, large-scale Internet-based services, Mathematical model, operating systems, operating systems (computers), power aware computing, Power demand, Predictive models, server level, Servers, software-centric power models, telecommunication power management, virtual machines},
	pages = {732--794},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/9TCTVPR6/7279063.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/MXUGL597/Dayarathna et al. - 2016 - Data Center Energy Consumption Modeling A Survey.pdf:application/pdf},
}

@article{whitley_statistics_2002,
	title = {Statistics review 1: {Presenting} and summarising data},
	volume = {6},
	issn = {1364-8535},
	shorttitle = {Statistics review 1},
	url = {https://www.ncbi.nlm.nih.gov/pmc/articles/PMC137399/},
	abstract = {The present review is the first in an ongoing guide to medical statistics, using specific examples from intensive care. The first step in any analysis is to describe and summarize the data. As well as becoming familiar with the data, this is also an opportunity to look for unusually high or low values (outliers), to check the assumptions required for statistical tests, and to decide the best way to categorize the data if this is necessary. In addition to tables and graphs, summary values are a convenient way to summarize large amounts of information. This review introduces some of these measures. It describes and gives examples of qualitative data (unordered and ordered) and quantitative data (discrete and continuous); how these types of data can be represented figuratively; the two important features of a quantitative dataset (location and variability); the measures of location (mean, median and mode); the measures of variability (range, interquartile range, standard deviation and variance); common distributions of clinical data; and simple transformations of positively skewed data.},
	number = {1},
	urldate = {2018-11-23},
	journal = {Critical Care},
	author = {Whitley, Elise and Ball, Jonathan},
	year = {2002},
	pmid = {11940268},
	pmcid = {PMC137399},
	note = {Number: 1},
	pages = {66--71},
	file = {PubMed Central Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/7YEEL5WN/Whitley and Ball - 2002 - Statistics review 1 Presenting and summarising da.pdf:application/pdf},
}

@article{corcoran_emerging_nodate,
	title = {Emerging	   {Trends}	   in	   {Electricity}	   {Consumption}	    for	   {Consumer}	   {ICT}},
	language = {en},
	author = {Corcoran, Peter and Andrae, Anders},
	pages = {56},
	file = {Corcoran and Andrae - Emerging    Trends    in    Electricity    Consump.pdf:/Users/chakibbelgaid/Zotero newone/storage/6C7KXMBT/Corcoran and Andrae - Emerging    Trends    in    Electricity    Consump.pdf:application/pdf},
}

@inproceedings{pereira_helping_2017,
	address = {Buenos Aires, Argentina},
	title = {Helping {Programmers} {Improve} the {Energy} {Efficiency} of {Source} {Code}},
	isbn = {978-1-5386-1589-8},
	url = {http://ieeexplore.ieee.org/document/7965316/},
	doi = {10.1109/ICSE-C.2017.80},
	abstract = {This paper brieﬂy proposes a technique to detect energy inefﬁcient fragments in the source code of a software system. Test cases are executed to obtain energy consumption measurements, and a statistical method, based on spectrum-based fault localization, is introduced to relate energy consumption to the system’s source code. The result of our technique is an energy ranking of source code fragments pointing developers to possible energy leaks in their code.},
	language = {en},
	urldate = {2019-01-18},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	publisher = {IEEE},
	author = {Pereira, Rui and Carcao, Tiago and Couto, Marco and Cunha, Jacome and Fernandes, Joao Paulo and Saraiva, Joao},
	month = may,
	year = {2017},
	pages = {238--240},
	annote = {\#\# main idea
This paper presents a technique to spot the energy leaks inside a program using a spectrum technique called SPELL (Spectrum-based Energy Leak Localization)
\#\# How it works  
We have a matrix (n*m) where n is the number of the tests and m is the number of components (like classes, methods, packages, etc.) after this we calculate the oracle (a vector that says which component is responsible for what)
 
\#\# Contributions
This paper helps developers to spot the red areas in their code and optimize the energy consumption. As an example it helped to reduce the energy consumption of a java application 50\% faster and with 18\% more efficiency.},
	file = {Pereira et al. - 2017 - Helping Programmers Improve the Energy Efficiency .pdf:/Users/chakibbelgaid/Zotero newone/storage/5FKHHGPV/Pereira et al. - 2017 - Helping Programmers Improve the Energy Efficiency .pdf:application/pdf},
}

@article{park_investigation_nodate,
	title = {Investigation for {Software} {Power} {Consumption} of {Code} {Refactoring} {Techniques}},
	abstract = {Code refactoring technique focuses on enhancing the maintainability of software to extend its lifetime. However, there are other efforts to improve software qualities like performance or reliability as well as maintainability by using code refactoring techniques. Recently, as low-power software has become one of the critical issues in mobile environments, developing energyefficient software through code refactoring becomes an important one. This paper aims to investigate whether the existing refactoring techniques can support energy-efficient software generation or not. The refactored codes generated by the existing techniques can consume more power than original codes because they did not consider the power consumption in their refactoring processes. This paper analyzes the power consumption to investigate the energy efficiency of M. Fowler’s refactoring techniques. Our analysis result can provide useful information about energy-efficient refactoring techniques to software engineers, and support the development of software that has high maintainability and good energy efficiency.},
	language = {en},
	author = {Park, Jae-Jin and Hong, Jang-Eui and Lee, Sang-Ho},
	pages = {6},
	file = {Park et al. - Investigation for Software Power Consumption of Co.pdf:/Users/chakibbelgaid/Zotero newone/storage/5JJGP8HE/Park et al. - Investigation for Software Power Consumption of Co.pdf:application/pdf},
}

@misc{noauthor_python_2019,
	title = {Python {Developers} {Survey} 2018 {Results}},
	url = {https://www.jetbrains.com/research/python-developers-survey-2018/},
	abstract = {Results of the official Python Developers Survey 2018 by Python Software Foundation and JetBrains: more than 20k responses from more than 150 countries.},
	urldate = {2019-02-12},
	journal = {JetBrains},
	month = feb,
	year = {2019},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/6XPFMMLX/python-developers-survey-2018.html:text/html},
}

@misc{noauthor_python_2019-1,
	title = {Python {Developers} {Survey} 2018 {Results}},
	url = {https://www.jetbrains.com/research/python-developers-survey-2018/},
	abstract = {Results of the official Python Developers Survey 2018 by Python Software Foundation and JetBrains: more than 20k responses from more than 150 countries.},
	urldate = {2019-02-12},
	journal = {JetBrains},
	month = feb,
	year = {2019},
	annote = {things that i might use 
84\% of python used is python3 
    - python 2 maintenance will stoop in 2020 
    - python 2 is used for maintaining existing projects only 
31\% of projects are isolated in docker - 64\% using virtualenv
 
frameworks 
{\textbar} activity {\textbar} framework {\textbar} \% {\textbar} 
{\textbar}:-------{\textbar}---------:{\textbar}:--:
{\textbar} web    {\textbar}    Flask     {\textbar}    47\%{\textbar}
{\textbar}            {\textbar}    Django {\textbar} 45 \% {\textbar}
{\textbar}----------------------{\textbar}
{\textbar}data    {\textbar}    numpy{\textbar}  62\% {\textbar}
{\textbar}science {\textbar} Pandas {\textbar}51 \% {\textbar}
{\textbar}             {\textbar} matplotlib 46\%  {\textbar}
{\textbar}            {\textbar} scipy {\textbar} 38 {\textbar}
--------------------------
{\textbar}others {\textbar} request {\textbar} 53\% {\textbar}
{\textbar}..........{\textbar} Pillow{\textbar} 29\% {\textbar}
{\textbar}            {\textbar} Scrapy {\textbar} 19\% {\textbar}
 
-----------------------------------
usage in cloud 
40\% in containers 
69\%  is used in linux 
 },
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/VEIGT725/python-developers-survey-2018.html:text/html},
}

@misc{noauthor_python_2019-2,
	title = {Python {Developers} {Survey} 2017 - {Results}},
	url = {https://www.jetbrains.com/research/python-developers-survey-2017/},
	abstract = {At the very end of 2017, the Python Software Foundation together with JetBrains conducted an official Python Developers Survey. We set out to identify the latest trends and gather insight into how the Python development world looks today. Over 9,500 developers from almost 150 different countries participated to help us map out an accurate landscape of the Python community.},
	urldate = {2019-02-12},
	journal = {JetBrains},
	month = feb,
	year = {2019},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/U7BJUNP6/python-developers-survey-2017.html:text/html},
}

@misc{bradberry_how_2019,
	title = {How {Successful} {People} {Stay} {Calm}},
	url = {https://www.forbes.com/sites/travisbradberry/2014/02/06/how-successful-people-stay-calm/},
	abstract = {The ability to manage your emotions and remain calm under pressure has a direct link to your performance. TalentSmart has conducted research with more than a million people, and we’ve found that 90\% of top performers are skilled at managing their emotions in times of stress in order to remain [...]},
	language = {en},
	urldate = {2019-02-20},
	journal = {Forbes},
	author = {Bradberry, Travis},
	month = feb,
	year = {2019},
	annote = {havoc stress},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/NXRZ5ZQB/how-successful-people-stay-calm.html:text/html},
}

@misc{bradberry_emotional_2019,
	title = {Emotional {Intelligence} - {EQ}},
	url = {https://www.forbes.com/sites/travisbradberry/2014/01/09/emotional-intelligence/},
	abstract = {As the bestselling coauthor of Emotional Intelligence 2.0, I'm often asked to break down what emotional intelligence is and why it's so important. Here goes... Emotional Intelligence Is the Other Kind of Smart. When emotional intelligence first appeared to the masses in 1995, it served as the missing link in a peculiar [...]},
	language = {en},
	urldate = {2019-02-20},
	journal = {Forbes},
	author = {Bradberry, Travis},
	month = feb,
	year = {2019},
	annote = {havoc stress},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/AVDSZJE7/emotional-intelligence.html:text/html},
}

@article{callau_how_2013,
	title = {How (and why) developers use the dynamic features of programming languages: the case of smalltalk},
	volume = {18},
	issn = {1382-3256, 1573-7616},
	shorttitle = {How (and why) developers use the dynamic features of programming languages},
	url = {http://link.springer.com/10.1007/s10664-012-9203-2},
	doi = {10.1007/s10664-012-9203-2},
	abstract = {The dynamic and reflective features of programming languages are powerful constructs that programmers often mention as extremely useful. However, the ability to modify a program at runtime can be both a boon—in terms of flexibility—, and a curse—in terms of tool support. For instance, usage of these features hampers the design of type systems, the accuracy of static analysis techniques, or the introduction of optimizations by compilers. In this paper, we perform an empirical study of a large Smalltalk codebase—often regarded as the poster-child in terms of availability of these features—, in order to assess how much these features are actually used in practice, whether some are used more than others, and in which kinds of projects. In addition, we performed a qualitative analysis of a representative sample of usages of dynamic features in order to uncover (1) the principal reasons that drive people to use dynamic features, and (2) whether and how these dynamic feature usages can be removed or converted to safer usages. These results are useful to make informed decisions about which features to consider when designing language extensions or tool support.},
	language = {en},
	number = {6},
	urldate = {2019-03-08},
	journal = {Empirical Software Engineering},
	author = {Callaú, Oscar and Robbes, Romain and Tanter, Éric and Röthlisberger, David},
	month = dec,
	year = {2013},
	note = {Number: 6},
	pages = {1156--1194},
	file = {Callaú et al. - 2013 - How (and why) developers use the dynamic features .pdf:/Users/chakibbelgaid/Zotero newone/storage/APA6RJUF/Callaú et al. - 2013 - How (and why) developers use the dynamic features .pdf:application/pdf},
}

@inproceedings{diouri_your_2013,
	title = {Your cluster is not power homogeneous: {Take} care when designing green schedulers!},
	shorttitle = {Your cluster is not power homogeneous},
	doi = {10.1109/IGCC.2013.6604506},
	abstract = {Future supercomputers will consume enormous amounts of energy. These very large scale systems will gather many homogeneous clusters. In this paper, we analyze the power consumption of the nodes from different homogeneous clusters during different workloads. We classically observe that these nodes exhibit the same level of performance. But we also show that different nodes from a homogeneous cluster may exhibit heterogeneous idle power energy consumption even if they are made of identical hardware. Hence, we propose an experimental methodology to understand such differences. We show that CPUs are responsible for such heterogeneity which can reach 20\% in terms of energy consumption. So energy aware (Green) schedulers must take care of such hidden heterogeneity in order to propose efficient mapping of tasks. To consume less energy, we propose an energy-aware scheduling approach taking into account the heterogeneous idle power consumption of homogeneous nodes. It shows that we are able to save energy up to 17\% while exploiting the high power heterogeneity that may exist in some homogeneous clusters.},
	booktitle = {2013 {International} {Green} {Computing} {Conference} {Proceedings}},
	author = {Diouri, M. El Mehdi and Glück, O. and Lefèvre, L. and Mignot, J.},
	month = jun,
	year = {2013},
	keywords = {Benchmark testing, CPU, Dispersion, Energy consumption, energy-aware scheduling approach, green schedulers, Hardware, heterogeneous idle power energy consumption, homogeneous clusters, HPC applications, parallel machines, parallel processing, power consumption, Power demand, Power measurement, scheduling, supercomputers, very large scale systems, Wattmeters},
	pages = {1--10},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/IIAVF9ND/6604506.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/VTZU43NV/Diouri et al. - 2013 - Your cluster is not power homogeneous Take care w.pdf:application/pdf},
}

@article{hammouda_noise-tolerant_2015,
	title = {Noise-{Tolerant} {Explicit} {Stencil} {Computations} for {Nonuniform} {Process} {Execution} {Rates}},
	volume = {2},
	issn = {23294949},
	url = {http://dl.acm.org/citation.cfm?doid=2757213.2742351},
	doi = {10.1145/2742351},
	language = {en},
	number = {1},
	urldate = {2019-03-18},
	journal = {ACM Transactions on Parallel Computing},
	author = {Hammouda, Adam and Siegel, Andrew R. and Siegel, Stephen F.},
	month = apr,
	year = {2015},
	note = {Number: 1},
	pages = {1--33},
	file = {Hammouda et al. - 2015 - Noise-Tolerant Explicit Stencil Computations for N.pdf:/Users/chakibbelgaid/Zotero newone/storage/3Y6L2RSD/Hammouda et al. - 2015 - Noise-Tolerant Explicit Stencil Computations for N.pdf:application/pdf},
}

@article{bailey_nas_nodate,
	title = {The {NAS} {Parallel} {Benchmarks}},
	abstract = {A new set of benchmarks has been developed for the performance evaluation of highly parallel supercomputers. These benchmarks consist of ve parallel kernels and three simulated application benchmarks. Together they mimic the computation and data movement characteristics of large scale computational uid dynamics (CFD) applications.},
	language = {en},
	author = {Bailey, D and Barszcz, E and Barton, J and Browning, D and Carter, R and Dagum, L and Fineberg, S and Frederickson, P and Lasinski, T and Schreiber, R and Simon, H and Venkatakrishnan, V and Weeratunga, S},
	pages = {79},
	file = {Bailey et al. - The NAS Parallel Benchmarks.pdf:/Users/chakibbelgaid/Zotero newone/storage/HKRAEIFE/Bailey et al. - The NAS Parallel Benchmarks.pdf:application/pdf},
}

@article{oliveira_recommending_nodate,
	title = {Recommending {Energy}-{Efﬁcient} {Java} {Collections}},
	abstract = {Over the last years, increasing attention has been given to creating energy-efﬁcient software systems. However, developers still lack the knowledge and the tools to support them in that task. In this work, we explore our vision that energy consumption non-specialists can build software that consumes less energy by alternating, at development time, between thirdparty, readily available, diversely-designed pieces of software, without increasing the development complexity. To support our vision, we propose an approach for energy-aware development that combines the construction of application-independent energy proﬁles of Java collections and static analysis to produce an estimate of in which ways and how intensively a system employs these collections. By combining these two pieces of information, it is possible to produce energy-saving recommendations for alternative collection implementations to be used in different parts of the system. We implement this approach in a tool named CT+ that works with both desktop and mobile Java systems, and is capable of analyzing 40 different collection implementations of lists, maps, and sets. We applied CT+ to twelve software systems: two mobile-based, seven desktop-based, and three that can run in both environments. Our evaluation infrastructure involved a high-end server, a notebook, and three mobile devices. When applying the (mostly trivial) recommendations, we achieved up to 17.34\% reduction in energy consumption just by replacing collection implementations. Even for a real world, mature, highlyoptimized system such as Xalan, CT+ could achieve a 5.81\% reduction in energy consumption. Our results indicate that some widely used collections, e.g., ArrayList, HashMap, and HashTable, are not energy-efﬁcient and sometimes should be avoided when energy consumption is a major concern.},
	language = {en},
	author = {Oliveira, Wellington and Oliveira, Renato and Castor, Fernando and Fernandes, Benito and Pinto, Gustavo},
	pages = {11},
	annote = {Chapter 2:
Collections- Introducing the main study field
- categorizing them with the characteristics of each category },
	file = {Oliveira et al. - Recommending Energy-Efﬁcient Java Collections.pdf:/Users/chakibbelgaid/Zotero newone/storage/YMZ2D2UV/Oliveira et al. - Recommending Energy-Efﬁcient Java Collections.pdf:application/pdf},
}

@inproceedings{chowdhury_greenoracle_2016,
	address = {New York, NY, USA},
	series = {{MSR} '16},
	title = {{GreenOracle}: {Estimating} {Software} {Energy} {Consumption} with {Energy} {Measurement} {Corpora}},
	isbn = {978-1-4503-4186-8},
	shorttitle = {{GreenOracle}},
	url = {http://doi.acm.org/10.1145/2901739.2901763},
	doi = {10.1145/2901739.2901763},
	abstract = {Software energy consumption is a relatively new concern for mobile application developers. Poor energy performance can harm adoption and sales of applications. Unfortunately for the developers, the measurement of software energy consumption is expensive in terms of hardware and difficult in terms of expertise. Many prior models of software energy consumption assume that developers can use hardware instrumentation and thus cannot evaluate software running within emulators or virtual machines. Some prior models require actual energy measurements from the previous versions of applications in order to model the energy consumption of later versions of the same application. In this paper, we take a big-data approach to software energy consumption and present a model that can estimate software energy consumption mostly within 10\% error (in joules) and does not require the developer to train on energy measurements of their own applications. This model leverages a big-data approach whereby a collection of prior applications' energy measurements allows us to train, transmit, and apply the model to estimate any foreign application's energy consumption for a test run. Our model is based on the dynamic traces of system calls and CPU utilization.},
	urldate = {2019-04-01},
	booktitle = {Proceedings of the 13th {International} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Chowdhury, Shaiful Alam and Hindle, Abram},
	year = {2016},
	note = {event-place: Austin, Texas},
	pages = {49--60},
	file = {ACM Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/3ZPKNLPW/Chowdhury and Hindle - 2016 - GreenOracle Estimating Software Energy Consumptio.pdf:application/pdf},
}

@misc{noauthor_pdf_2019,
	title = {({PDF}) {The} {YouTube} video recommendation system},
	url = {https://www.researchgate.net/publication/221140967_The_YouTube_video_recommendation_system},
	abstract = {ResearchGate is a network dedicated to science and research. Connect, collaborate and discover scientific publications, jobs and conferences. All for free.},
	language = {en},
	urldate = {2019-05-15},
	journal = {ResearchGate},
	month = may,
	year = {2019},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/LXIQKC6J/221140967_The_YouTube_video_recommendation_system.html:text/html},
}

@article{wang_experimental_nodate,
	title = {Experimental {Characterization} of {Variation} in {Power} {Consumption} for {Processors} of {Different} generations},
	abstract = {Data centers are energy-hungry facilities. Building energy consumption predictive models for servers is one of the solutions to use efﬁciently the resources. However, physical experiments have shown that even under the same conditions, identical processors consume different amount of energy to complete the same task. While this manufacturing variability has been observed and studied before, there is lack of evidence supporting the hypotheses due to limited sampling data, especially from the thermal characteristics. In this article, we compare the power consumption among identical processors for two Intel processors series with the same TDP (Thermal Design Power) but from different generations. The observed power variation of the processors in newer generation is much greater than the older one. Then, we propose our hypotheses for the underlying causes and validate them under precisely controlled environmental conditions. The experimental results show that, with the increase of transistor densities, difference of thermal characteristics becomes larger among processors, which has non-negligible contribution to the variation of power consumption for modern processors. This observation reminds us of re-calibrating the precision of the current energy predictive models. The manufacturing variability has to be considered when building energy predictive models for homogeneous clusters.},
	language = {en},
	author = {Wang, Yewan and Nörtershäuser, David and Masson, Stéphane Le and Menaud, Jean-Marc},
	pages = {10},
	file = {Wang et al. - Experimental Characterization of Variation in Powe.pdf:/Users/chakibbelgaid/Zotero newone/storage/BAR7YZEN/Wang et al. - Experimental Characterization of Variation in Powe.pdf:application/pdf},
}

@book{urdan_statistics_2010,
	address = {Hoboken},
	title = {Statistics in {Plain} {English}, {Third} {Edition}.},
	isbn = {978-0-203-85117-3},
	url = {http://www.SLQ.eblib.com.au/patron/FullRecord.aspx?p=668346},
	abstract = {This inexpensive paperback provides a brief, simple overview of statistics to help readers gain a better understanding of how statistics work and how to interpret them correctly. Each chapter describes a different statistical technique, ranging from basic concepts like central tendency and describing distributions to more advanced concepts such as t tests, regression, repeated measures ANOVA, and factor analysis. Each chapter begins with a short description of the statistic and when it should be used. This is followed by a more in-depth explanation of how the statistic works. Finally, each cha.},
	language = {en},
	urldate = {2019-08-10},
	publisher = {Taylor \& Francis},
	author = {Urdan, Timothy C},
	year = {2010},
	note = {OCLC: 781311754},
	file = {Urdan - 2010 - Statistics in Plain English, Third Edition..pdf:/Users/chakibbelgaid/Zotero newone/storage/4JK3GBJV/Urdan - 2010 - Statistics in Plain English, Third Edition..pdf:application/pdf},
}

@misc{noauthor_notitle_nodate,
	file = {Mobile_2019_paper_1.pdf:/Users/chakibbelgaid/Zotero newone/storage/VLIXMXY7/_.pdf:application/pdf},
}

@article{van_der_kouwe_benchmarking_2018,
	title = {Benchmarking {Crimes}: {An} {Emerging} {Threat} in {Systems} {Security}},
	shorttitle = {Benchmarking {Crimes}},
	url = {http://arxiv.org/abs/1801.02381},
	abstract = {Properly benchmarking a system is a difficult and intricate task. Unfortunately, even a seemingly innocuous benchmarking mistake can compromise the guarantees provided by a given systems security defense and also put its reproducibility and comparability at risk. This threat is particularly insidious as it is generally not a result of malice and can easily go undetected by both authors and reviewers. Moreover, as modern defenses often trade off security for performance in an attempt to find an ideal design point in the performance-security space, the damage caused by benchmarking mistakes is increasingly worrisome. To analyze the magnitude of the phenomenon, we identify a set of 22 "benchmarking crimes" that threaten the validity of systems security evaluations and perform a survey of 50 defense papers published in top venues. To ensure the validity of our results, we perform the complete survey twice, with two independent readers. We find only a very small number of disagreements between readers, showing that our assessment of benchmarking crimes is highly reproducible. We show that benchmarking crimes are widespread even in papers published at tier-1 venues. We find that tier-1 papers commit an average of five benchmarking crimes and we find only a single paper in our sample that committed no benchmarking crimes. Moreover, we find that the scale of the problem is constant over time, suggesting that the community is not yet addressing it despite the problem being now more relevant than ever. This threatens the scientific process, which relies on reproducibility and comparability to ensure that published research advances the state of the art. We hope to raise awareness of these issues and provide recommendations to improve benchmarking quality and safeguard the scientific process in our community.},
	urldate = {2019-09-03},
	journal = {arXiv:1801.02381 [cs]},
	author = {van der Kouwe, Erik and Andriesse, Dennis and Bos, Herbert and Giuffrida, Cristiano and Heiser, Gernot},
	month = jan,
	year = {2018},
	note = {arXiv: 1801.02381},
	keywords = {Computer Science - Cryptography and Security},
	file = {arXiv\:1801.02381 PDF:/Users/chakibbelgaid/Zotero newone/storage/ZRL8MBQR/van der Kouwe et al. - 2018 - Benchmarking Crimes An Emerging Threat in Systems.pdf:application/pdf;arXiv.org Snapshot:/Users/chakibbelgaid/Zotero newone/storage/CUTIVI4J/1801.html:text/html},
}

@misc{noauthor_254_2019,
	title = {25.4. 2to3 - {Automated} {Python} 2 to 3 code translation — {Python} 2.7.16 documentation},
	url = {https://docs.python.org/2/library/2to3.html},
	urldate = {2019-09-03},
	month = sep,
	year = {2019},
	file = {25.4. 2to3 - Automated Python 2 to 3 code translation — Python 2.7.16 documentation:/Users/chakibbelgaid/Zotero newone/storage/E472Z84A/2to3.html:text/html},
}

@article{strubell_energy_2019,
	title = {Energy and {Policy} {Considerations} for {Deep} {Learning} in {NLP}},
	url = {http://arxiv.org/abs/1906.02243},
	abstract = {Recent progress in hardware and methodology for training neural networks has ushered in a new generation of large networks trained on abundant data. These models have obtained notable gains in accuracy across many NLP tasks. However, these accuracy improvements depend on the availability of exceptionally large computational resources that necessitate similarly substantial energy consumption. As a result these models are costly to train and develop, both financially, due to the cost of hardware and electricity or cloud compute time, and environmentally, due to the carbon footprint required to fuel modern tensor processing hardware. In this paper we bring this issue to the attention of NLP researchers by quantifying the approximate financial and environmental costs of training a variety of recently successful neural network models for NLP. Based on these findings, we propose actionable recommendations to reduce costs and improve equity in NLP research and practice.},
	urldate = {2019-09-04},
	journal = {arXiv:1906.02243 [cs]},
	author = {Strubell, Emma and Ganesh, Ananya and McCallum, Andrew},
	month = jun,
	year = {2019},
	note = {arXiv: 1906.02243},
	keywords = {Computer Science - Computation and Language},
	annote = {Comment: In the 57th Annual Meeting of the Association for Computational Linguistics (ACL). Florence, Italy. July 2019},
	file = {arXiv\:1906.02243 PDF:/Users/chakibbelgaid/Zotero newone/storage/GR5RNJDL/Strubell et al. - 2019 - Energy and Policy Considerations for Deep Learning.pdf:application/pdf;arXiv.org Snapshot:/Users/chakibbelgaid/Zotero newone/storage/UUHJBFTL/1906.html:text/html},
}

@inproceedings{imes_copper_2019,
	title = {{CoPPer}: {Soft} {Real}-{Time} {Application} {Performance} {Using} {Hardware} {Power} {Capping}},
	shorttitle = {{CoPPer}},
	doi = {10.1109/ICAC.2019.00015},
	abstract = {Dynamic voltage and frequency scaling (DVFS) has been the cornerstone of innumerable software approaches to meeting application timing requirements with minimal energy. However, recent trends in technology-e.g., moving voltage converters on chip-favor hardware control of DVFS, as hardware can both react faster to external events and perform fine-grained power management across a device. We respond to these trends with CoPPer, which instead uses hardware power capping to meet application performance requirements with high energy efficiency. We find that meeting performance requirements with power capping is more challenging than using DVFS because the relationship between power and performance is non-linear and has diminishing returns at high power values. CoPPer overcomes these difficulties by using adaptive control to approximate non-linearities and a novel gain limit to avoid over-allocating power when it is no longer beneficial. We evaluate CoPPer with 20 parallel applications and compare it to both a classic linear DVFS controller and to a sophisticated control-theoretic, model-driven software DVFS manager. CoPPer provides all the functionality of the sophisticated DVFS-based approach, without requiring a user-specified model or time-consuming, exhaustive application/system pre-characterization. Compared to DVFS, CoPPer's gain limit reduces energy by 6\% on average and by 12\% for memory-bound applications. For high performance requirements, the energy savings are even greater: 8\% on average and 18\% for memory-bound applications.},
	booktitle = {2019 {IEEE} {International} {Conference} on {Autonomic} {Computing} ({ICAC})},
	author = {Imes, C. and Zhang, H. and Zhao, K. and Hoffmann, H.},
	month = jun,
	year = {2019},
	keywords = {adaptive control, application timing requirements, chip-favor hardware control, Computational modeling, control theory, Copper, CoPPer, dvfs, dynamic voltage and frequency scaling, energy conservation, energy efficiency, fine-grained power management, Hardware, hardware power capping, linear DVFS controller, Market research, memory-bound applications, minimal energy, model-driven software DVFS manager, multiprocessing systems, parallel applications, performance, power aware computing, power cap, Power demand, rapl, self aware systems, soft real-time application performance, Software, sophisticated DVFS-based approach, Timing, voltage converters},
	pages = {31--41},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/RWZDWXG5/8831193.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/USUAKL49/Imes et al. - 2019 - CoPPer Soft Real-Time Application Performance Usi.pdf:application/pdf},
}

@article{khokhriakov_modern_2019,
	title = {Modern {Multicore} {CPUs} are not {Energy} {Proportional}: {Opportunity} for {Bi}-objective {Optimization} for {Performance} and {Energy}},
	shorttitle = {Modern {Multicore} {CPUs} are not {Energy} {Proportional}},
	url = {http://arxiv.org/abs/1910.06674},
	abstract = {Energy proportionality is the key design goal followed by architects of modern multicore CPUs. One of its implications is that optimization of an application for performance will also optimize it for energy. In this work, we show that energy proportionality does not hold true for multicore CPUs. This ﬁnding creates the opportunity for bi-objective optimization of applications for performance and energy. We propose and study the ﬁrst application-level method for bi-objective optimization of multithreaded data-parallel applications for performance and energy. The method uses two decision variables, the number of identical multithreaded kernels (threadgroups) executing the application and the number of threads in each threadgroup, so that a given workload is partitioned equally between the threadgroups. We experimentally demonstrate the efﬁciency of the method using four highly optimized multithreaded data-parallel applications, 2D fast Fourier transform based on FFTW and Intel MKL, and dense matrix-matrix multiplication using OpenBLAS and Intel MKL. Four modern multicore CPUs are used in the experiments. The experiments show that the optimization for performance alone results in the increase in dynamic energy consumption by up to 89\% and optimization for dynamic energy alone results in performance degradation by up to 49\%. By solving the bi-objective optimization problem, the method determines up to 11 globally Pareto-optimal solutions.},
	language = {en},
	urldate = {2019-10-21},
	journal = {arXiv:1910.06674 [cs, eess]},
	author = {Khokhriakov, Semyon and Manumachu, Ravi Reddy and Lastovetsky, Alexey},
	month = oct,
	year = {2019},
	note = {arXiv: 1910.06674},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Hardware Architecture, Computer Science - Performance, Electrical Engineering and Systems Science - Systems and Control},
	file = {Khokhriakov et al. - 2019 - Modern Multicore CPUs are not Energy Proportional.pdf:/Users/chakibbelgaid/Zotero newone/storage/CULEM9W9/Khokhriakov et al. - 2019 - Modern Multicore CPUs are not Energy Proportional.pdf:application/pdf},
}

@misc{noauthor_power_2019,
	title = {Power profiling overview},
	url = {https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Power_profiling_overview},
	abstract = {This article covers important background information about power profiling, with an emphasis on Intel processors used in desktop and laptop machines. It serves as a starting point for anybody doing power profiling for the first time.},
	language = {en},
	urldate = {2019-10-21},
	journal = {MDN Web Docs},
	month = oct,
	year = {2019},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/QH3RCPIB/Power_profiling_overview.html:text/html},
}

@article{khokhriakov_modern_2019-1,
	title = {Modern {Multicore} {CPUs} are not {Energy} {Proportional}: {Opportunity} for {Bi}-objective {Optimization} for {Performance} and {Energy}},
	shorttitle = {Modern {Multicore} {CPUs} are not {Energy} {Proportional}},
	url = {http://arxiv.org/abs/1910.06674},
	abstract = {Energy proportionality is the key design goal followed by architects of modern multicore CPUs. One of its implications is that optimization of an application for performance will also optimize it for energy. In this work, we show that energy proportionality does not hold true for multicore CPUs. This ﬁnding creates the opportunity for bi-objective optimization of applications for performance and energy. We propose and study the ﬁrst application-level method for bi-objective optimization of multithreaded data-parallel applications for performance and energy. The method uses two decision variables, the number of identical multithreaded kernels (threadgroups) executing the application and the number of threads in each threadgroup, so that a given workload is partitioned equally between the threadgroups. We experimentally demonstrate the efﬁciency of the method using four highly optimized multithreaded data-parallel applications, 2D fast Fourier transform based on FFTW and Intel MKL, and dense matrix-matrix multiplication using OpenBLAS and Intel MKL. Four modern multicore CPUs are used in the experiments. The experiments show that the optimization for performance alone results in the increase in dynamic energy consumption by up to 89\% and optimization for dynamic energy alone results in performance degradation by up to 49\%. By solving the bi-objective optimization problem, the method determines up to 11 globally Pareto-optimal solutions.},
	language = {en},
	urldate = {2019-10-29},
	journal = {arXiv:1910.06674 [cs, eess]},
	author = {Khokhriakov, Semyon and Manumachu, Ravi Reddy and Lastovetsky, Alexey},
	month = oct,
	year = {2019},
	note = {arXiv: 1910.06674},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Hardware Architecture, Computer Science - Performance, Electrical Engineering and Systems Science - Systems and Control},
	file = {Khokhriakov et al. - 2019 - Modern Multicore CPUs are not Energy Proportional.pdf:/Users/chakibbelgaid/Zotero newone/storage/FLEI5VKS/Khokhriakov et al. - 2019 - Modern Multicore CPUs are not Energy Proportional.pdf:application/pdf},
}

@inproceedings{crist_dask_2016,
	title = {Dask {Numba}: {Simple} libraries for optimizing scientific python code},
	shorttitle = {Dask {Numba}},
	doi = {10.1109/BigData.2016.7840867},
	abstract = {Python is a high level language that is used by scientists for numeric computations. However, the performance of the language can be a hindrance when scaling to larger data sets, requiring some operations to be rewritten in a lower level language. To address this problem, we propose two libraries to allow numeric Python code to be optimized incrementally, requiring minimal changes. Here we describe Numba, a compiler for a subset of the Python language, and Dask, a flexible parallel programming library.},
	booktitle = {2016 {IEEE} {International} {Conference} on {Big} {Data} ({Big} {Data})},
	author = {Crist, James},
	month = dec,
	year = {2016},
	keywords = {Arrays, Big data, Complexity theory, Conferences, Dask \& Numba, data handling, data sets, flexible parallel programming library, high level language, high level languages, Instruction sets, libraries, Libraries, numeric computations, parallel programming, scientific Python code, software libraries, Syntactics},
	pages = {2342--2343},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/3VWCBI37/7840867.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/WIX66XKX/Crist - 2016 - Dask Numba Simple libraries for optimizing scient.pdf:application/pdf},
}

@inproceedings{li_boosting_2016,
	title = {Boosting {Python} {Performance} on {Intel} {Processors}: {A} {Case} {Study} of {Optimizing} {Music} {Recognition}},
	shorttitle = {Boosting {Python} {Performance} on {Intel} {Processors}},
	doi = {10.1109/PyHPC.2016.011},
	abstract = {We present a case study of optimizing a Python-based music recognition application on Intel Haswell Xeon processor. With support from Numpy and Scipy, Python addresses the requirements of the music recognition problem with math library utilization and special structures for data access. However, a general optimized Python application cannot fully utilize the latest high performance multicore processors. In this study, we survey an existing open-source music recognition application, written in Python, to explore the effect of applying changes to the Scipy and Numpy libraries to achieve full processor resource occupancy and reduce code latency. Instead of comparing across many different architectures, we focus on Intel high performance processors that have multiple cores and vector registers, and we attempt to preserve both user-friendliness and code scalability so that the revised library functions can be ported to other platforms and require no additional code changes.},
	booktitle = {2016 6th {Workshop} on {Python} for {High}-{Performance} and {Scientific} {Computing} ({PyHPC})},
	author = {Li, Yuanzhe and Schwiebert, Loren},
	month = nov,
	year = {2016},
	keywords = {code latency reduction, full processor resource occupancy, Graphics processing units, high level languages, Instruction sets, Intel Haswell Xeon processor, Intel high performance processors, Libraries, math library utilization, Multithreading, music, Numpy libraries, open-source music recognition, parallel processing, public domain software, Python performance optimization, Python-based music recognition, Registers, roofline, Scipy libraries, software libraries, vector processing},
	pages = {52--58},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/E4WL55I8/7836844.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/9NGU625G/Li and Schwiebert - 2016 - Boosting Python Performance on Intel Processors A.pdf:application/pdf},
}

@inproceedings{ben_asher_effect_2009,
	address = {Haifa, Israel},
	title = {The effect of unrolling and inlining for {Python} bytecode optimizations},
	isbn = {978-1-60558-623-6},
	url = {http://portal.acm.org/citation.cfm?doid=1534530.1534550},
	doi = {10.1145/1534530.1534550},
	language = {en},
	urldate = {2019-11-14},
	booktitle = {Proceedings of {SYSTOR} 2009: {The} {Israeli} {Experimental} {Systems} {Conference} on - {SYSTOR} '09},
	publisher = {ACM Press},
	author = {Ben Asher, Yosi and Rotem, Nadav},
	year = {2009},
	pages = {1},
	file = {Ben Asher and Rotem - 2009 - The effect of unrolling and inlining for Python by.pdf:/Users/chakibbelgaid/Zotero newone/storage/W5SV2B9G/Ben Asher and Rotem - 2009 - The effect of unrolling and inlining for Python by.pdf:application/pdf},
}

@misc{noauthor_lazy_2019,
	title = {On lazy evaluation as a tool to optimize the efficiency of large scale numerical simulations in {Python} {\textbar} {Elsevier} {Enhanced} {Reader}},
	url = {https://reader.elsevier.com/reader/sd/pii/S1877050910002413?token=D3F5799C47E5D5C405BA38C3179A996555E4484B7419F259787A03358531943C2E444BCDA181515FCDC550D54F6C77B5},
	language = {en},
	urldate = {2019-11-14},
	month = nov,
	year = {2019},
	doi = {10.1016/j.procs.2010.04.240},
	file = {Full Text:/Users/chakibbelgaid/Zotero newone/storage/G4XT5I2V/On lazy evaluation as a tool to optimize the effic.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/SC285JYH/S1877050910002413.html:text/html},
}

@inproceedings{zaman_extracting_2018,
	address = {Montpellier, France},
	title = {Extracting implicit programming rules: comparing static and dynamic approaches},
	isbn = {978-1-4503-5975-7},
	shorttitle = {Extracting implicit programming rules},
	url = {http://dl.acm.org/citation.cfm?doid=3242887.3242889},
	doi = {10.1145/3242887.3242889},
	abstract = {Programs often follow implicit programming rules, such as, function call A must be followed by function call B. Rules of such kinds are rarely documented by developers. Nevertheless, programming rules play an important role in software testing and maintenance. For example, the rules can be used as test oracles to detect violations. If a programmer can be notified of these rules before updating the source code, the chances of generating defects due to rule violations might be minimized. Prior works have used static and dynamic analysis techniques to extract implicit programming rules, but none compares the effectiveness of the two techniques. In this paper, we have undertaken an empirical study to compare the two techniques when they are being used for extracting programming rules. Our results indicate that the performance of the dynamic analysis technique depends on the number and the diversity of the traces. Moreover, the dynamic analysis technique generates more precise rules than the static analysis technique if a diverse and sufficient number of test cases are provided.},
	language = {en},
	urldate = {2020-01-06},
	booktitle = {Proceedings of the 7th {International} {Workshop} on {Software} {Mining} - {SoftwareMining} 2018},
	publisher = {ACM Press},
	author = {Zaman, Tarannum Shaila and Yu, Tingting},
	year = {2018},
	pages = {1--7},
	file = {Zaman and Yu - 2018 - Extracting implicit programming rules comparing s.pdf:/Users/chakibbelgaid/Zotero newone/storage/YDKVVTZJ/Zaman and Yu - 2018 - Extracting implicit programming rules comparing s.pdf:application/pdf},
}

@inproceedings{correia_detecting_2019,
	address = {Salvador, Brazil},
	title = {Detecting {Design} {Violations} in {Django}-based {Web} {Applications}},
	isbn = {978-1-4503-7637-2},
	url = {http://dl.acm.org/citation.cfm?doid=3357141.3357600},
	doi = {10.1145/3357141.3357600},
	abstract = {If on one hand frameworks allow programmers to reuse well-known architectural solutions, on the other hand they can make programmers unaware of important design decisions that should be followed during software construction, maintenance and evolution. And if programmers are unaware of these design decisions, there is a high risk of introducing design violations in the source code, and the accumulation of these violations might hinder software maintainability and evolvability. The use of static analysis tools might be employed to mitigate these problems by assisting the detection of recurring design violations in a given architectural pattern. In this work, we present MTV-Checker, a tool to assist the automatic detection of 5 design violations in Django-based web applications. We also conducted an empirical study in the context of the SUAP system, a large-scale Django-based information system with more than 175.000 lines of Python code currently deployed in more than 30 Brazilian institutions. Our results present the most recurrent violations, how they evolve along software evolution, and the opinions and experiences of software architects regarding these violations.},
	language = {en},
	urldate = {2020-01-06},
	booktitle = {Proceedings of the {XIII} {Brazilian} {Symposium} on {Software} {Components}, {Architectures}, and {Reuse}  - {SBCARS} '19},
	publisher = {ACM Press},
	author = {Correia, Renieri and Adachi, Eiji},
	year = {2019},
	pages = {33--42},
	file = {Correia and Adachi - 2019 - Detecting Design Violations in Django-based Web Ap.pdf:/Users/chakibbelgaid/Zotero newone/storage/EF5V57DS/Correia and Adachi - 2019 - Detecting Design Violations in Django-based Web Ap.pdf:application/pdf},
}

@inproceedings{he_statistics-based_2019,
	address = {Tallinn, Estonia},
	title = {A statistics-based performance testing methodology for cloud applications},
	isbn = {978-1-4503-5572-8},
	url = {http://dl.acm.org/citation.cfm?doid=3338906.3338912},
	doi = {10.1145/3338906.3338912},
	abstract = {The low cost of resource ownership and flexibility have led users to increasingly port their applications to the clouds. To fully realize the cost benefits of cloud services, users usually need to reliably know the execution performance of their applications. However, due to the random performance fluctuations experienced by cloud applications, the black box nature of public clouds and the cloud usage costs, testing on clouds to acquire accurate performance results is extremely difficult. In this paper, we present a novel cloud performance testing methodology called PT4Cloud. By employing non-parametric statistical approaches of likelihood theory and the bootstrap method, PT4Cloud provides reliable stop conditions to obtain highly accurate performance distributions with confidence bands. These statistical approaches also allow users to specify intuitive accuracy goals and easily trade between accuracy and testing cost. We evaluated PT4Cloud with 33 benchmark configurations on Amazon Web Service and Chameleon clouds. When compared with performance data obtained from extensive performance tests, PT4Cloud provides testing results with 95.4\% accuracy on average while reducing the number of test runs by 62\%. We also propose two test execution reduction techniques for PT4Cloud, which can reduce the number of test runs by 90.1\% while retaining an average accuracy of 91\%. We compared our technique to three other techniques and found that our results are much more accurate.},
	language = {en},
	urldate = {2020-01-06},
	booktitle = {Proceedings of the 2019 27th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}  - {ESEC}/{FSE} 2019},
	publisher = {ACM Press},
	author = {He, Sen and Manns, Glenna and Saunders, John and Wang, Wei and Pollock, Lori and Soffa, Mary Lou},
	year = {2019},
	pages = {188--199},
	file = {He et al. - 2019 - A statistics-based performance testing methodology.pdf:/Users/chakibbelgaid/Zotero newone/storage/CFIR8SXF/He et al. - 2019 - A statistics-based performance testing methodology.pdf:application/pdf},
}

@inproceedings{kitaura_random_2018,
	address = {Lake Buena Vista, FL, USA},
	title = {Random testing of compilers’ performance based on mixed static and dynamic code comparison},
	isbn = {978-1-4503-6053-1},
	url = {http://dl.acm.org/citation.cfm?doid=3278186.3278192},
	doi = {10.1145/3278186.3278192},
	abstract = {This paper proposes an automated test method for detecting performance bugs in compilers. It is based on di erential random testing, in which randomly generated programs are compiled by two di erent compilers and resulting pairs of assembly codes are compared. Our method attempts to achieve e cient and accurate detection of performance di erence, by combining dynamic measurement of execution time with static assembly-level comparison and test program minimization. In the rst step, discrepant pairs of code sections in the assembly codes are extracted, and then the sums of the weights of discrepant instructions in the sections are computed. If signi cant di erences are detected, the test program is reduced to a small program that still exhibits the static di erence and then the actual execution time of the codes are compared. A test system has been implemented on top of the random test system Orange4, which has successfully detected a regression in the optimizer of a development version of GCC-8.0.0 (latest as of May, 2017).},
	language = {en},
	urldate = {2020-01-06},
	booktitle = {Proceedings of the 9th {ACM} {SIGSOFT} {International} {Workshop} on {Automating} {TEST} {Case} {Design}, {Selection}, and {Evaluation} - {A}-{TEST} 2018},
	publisher = {ACM Press},
	author = {Kitaura, Kota and Ishiura, Nagisa},
	year = {2018},
	pages = {38--44},
	file = {Kitaura and Ishiura - 2018 - Random testing of compilers’ performance based on .pdf:/Users/chakibbelgaid/Zotero newone/storage/2SG8QRC6/Kitaura and Ishiura - 2018 - Random testing of compilers’ performance based on .pdf:application/pdf},
}

@article{procaccianti_energy_nodate,
	title = {Energy {Efﬁciency} of {ORM} {Approaches}: an {Empirical} {Evaluation}},
	abstract = {Method. We performed an empirical experiment in a controlled environment. We selected three factors for our experimentation: the diﬀerent ORM approaches, the type of query (Create, Read, Update, Delete) and the size of database tables. Our response variables were execution time and energy consumption.
Results. As expected, pure SQL yielded the best performance and energy eﬃciency in all test cases. Propel exhibited a much higher energy consumption and longer execution times. The TinyQueries tool performed slightly worse than SQL, but signiﬁcantly better than Propel, oﬀering a convenient trade–oﬀ between ORM beneﬁts and energy eﬃciency.
Conclusions. Our experiment shows that ORM approaches have a signiﬁcant impact on both energy consumption and performance. This helps developers and architects when considering the trade-oﬀ between their beneﬁts (e.g. in terms of code maintainability and readability) and drawbacks.},
	language = {en},
	author = {Procaccianti, Giuseppe and Lago, Patricia and Diesveld, Wouter},
	pages = {10},
	file = {Procaccianti et al. - Energy Efﬁciency of ORM Approaches an Empirical E.pdf:/Users/chakibbelgaid/Zotero newone/storage/Z3QWFHJF/Procaccianti et al. - Energy Efﬁciency of ORM Approaches an Empirical E.pdf:application/pdf},
}

@inproceedings{cardenas_performance_2005,
	title = {Performance comparison of a {Web} cache simulation framework},
	volume = {2},
	doi = {10.1109/AINA.2005.275},
	abstract = {Performance comparison studies are primarily carried out through real systems or simulation environments. Simulation is the most commonly used method to explore new proposals due to both its flexibility and the relatively reduced time taken to obtain performance results. This paper presents a powerful framework to simulate Web proxy cache systems. Our tool provides a comfortable environment to simulate and explore cache management techniques. In order to validate our framework and show how accurate it executes, a performance comparison has been done. We analyzed the details of a commercial proxy cache system and compare its results with those obtained from our simulator using the most commonly replacement algorithm (LRU). For this purpose, the proposed environment was adapted to match the performance of the real proxy cache. Experimental results show that proxy cache hit ratio deviations fall very close to the real system, since then, never exceeds 3.42\%.},
	booktitle = {19th {International} {Conference} on {Advanced} {Information} {Networking} and {Applications} ({AINA}'05) {Volume} 1 ({AINA} papers)},
	author = {Cardenas, L. G. and Gil, J. A. and Domenech, J. and Sahuquillo, J. and Pont, A.},
	month = mar,
	year = {2005},
	note = {ISSN: 2332-5658},
	keywords = {Algorithm design and analysis, Analytical models, cache management, cache storage, Computational modeling, Computer simulation, Content management, Delay, digital simulation, Environmental management, Internet, LRU, Navigation, performance comparison, Proposals, Proxy web cache, real system, replacement algorithm, simulation environment, simulation techniques, validation, Web cache simulation, Web proxy cache system, Web server},
	pages = {281--284 vol.2},
	file = {IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/T2B2K5EQ/Cardenas et al. - 2005 - Performance comparison of a Web cache simulation f.pdf:application/pdf},
}

@article{sokol_performance-benchmark_nodate,
	title = {Ein {Performance}-{Benchmark} für {Java}-{Web}-{Frameworks} {Diplomarbeit}},
	language = {de},
	author = {Sokol, Christophe},
	pages = {24},
	file = {Sokol - Ein Performance-Benchmark für Java-Web-Frameworks .pdf:/Users/chakibbelgaid/Zotero newone/storage/Q3BVMA4F/Sokol - Ein Performance-Benchmark für Java-Web-Frameworks .pdf:application/pdf},
}

@misc{das_comparison_2016,
	title = {Comparison of {Procedural} {PHP} with {Codeigniter} and {Laravel} {Framework}},
	url = {/paper/A-new-model-for-the-selection-of-web-development-to-Benmoussa-Laaziri/6eb6977a37b2d38e232472b43897ab6047bd751c},
	abstract = {The use of a framework is often essential for medium and large scale developments, but is also of interest for small developments. PHP has evolved as the scripting language the most chosen by developers, which has generated an explosion of PHP frameworks. There is a big debate about what the best PHP frameworks are, because the simple fact is that not all frameworks are built for everyone. Indeed, not all frameworks meet the same needs, and several frameworks can be used together in certain situations. Choosing the right framework, however, can sometimes be difficult. In order to make the selection process easier, we propose a pragmatic and complete model to compare and evaluate the main PHP frameworks. This model is based on a set of comparison criteria based on the Intrinsic durability, industrialized solution, technical adaptability, strategy, technical architecture and Speed criteria. Results show that the values of these criteria allow developers to easily and properly choose the framwork that best meets their needs},
	language = {en},
	urldate = {2020-10-27},
	author = {Das, R. and Saikia, Dr Lakshmi Prasad},
	year = {2016},
}

@article{benmoussa_new_2019,
	title = {A new model for the selection of web development frameworks: application to {PHP} frameworks},
	volume = {9},
	copyright = {Copyright (c) 2019 Institute of Advanced Engineering and Science},
	issn = {2722-2578},
	shorttitle = {A new model for the selection of web development frameworks},
	url = {http://ijece.iaescore.com/index.php/IJECE/article/view/11586},
	doi = {10.11591/ijece.v9i1.pp695-703},
	abstract = {The use of a framework is often essential for medium and large scale developments, but is also of interest for small developments. PHP has evolved as the scripting language the most chosen by developers, which has generated an explosion of PHP frameworks. There is a big debate about what the best PHP frameworks are, because the simple fact is that not all frameworks are built for everyone. Indeed, not all frameworks meet the same needs, and several frameworks can be used together in certain situations. Choosing the right framework, however, can sometimes be difficult. In order to make the selection process easier, we propose a pragmatic and complete model to compare and evaluate the main PHP frameworks. This model is based on a set of comparison criteria based on the Intrinsic durability, industrialized solution, technical adaptability, strategy, technical architecture and Speed criteria. Results show that the values of these criteria allow developers to easily and properly choose the framwork that best meets their needs},
	language = {en},
	number = {1},
	urldate = {2020-10-27},
	journal = {International Journal of Electrical and Computer Engineering (IJECE)},
	author = {Benmoussa, Khaoula and Laaziri, Majida and Khoulji, Samira and Larbi, Kerkeb Mohamed and Yamami, Abir El},
	month = feb,
	year = {2019},
	note = {Number: 1},
	keywords = {codeIgniter, laravel, PHP frameworks, PHP frameworks evaluation, symphony, zend},
	pages = {695--703},
	file = {Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/CWLAD2Y8/Benmoussa et al. - 2019 - A new model for the selection of web development f.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/S9JKHQM8/11586.html:text/html},
}

@article{pankiv_concurrent_nodate,
	title = {Concurrent benchmark system for web-frameworks on {Python}},
	abstract = {The frameworks have come a long way, and each new developer is faced not only with learning the language but also with the choice of the ﬁrst framework for himself. The current choice is the result of incredible innovations in a relatively short period. As recently as 2004, Google released Gmail, which is considered the ﬁrst product to be an all-in-browser; Today, such products are called one-page applications. Have you ever tried to create a front-end web interface using only HTML, CSS, and JavaScript? Well, nowadays it’s not so hard. If the requirements are not too complicated, a small project can be completed relatively quickly. As for medium and large projects, to cope with the complexity of user requirements, you will need at least one framework.},
	language = {en},
	author = {Pankiv, Andriy},
	pages = {26},
	file = {Pankiv - Concurrent benchmark system for web-frameworks on .pdf:/Users/chakibbelgaid/Zotero newone/storage/VXFIFW3Z/Pankiv - Concurrent benchmark system for web-frameworks on .pdf:application/pdf},
}

@inproceedings{manotas_investigating_2013,
	title = {Investigating the impacts of web servers on web application energy usage},
	doi = {10.1109/GREENS.2013.6606417},
	abstract = {Software engineers make decisions about the design of the software they are creating on a daily basis. These decisions may impact the application in terms of efficiency, usability, flexibility, etc. Different competing design decisions are therefore often evaluated in terms of their projected impact on quality metrics prior to implementation. Recently energy has become a concern for software systems, ranging from mobile devices to large data centers. Additionally, it has been recognized that the software executing on a computing device can have a significant impact on the device's energy consumption. This raises the obvious question of whether or not it is possible to reduce the energy consumption of a software system by the means of software design decisions. This work examines how the use of different servers impacts the energy consumption of a web application. Through a controlled empirical experiment we have discovered several important findings in this regard. The results indicate that the energy consumption of a web application can vary greatly depending on the web server used to handle its requests. Furthermore, different web servers are more or less energy efficient depending on which web application features are being executed. The paper details an analysis of the results of the experiment.},
	booktitle = {2013 2nd {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	author = {Manotas, I. and Sahin, C. and Clause, J. and Pollock, L. and Winbladh, K.},
	month = may,
	year = {2013},
	keywords = {Browsers, Calendars, computing device, Context, data centers, device energy consumption, empirical studies, energy consumption, Energy consumption, energy consumption reduction, Energy usage, file servers, Internet, mobile devices, power aware computing, quality metrics, request handling, software design decision, software engineering, software systems, Web application energy usage, Web applications, Web servers},
	pages = {16--23},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/CNQSTLUX/6606417.html:text/html},
}

@inproceedings{manotas_investigating_2013-1,
	title = {Investigating the impacts of web servers on web application energy usage},
	doi = {10.1109/GREENS.2013.6606417},
	abstract = {Software engineers make decisions about the design of the software they are creating on a daily basis. These decisions may impact the application in terms of efficiency, usability, flexibility, etc. Different competing design decisions are therefore often evaluated in terms of their projected impact on quality metrics prior to implementation. Recently energy has become a concern for software systems, ranging from mobile devices to large data centers. Additionally, it has been recognized that the software executing on a computing device can have a significant impact on the device's energy consumption. This raises the obvious question of whether or not it is possible to reduce the energy consumption of a software system by the means of software design decisions. This work examines how the use of different servers impacts the energy consumption of a web application. Through a controlled empirical experiment we have discovered several important findings in this regard. The results indicate that the energy consumption of a web application can vary greatly depending on the web server used to handle its requests. Furthermore, different web servers are more or less energy efficient depending on which web application features are being executed. The paper details an analysis of the results of the experiment.},
	booktitle = {2013 2nd {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	author = {Manotas, I. and Sahin, C. and Clause, J. and Pollock, L. and Winbladh, K.},
	month = may,
	year = {2013},
	keywords = {Browsers, Calendars, computing device, Context, data centers, device energy consumption, empirical studies, energy consumption, Energy consumption, energy consumption reduction, Energy usage, file servers, Internet, mobile devices, power aware computing, quality metrics, request handling, software design decision, software engineering, software systems, Web application energy usage, Web applications, Web servers},
	pages = {16--23},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/NEVN5G7Q/6606417.html:text/html},
}

@inproceedings{manotas_investigating_2013-2,
	title = {Investigating the impacts of web servers on web application energy usage},
	doi = {10.1109/GREENS.2013.6606417},
	abstract = {Software engineers make decisions about the design of the software they are creating on a daily basis. These decisions may impact the application in terms of efficiency, usability, flexibility, etc. Different competing design decisions are therefore often evaluated in terms of their projected impact on quality metrics prior to implementation. Recently energy has become a concern for software systems, ranging from mobile devices to large data centers. Additionally, it has been recognized that the software executing on a computing device can have a significant impact on the device's energy consumption. This raises the obvious question of whether or not it is possible to reduce the energy consumption of a software system by the means of software design decisions. This work examines how the use of different servers impacts the energy consumption of a web application. Through a controlled empirical experiment we have discovered several important findings in this regard. The results indicate that the energy consumption of a web application can vary greatly depending on the web server used to handle its requests. Furthermore, different web servers are more or less energy efficient depending on which web application features are being executed. The paper details an analysis of the results of the experiment.},
	booktitle = {2013 2nd {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	author = {Manotas, I. and Sahin, C. and Clause, J. and Pollock, L. and Winbladh, K.},
	month = may,
	year = {2013},
	keywords = {Browsers, Calendars, computing device, Context, data centers, device energy consumption, empirical studies, energy consumption, Energy consumption, energy consumption reduction, Energy usage, file servers, Internet, mobile devices, power aware computing, quality metrics, request handling, software design decision, software engineering, software systems, Web application energy usage, Web applications, Web servers},
	pages = {16--23},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/L22VXPSM/6606417.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/MQ98KSJM/Manotas et al. - 2013 - Investigating the impacts of web servers on web ap.pdf:application/pdf},
}

@inproceedings{philippot_characterization_2014,
	title = {Characterization of the energy consumption of websites: {Impact} of website implementation on resource consumption},
	isbn = {978-94-6252-022-6},
	shorttitle = {Characterization of the energy consumption of websites},
	url = {https://www.atlantis-press.com/proceedings/ict4s-14/13439},
	doi = {10.2991/ict4s-14.2014.21},
	abstract = {This document presents the Web Energy Archive (WEA) project led by the Green Code Lab. This tools aims at measuring the computer resource consumption (energy, memory…) of the loading of a website in a browser. Firstly, considering the measure of 500 websites, website behavior can be characterized in terms of environmental impact. In a second step, best...},
	language = {en},
	urldate = {2020-10-28},
	publisher = {Atlantis Press},
	author = {Philippot, Olivier and Anglade, Alain and Leboucq, Thierry},
	month = aug,
	year = {2014},
	note = {ISSN: 2352-538X},
	pages = {171--178},
	file = {Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/2FKJJ42Z/Philippot et al. - 2014 - Characterization of the energy consumption of webs.pdf:application/pdf;Snapshot:/Users/chakibbelgaid/Zotero newone/storage/MSRQCJ37/13439.html:text/html},
}

@misc{modzelewski_pyston_2020,
	title = {Pyston v2: 20\% faster {Python}},
	shorttitle = {Pyston v2},
	url = {https://blog.pyston.org/2020/10/28/pyston-v2-20-faster-python/},
	abstract = {We’re very excited to release Pyston v2, a faster and highly compatible implementation of the Python programming language. Version 2 is 20\% faster than stock Python 3.8 on our macrobenchmarks…},
	language = {en},
	urldate = {2020-10-30},
	journal = {The Pyston Blog},
	author = {Modzelewski, Kevin},
	month = oct,
	year = {2020},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/PMUNDEK3/pyston-v2-20-faster-python.html:text/html},
}

@misc{noauthor_which_2020,
	title = {Which programming language is fastest? {\textbar} {Computer} {Language} {Benchmarks} {Game}},
	url = {https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html},
	urldate = {2020-11-03},
	month = nov,
	year = {2020},
	file = {Which programming language is fastest? | Computer Language Benchmarks Game:/Users/chakibbelgaid/Zotero newone/storage/Z8XT9DP2/index.html:text/html},
}

@article{harinadha_efficacious_2019,
	title = {An {Efficacious} {Query} {Processing} {Approach} with {Predictive} {Energy} {Saving} using {Online} {Scheduling}},
	volume = {9},
	abstract = {Web search engines are composed by thousands of query processing nodes, i.e., servers dedicated to process user queries. Such many servers consume a significant amount of energy, mostly accountable to their CPUs, but they are necessary to ensure low latencies, since users expect sub-second response times (e.g., 500 ms). However, users can hardly notice response times that are faster than their expectations. Hence, we propose the Predictive Energy Saving Online Scheduling Algorithm (PESOS) to select the most appropriate CPU frequency to process a query on a per-core basis. PESOS aim at process queries by their deadlines and leverage high-level scheduling information to reduce the CPU energy consumption of a query processing node. PESOS base its decision on query efficiency predictors, estimating the processing volume and processing time of a query. We experimentally evaluate PESOS upon the TREC ClueWeb09B collection and the MSN2006 query log. Results show that PESOS can reduce the CPU energy consumption of a query processing node up to ∼48\% compared to a system running at maximum CPU core frequency. PESOS outperform also the best state of the-art competitor with a ∼20\% energy saving, while the competitor requires a fine parameter tuning and it may incur in uncontrollable latency violations.},
	language = {en},
	number = {3},
	author = {Harinadha, Maragani and Shekhar, Chinthala},
	year = {2019},
	note = {Number: 3},
	pages = {7},
	file = {Harinadha and Shekhar - 2019 - An Efficacious Query Processing Approach with Pred.pdf:/Users/chakibbelgaid/Zotero newone/storage/4Q7JVA95/Harinadha and Shekhar - 2019 - An Efficacious Query Processing Approach with Pred.pdf:application/pdf},
}

@article{zhang_extending_2020,
	title = {Extending {Performance}-{Energy} {Trade}-offs via {Dynamic} {Core} {Scaling}},
	issn = {1557-9956},
	doi = {10.1109/TC.2020.3029306},
	abstract = {As transistor scaling is reaching its limit, the viable supply voltage range where DVFS can operate is shrinking, which limits its effectiveness. To extend the performance-energy trade-off capabilities in modern processors, this paper proposes dynamic core scaling (DCS) that does not rely on voltage scaling. DCS dynamically adjusts the active superscalar datapath resources so that programs run at a given percentage of their maximum speed while minimizing energy consumption at the same time. Since DCS does not need voltage scaling, it can be combined with DVFS to achieve greater energy savings. To effectively manage performance-energy trade-offs using a combination of DCS and DVFS, this paper proposes an oracle controller that demonstrates the optimal control strategy, and two practical controllers that are applicable in real implementations. Evaluations using an 8-way superscalar processor implemented in 45nm circuit show that DCS is more effective in performance-energy trade-offs than DVFS at the high performance end for a number of SPEC CPU2000 benchmarks. When used together with DVFS, DCS saves an additional 20\% of a full-size core's energy on average. At the minimum operating voltage, DVFS hits its limit, while DCS is still able to achieve an average of 46\% further energy reduction.},
	journal = {IEEE Transactions on Computers},
	author = {Zhang, W. and Zhang, H. and Lach, J.},
	year = {2020},
	note = {Conference Name: IEEE Transactions on Computers},
	keywords = {Calibration, Energy consumption, Hardware, Pipelines, Program processors, Registers, Runtime},
	pages = {1--1},
}

@inproceedings{lancor_analyzing_2013,
	address = {New York, NY, USA},
	series = {{SIGCSE} '13},
	title = {Analyzing {PHP} frameworks for use in a project-based software engineering course},
	isbn = {978-1-4503-1868-6},
	url = {https://doi.org/10.1145/2445196.2445350},
	doi = {10.1145/2445196.2445350},
	abstract = {Given the popularity of PHP frameworks used in developing web-based applications, a comparative study is conducted to determine which framework is best suited for incorporation into the curriculum of an undergraduate software engineering course that uses project-based learning. The top six PHP frameworks (Zend, Yii, CakePHP, CodeIgniter, PRADO, and Symphony) were initially considered and then narrowed down to two (CakePHP and CodeIgniter) based on their alignment with common functionality in previous class projects, framework complexity for those new to frameworks (learning curve), and developer friendliness (availability of documentation and online resources). An in-depth comparative study is conducted by developing a functionally-equivalent web application using each of the two frameworks as well as plain PHP (no framework). This work was motivated by the difficulties that were encountered in an evolving, content-rich software engineering course and discusses the educational changes that were made to align student learning with sound software engineering principles and current software development practices used in the computing industry.},
	urldate = {2020-11-09},
	booktitle = {Proceeding of the 44th {ACM} technical symposium on {Computer} science education},
	publisher = {Association for Computing Machinery},
	author = {Lancor, Lisa and Katha, Samyukta},
	month = mar,
	year = {2013},
	keywords = {PHP frameworks, project-based learning, software design and development, software engineering},
	pages = {519--524},
}

@inproceedings{gajewski_analysis_2019,
	title = {Analysis and {Comparison} of the {Spring} {Framework} and {Play} {Framework} {Performance}, {Used} to {Create} {Web} {Applications} in {Java}},
	doi = {10.1109/MEMSTECH.2019.8817390},
	abstract = {In the era of continuous technological development, which is followed by the increase in the speed of computers and the Internet, it is also important to develop techniques and programming languages as well as various mechanisms helping programmers in their work. Therefore, the frameworks were created, or skeleton applications that define the application structure and the general mechanism of its operation, to facilitate writing programs and unify the structure of various applications. The purpose of this article is to analyze and compare the performance of two popular frameworks, used to create a server part of a web application in Java, namely the Spring Framework and Play Framework.},
	booktitle = {2019 {IEEE} {XVth} {International} {Conference} on the {Perspective} {Technologies} and {Methods} in {MEMS} {Design} ({MEMSTECH})},
	author = {Gajewski, M. and Zabierowski, W.},
	month = may,
	year = {2019},
	note = {ISSN: 2573-5373},
	keywords = {application structure, Internet, Java, Jmeter, load tests, play framework performance, programming languages, skeleton applications, Spring Boot Play Framework, spring framework, Spring Framework, Web applications},
	pages = {170--173},
	file = {IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/KUW657FS/8817390.html:text/html;IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/9JCUG4DB/Gajewski and Zabierowski - 2019 - Analysis and Comparison of the Spring Framework an.pdf:application/pdf},
}

@inproceedings{grambow_benchmarking_2020,
	address = {Brno Czech Republic},
	title = {Benchmarking microservice performance: a pattern-based approach},
	isbn = {978-1-4503-6866-7},
	shorttitle = {Benchmarking microservice performance},
	url = {https://dl.acm.org/doi/10.1145/3341105.3373875},
	doi = {10.1145/3341105.3373875},
	abstract = {Benchmarking microservices serves to understand and check their non-functional properties for relevant workloads and over time. Performing benchmarks, however, can be costly: each microservice requires the design and implementation of a benchmark, possibly repeatedly as the service evolves. As microservice APIs differ, benchmarking tools that assume common interfaces – like ones for databases – do not exist.},
	language = {en},
	urldate = {2020-11-09},
	booktitle = {Proceedings of the 35th {Annual} {ACM} {Symposium} on {Applied} {Computing}},
	publisher = {ACM},
	author = {Grambow, Martin and Meusel, Lukas and Wittern, Erik and Bermbach, David},
	month = mar,
	year = {2020},
	pages = {232--241},
	file = {Grambow et al. - 2020 - Benchmarking microservice performance a pattern-b.pdf:/Users/chakibbelgaid/Zotero newone/storage/SFKTCPQ8/Grambow et al. - 2020 - Benchmarking microservice performance a pattern-b.pdf:application/pdf},
}

@inproceedings{arcuri_practical_2011,
	address = {Waikiki, Honolulu, HI, USA},
	title = {A practical guide for using statistical tests to assess randomized algorithms in software engineering},
	isbn = {978-1-4503-0445-0},
	url = {http://portal.acm.org/citation.cfm?doid=1985793.1985795},
	doi = {10.1145/1985793.1985795},
	abstract = {Randomized algorithms have been used to successfully address many different types of software engineering problems. This type of algorithms employ a degree of randomness as part of their logic. Randomized algorithms are useful for difﬁcult problems where a precise solution cannot be derived in a deterministic way within reasonable time. However, randomized algorithms produce different results on every run when applied to the same problem instance. It is hence important to assess the effectiveness of randomized algorithms by collecting data from a large enough number of runs. The use of rigorous statistical tests is then essential to provide support to the conclusions derived by analyzing such data. In this paper, we provide a systematic review of the use of randomized algorithms in selected software engineering venues in 2009. Its goal is not to perform a complete survey but to get a representative snapshot of current practice in software engineering research. We show that randomized algorithms are used in a signiﬁcant percentage of papers but that, in most cases, randomness is not properly accounted for. This casts doubts on the validity of most empirical results assessing randomized algorithms. There are numerous statistical tests, based on different assumptions, and it is not always clear when and how to use these tests. We hence provide practical guidelines to support empirical research on randomized algorithms in software engineering.},
	language = {en},
	urldate = {2021-05-05},
	booktitle = {Proceeding of the 33rd international conference on {Software} engineering - {ICSE} '11},
	publisher = {ACM Press},
	author = {Arcuri, Andrea and Briand, Lionel},
	year = {2011},
	pages = {1},
	file = {Arcuri and Briand - 2011 - A practical guide for using statistical tests to a.pdf:/Users/chakibbelgaid/Zotero newone/storage/HFAYTVZK/Arcuri and Briand - 2011 - A practical guide for using statistical tests to a.pdf:application/pdf},
}

@article{mcdowell_189_nodate,
	title = {189 {Programming} {Questions} and {Solutions}},
	language = {en},
	author = {Mcdowell, Gayle Laakmann},
	pages = {708},
	file = {Mcdowell - 189 Programming Questions and Solutions.pdf:/Users/chakibbelgaid/Zotero newone/storage/4YH7AZ47/Mcdowell - 189 Programming Questions and Solutions.pdf:application/pdf},
}

@article{garvin_introduction_2021,
	title = {An {Introduction} to {Statistical} {Learning} {Springer} {Texts} in {Statistics} {An} {Introduction} to {Statistical} {Learning}},
	url = {https://www.academia.edu/36691506/An_Introduction_to_Statistical_Learning_Springer_Texts_in_Statistics_An_Introduction_to_Statistical_Learning},
	language = {en},
	urldate = {2021-05-20},
	author = {Garvin, Matthew},
	month = may,
	year = {2021},
}

@book{james_introduction_2013,
	address = {New York, NY},
	series = {Springer {Texts} in {Statistics}},
	title = {An {Introduction} to {Statistical} {Learning}},
	volume = {103},
	isbn = {978-1-4614-7137-0 978-1-4614-7138-7},
	url = {http://link.springer.com/10.1007/978-1-4614-7138-7},
	language = {en},
	urldate = {2021-05-20},
	publisher = {Springer New York},
	author = {James, Gareth and Witten, Daniela and Hastie, Trevor and Tibshirani, Robert},
	year = {2013},
	doi = {10.1007/978-1-4614-7138-7},
	file = {James et al. - 2013 - An Introduction to Statistical Learning.pdf:/Users/chakibbelgaid/Zotero newone/storage/ZTLYY7VV/James et al. - 2013 - An Introduction to Statistical Learning.pdf:application/pdf},
}

@inproceedings{ilsche_power_2015,
	address = {Las Vegas, NV, USA},
	title = {Power measurements for compute nodes: {Improving} sampling rates, granularity and accuracy},
	isbn = {978-1-5090-0172-9},
	shorttitle = {Power measurements for compute nodes},
	url = {http://ieeexplore.ieee.org/document/7393710/},
	doi = {10.1109/IGCC.2015.7393710},
	abstract = {Energy efﬁciency is a key optimization goal for software and hardware in the High Performance Computing (HPC) domain. This necessitates sophisticated power measurement capabilities that are characterized by the key criteria (i) high sampling rates, (ii) measurement of individual components, (iii) well-deﬁned accuracy, and (iv) high scalability. In this paper, we tackle the ﬁrst three of these goals and describe the instrumentation of two high-end compute nodes with three different current measurement techniques: (i) Hall effect sensors, (ii) measuring shunts in extension cables and riser cards, and (iii) tapping into the voltage regulators. The resulting measurement data for components such as sockets, PCIe cards, and DRAM DIMMs is digitized at sampling rates from 7 kSa/s up to 500 kSa/s, enabling a ﬁne-grained correlation between power usage and application events. The accuracy of all elements in the measurement infrastructure is studied carefully. Moreover, potential pitfalls in building custom power instrumentation are discussed. We raise the awareness for the properties of power measurements, as disregarding existing inaccuracies can lead to invalid conclusions regarding energy efﬁciency.},
	language = {en},
	urldate = {2021-08-20},
	booktitle = {2015 {Sixth} {International} {Green} and {Sustainable} {Computing} {Conference} ({IGSC})},
	publisher = {IEEE},
	author = {Ilsche, Thomas and Hackenberg, Daniel and Graul, Stefan and Schone, Robert and Schuchart, Joseph},
	month = dec,
	year = {2015},
	pages = {1--8},
	file = {Ilsche et al. - 2015 - Power measurements for compute nodes Improving sa.pdf:/Users/chakibbelgaid/Zotero newone/storage/PBJIQRBK/Ilsche et al. - 2015 - Power measurements for compute nodes Improving sa.pdf:application/pdf},
}

@article{boettiger_introduction_2015-2,
	title = {An introduction to {Docker} for reproducible research},
	volume = {49},
	issn = {0163-5980},
	url = {https://dl.acm.org/doi/10.1145/2723872.2723882},
	doi = {10.1145/2723872.2723882},
	abstract = {As computational work becomes more and more integral to many aspects of scientiﬁc research, computational reproducibility has become an issue of increasing importance to computer systems researchers and domain scientists alike. Though computational reproducibility seems more straight forward than replicating physical experiments, the complex and rapidly changing nature of computer environments makes being able to reproduce and extend such work a serious challenge. In this paper, I explore common reasons that code developed for one research project cannot be successfully executed or extended by subsequent researchers. I review current approaches to these issues, including virtual machines and workﬂow systems, and their limitations. I then examine how the popular emerging technology Docker combines several areas from systems research - such as operating system virtualization, cross-platform portability, modular re-usable elements, versioning, and a ‘DevOps’ philosophy, to address these challenges. I illustrate this with several examples of Docker use with a focus on the R statistical environment.},
	language = {en},
	number = {1},
	urldate = {2021-08-25},
	journal = {ACM SIGOPS Operating Systems Review},
	author = {Boettiger, Carl},
	month = jan,
	year = {2015},
	pages = {71--79},
	file = {Boettiger - 2015 - An introduction to Docker for reproducible researc.pdf:/Users/chakibbelgaid/Zotero newone/storage/SHIZMQ42/Boettiger - 2015 - An introduction to Docker for reproducible researc.pdf:application/pdf},
}

@article{howe_virtual_2012,
	title = {Virtual {Appliances}, {Cloud} {Computing}, and {Reproducible} {Research}},
	volume = {14},
	issn = {1558-366X},
	doi = {10.1109/MCSE.2012.62},
	abstract = {As science becomes increasingly computational, reproducibility has become increasingly difficult, perhaps surprisingly. In many contexts, virtualization and cloud computing can mitigate the issues involved without significant overhead to the researcher, enabling the next generation of rigorous and reproducible computational science.},
	number = {4},
	journal = {Computing in Science Engineering},
	author = {Howe, Bill},
	month = jul,
	year = {2012},
	note = {Conference Name: Computing in Science Engineering},
	keywords = {case studies in scientific applications, cloud computing, Cloud computing, Context awareness, Documentation, Information retrieval, information storage and retrieval, Reproducibility of results, reproducible results, Research and development, scientific computing, Scientific computing, services computing, Virtual machining},
	pages = {36--41},
	file = {IEEE Xplore Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/7X8YSW6D/Howe - 2012 - Virtual Appliances, Cloud Computing, and Reproduci.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/chakibbelgaid/Zotero newone/storage/F35AB4XS/6193081.html:text/html},
}

@incollection{ranka_energy_2009,
	address = {Berlin, Heidelberg},
	title = {Energy {Efficiency} of {Thermal}-{Aware} {Job} {Scheduling} {Algorithms} under {Various} {Cooling} {Models}},
	volume = {40},
	isbn = {978-3-642-03546-3 978-3-642-03547-0},
	url = {http://link.springer.com/10.1007/978-3-642-03547-0_54},
	abstract = {One proposed technique to reduce energy consumption of data centers is thermal-aware job scheduling, i.e. job scheduling that relies on predictive thermal models to select among possible job schedules to minimize its energy needs. This paper investigates, using a more realistic linear cooling model, the energy savings of previously proposed thermal-aware job scheduling algorithms, which assume a less realistic model of constant cooling. The results show that the energy savings achieved are greater than the savings previously predicted. The contributions of this paper include: i) linear cooling models should be used in analysis and algorithm design, and ii) although the job scheduler must control the cooling equipment to realize most of the thermal-aware job schedule’s savings, some savings can be still achieved without that control.},
	language = {en},
	urldate = {2019-04-05},
	booktitle = {Contemporary {Computing}},
	publisher = {Springer Berlin Heidelberg},
	author = {Varsamopoulos, Georgios and Banerjee, Ayan and Gupta, Sandeep K. S.},
	editor = {Ranka, Sanjay and Aluru, Srinivas and Buyya, Rajkumar and Chung, Yeh-Ching and Dua, Sumeet and Grama, Ananth and Gupta, Sandeep K. S. and Kumar, Rajeev and Phoha, Vir V.},
	year = {2009},
	doi = {10.1007/978-3-642-03547-0_54},
	pages = {568--580},
	file = {Varsamopoulos et al. - 2009 - Energy Efficiency of Thermal-Aware Job Scheduling .pdf:/Users/chakibbelgaid/Zotero newone/storage/JZM7DVLD/Varsamopoulos et al. - 2009 - Energy Efficiency of Thermal-Aware Job Scheduling .pdf:application/pdf},
}

@inproceedings{joakim_v_kisroski_variations_2016,
	address = {Delft, Netherlands},
	title = {Variations in {CPU} {Power} {Consumption}},
	abstract = {Experimental analysis of computer systems’ power consump-
tion has become an integral part of system performance eval-
uation,  efficiency  management,  and  model-based  analysis.
As with all measurements, repeatability and reproducibility
of power measurements are a major challenge.
Nominally identical systems can have different power con-
sumption running the same workload under otherwise iden-
tical conditions.  This behavior can also be observed for in-
dividual system components.  Specifically, CPU power con-
sumption can vary amongst different samples of nominally
identical CPUs.  This in turn has a significant impact on the
overall  system  power,  considering  that  a  system’s  proces-
sor is the largest and most dynamic power consumer of the
overall system.  The concrete impact of CPU sample power
variations is unknown, as comprehensive studies about dif-
ferences in power consumption for nominally identical sys-
tems are currently missing.
We  address  this  lack  of  studies  by  conducting  measure-
ments  on  four  different  processor  types  from  two  different
architectures.   For  each  of  these  types,  we  compare  up  to
30 physical processor samples with a total sum of 90 sam-
ples over all processor types.  We analyze the variations in
power consumption for the different samples using six dif-
ferent workloads over five load levels.  Additionally, we ana-
lyze how these variations change for different processor core
counts and architectures.
The results of this paper show that selection of a processor
sample can have a statistically significant impact on power
consumption.   With  no  correlation  to  performance,  power
consumption for nominally identical processors can differ as
much as 29.6\% in idle and 19.5\% at full load.  We also show
that these variations change over different architectures and
processor types.},
	publisher = {ACM},
	author = {{Joakim v Kisroski} and {Hansfreid Block} and {John Beckett} and {Cloyce Spradling} and {Klaus-Dieter Lange} and {Samuel Kounev}},
	month = mar,
	year = {2016},
	annote = {Key ideas: 
-
this paper, we demonstrate that identical systems, con-
taining nominally identical processors can exhibit significant
power consumption differences that do not correlate signifi-
cantly with CPU temperature and system performance. The
differences are most significant during two system states:
idle and high load. Idle is the most volatile state for power
measurements. Different processor samples exacerbate this
problem, leading to differences in mean idle power consump-
tion of up to 29.6\%.},
	file = {p147.pdf:/Users/chakibbelgaid/Zotero newone/storage/G35C8GYW/p147.pdf:application/pdf},
}

@inproceedings{chasapis_runtime-guided_2016,
	address = {Istanbul, Turkey},
	title = {Runtime-{Guided} {Mitigation} of {Manufacturing} {Variability} in {Power}-{Constrained} {Multi}-{Socket} {NUMA} {Nodes}},
	isbn = {978-1-4503-4361-9},
	url = {http://dl.acm.org/citation.cfm?doid=2925426.2926279},
	doi = {10.1145/2925426.2926279},
	abstract = {Current large scale systems show increasing power demands, to the point that it has become a huge strain on facilities and budgets. Researchers in academia, labs and industry are focusing on dealing with this “power wall”, striving to ﬁnd a balance between performance and power consumption. Some commodity processors enable power capping, which opens up new opportunities for applications to directly manage their power behavior at user level. However, while power capping ensures a system will never exceed a given power limit, it also leads to a new form of heterogeneity: natural manufacturing variability, which was previously hidden by varying power to achieve homogeneous performance, now results in heterogeneous performance caused by diﬀerent CPU frequencies, potentially for each core, to enforce the power limit.},
	language = {en},
	urldate = {2019-03-19},
	booktitle = {Proceedings of the 2016 {International} {Conference} on {Supercomputing} - {ICS} '16},
	publisher = {ACM Press},
	author = {Chasapis, Dimitrios and Schulz, Martin and Casas, Marc and Ayguadé, Eduard and Valero, Mateo and Moretó, Miquel and Labarta, Jesus},
	year = {2016},
	pages = {1--12},
	annote = {key ideas:
- },
	file = {Chasapis et al. - 2016 - Runtime-Guided Mitigation of Manufacturing Variabi.pdf:/Users/chakibbelgaid/Zotero newone/storage/FMISFRGA/Chasapis et al. - 2016 - Runtime-Guided Mitigation of Manufacturing Variabi.pdf:application/pdf},
}

@inproceedings{inadomi_analyzing_2015,
	address = {Austin, Texas},
	title = {Analyzing and mitigating the impact of manufacturing variability in power-constrained supercomputing},
	isbn = {978-1-4503-3723-6},
	url = {http://dl.acm.org/citation.cfm?doid=2807591.2807638},
	doi = {10.1145/2807591.2807638},
	abstract = {A key challenge in next-generation supercomputing is to eﬀectively schedule limited power resources. Modern processors suﬀer from increasingly large power variations due to the chip manufacturing process. These variations lead to power inhomogeneity in current systems and manifest into performance inhomogeneity in power constrained environments, drastically limiting supercomputing performance. We present a ﬁrst-of-its-kind study on manufacturing variability on four production HPC systems spanning four microarchitectures, analyze its impact on HPC applications, and propose a novel variation-aware power budgeting scheme to maximize eﬀective application performance. Our low-cost and scalable budgeting algorithm strives to achieve performance homogeneity under a power constraint by deriving application-speciﬁc, module-level power allocations. Experimental results using a 1,920 socket system show up to 5.4X speedup, with an average speedup of 1.8X across all benchmarks when compared to a variation-unaware power allocation scheme.},
	language = {en},
	urldate = {2019-03-18},
	booktitle = {Proceedings of the {International} {Conference} for {High} {Performance} {Computing}, {Networking}, {Storage} and {Analysis} on - {SC} '15},
	publisher = {ACM Press},
	author = {Inadomi, Yuichi and Ueda, Masatsugu and Kondo, Masaaki and Miyoshi, Ikuo and Patki, Tapasya and Inoue, Koji and Aoyagi, Mutsumi and Rountree, Barry and Schulz, Martin and Lowenthal, David and Wada, Yasutaka and Fukazawa, Keiichiro},
	year = {2015},
	pages = {1--12},
	annote = {key ideas : 
- variation -aware power allocation algorithm
- the CPU power variatin is  due to the fabrication process (manufactruing variability) with 10\% variability on 64 cpus
- Use of RAPL + wattmeter
 
- },
	file = {Inadomi et al. - 2015 - Analyzing and mitigating the impact of manufacturi.pdf:/Users/chakibbelgaid/Zotero newone/storage/5IGGAM83/Inadomi et al. - 2015 - Analyzing and mitigating the impact of manufacturi.pdf:application/pdf},
}


@inproceedings{el_mehdi_diouri_your_2013,
	address = {Arlington, VA, USA},
	title = {Your cluster is not power homogeneous: {Take} care when designing green schedulers!},
	isbn = {978-1-4799-0623-9},
	shorttitle = {Your cluster is not power homogeneous},
	url = {http://ieeexplore.ieee.org/document/6604506/},
	doi = {10.1109/IGCC.2013.6604506},
	abstract = {Future supercomputers will consume enormous amounts of energy. These very large scale systems will gather many homogeneous clusters. In this paper, we analyze the power consumption of the nodes from different homogeneous clusters during different workloads. We classically observe that these nodes exhibit the same level of performance. But we also show that different nodes from a homogeneous cluster may exhibit heterogeneous idle power energy consumption even if they are made of identical hardware. Hence, we propose an experimental methodology to understand such differences. We show that CPUs are responsible for such heterogeneity which can reach 20\% in terms of energy consumption. So energy aware (Green) schedulers must take care of such hidden heterogeneity in order to propose efﬁcient mapping of tasks. To consume less energy, we propose an energy-aware scheduling approach taking into account the heterogeneous idle power consumption of homogeneous nodes. It shows that we are able to save energy up to 17\% while exploiting the high power heterogeneity that may exist in some homogeneous clusters.},
	language = {en},
	urldate = {2019-03-18},
	booktitle = {2013 {International} {Green} {Computing} {Conference} {Proceedings}},
	publisher = {IEEE},
	author = {El Mehdi Diouri, Mohammed and Gluck, Olivier and Lefevre, Laurent and Mignot, Jean-Christophe},
	month = jun,
	year = {2013},
	pages = {1--10},
	annote = {key ideas:
- green scheduling approach taking into account the heterogneous idle power consumption of  identical CPUs (up to 17\% saving)
- CPU burn consuming diffrent power on diffrent machines of same cluster og G5k
- checking many  hypothesis to findout the reason of the diffrence (temperature, placement, interchaging componenets, sonde callibrating ...)
- Usage might be due to the age of a cpu ( noticed bigger variation on older nodes)},
	file = {El Mehdi Diouri et al. - 2013 - Your cluster is not power homogeneous Take care w.pdf:/Users/chakibbelgaid/Zotero newone/storage/JABGCCQN/El Mehdi Diouri et al. - 2013 - Your cluster is not power homogeneous Take care w.pdf:application/pdf},
}

@article{wang_potential_2018,
	title = {Potential effects on server power metering and modeling},
	issn = {1022-0038, 1572-8196},
	url = {http://link.springer.com/10.1007/s11276-018-1882-1},
	doi = {10.1007/s11276-018-1882-1},
	abstract = {Cloud datacenters are compute facilities formed by hundreds or even thousands of servers. With the increasing demand of cloud services, energy efficiency of servers in data center has become a significant issue. The knowledge of the energy consumption corresponding to hardware and software configuration is important for operators to optimize energy efficiency of a data center. We currently work on a predictive model for energy consumption of a server, with inputs as service provided, hardware material equipped (type and quantity of processor, memory and hard drive) and technical environment (energy conversion and cooling). In this article, we characterize some potential factors on the power variation of the servers, such as: original fabrication, position in the rack, voltage variation and temperature of components on motherboard. The results show that certain factors, such as original fabrication, ambient temperature and CPU temperature, have noticeable effects on the power consumption of servers. The experimental results emphasize the importance of adding these external factors into the metric, so as to build an energy predictive model adaptable in real situations.},
	language = {en},
	urldate = {2019-03-18},
	journal = {Wireless Networks},
	author = {Wang, Yewan and Nörtershäuser, David and Le Masson, Stéphane and Menaud, Jean-Marc},
	month = nov,
	year = {2018},
	annote = {key ideas:
- CPU temperature highly impacts ithe variation},
	file = {Wang et al. - 2018 - Potential effects on server power metering and mod.pdf:/Users/chakibbelgaid/Zotero newone/storage/2WSIBNDJ/Wang et al. - 2018 - Potential effects on server power metering and mod.pdf:application/pdf},
}

@inproceedings{acun_variation_2016,
	address = {Istanbul, Turkey},
	title = {Variation {Among} {Processors} {Under} {Turbo} {Boost} in {HPC} {Systems}},
	isbn = {978-1-4503-4361-9},
	url = {http://dl.acm.org/citation.cfm?doid=2925426.2926289},
	doi = {10.1145/2925426.2926289},
	abstract = {The design and manufacture of present-day CPUs causes inherent variation in supercomputer architectures such as variation in power and temperature of the chips. The variation also manifests itself as frequency differences among processors under Turbo Boost dynamic overclocking. This variation can lead to unpredictable and suboptimal performance in tightly coupled HPC applications. In this study, we use compute-intensive kernels and applications to analyze the variation among processors in four top supercomputers: Edison, Cab, Stampede, and Blue Waters. We observe that there is an execution time difference of up to 16\% among processors on the Turbo Boost-enabled supercomputers: Edison, Cab, Stampede. There is less than 1\% variation on Blue Waters, which does not have a dynamic overclocking feature. We analyze measurements from temperature and power instrumentation and ﬁnd that intrinsic differences in the chips’ power efﬁciency is the culprit behind the frequency variation. Moreover, we analyze potential solutions such as disabling Turbo Boost, leaving idle cores and replacing slow chips to mitigate the variation. We also propose a speed-aware dynamic task redistribution (load balancing) algorithm to reduce the negative effects of performance variation. Our speedaware load balancing algorithm improves the performance up to 18\% compared to no load balancing performance and 6\% better than the non-speed aware counterpart.},
	language = {en},
	urldate = {2019-03-18},
	booktitle = {Proceedings of the 2016 {International} {Conference} on {Supercomputing} - {ICS} '16},
	publisher = {ACM Press},
	author = {Acun, Bilge and Miller, Phil and Kale, Laxmikant V.},
	year = {2016},
	pages = {1--12},
	annote = {Key ideas : 
- execution time diffrence up to 16\% where the turbo boost is enabled, less than 1\% variation on a super computer where there is no dyamic overclocking feature.
-IVY bridge/Sandy Bridge CPUs
- Variation between Core of the same CPU (sharing the same clock)  is not significant 
proposed solutions to mitigate the variation : disable turbo boost, replace  slow chips, leave cores ( one core) Idle , load balance work across cores},
	file = {Acun et al. - 2016 - Variation Among Processors Under Turbo Boost in HP.pdf:/Users/chakibbelgaid/Zotero newone/storage/7ZXJDZ2Z/Acun et al. - 2016 - Variation Among Processors Under Turbo Boost in HP.pdf:application/pdf},
}

@inproceedings{marathe_empirical_2017,
	address = {Denver, CO, USA},
	title = {An empirical survey of performance and energy efficiency variation on {Intel} processors},
	isbn = {978-1-4503-5132-4},
	url = {http://dl.acm.org/citation.cfm?doid=3149412.3149421},
	doi = {10.1145/3149412.3149421},
	abstract = {Traditional HPC performance and energy characterization approaches assume homogeneity and predictability in the performance of the target processor platform. Consequently, processor performance variation has been considered to be a secondary issue in the broader problem of performance characterization. In this work, we present an empirical survey of the variation in processor performance and energy efficiency on several generations of HPC-grade Intel processors. Our study shows that, compared to the previous generation of Intel processors, the problem of performance variation has become worse on more recent generation of Intel processors. Specifically, the performance variation across processors on a large-scale production HPC cluster at LLNL has increased to 20\% and the runto-run variation in the performance of individual processors has increased to 15\%. We show that this variation is further magnified under a hardware-enforced power constraint, potentially due to the increase in number of cores, inconsistencies in the chip manufacturing process and their combined impact on processor’s energy management functionality. Our experimentation with a hardwareenforced processor power constraint shows that the variation in processor performance and energy efficiency has increased by up to 4x on the latest Intel processors.},
	language = {en},
	urldate = {2019-03-18},
	booktitle = {Proceedings of the 5th {International} {Workshop} on {Energy} {Efficient} {Supercomputing}  - {E2SC}'17},
	publisher = {ACM Press},
	author = {Marathe, Aniruddha and Zhang, Yijia and Blanks, Grayson and Kumbhare, Nirmal and Abdulla, Ghaleb and Rountree, Barry},
	year = {2017},
	pages = {1--8},
	annote = {Key ideas:
-The problem of performance variation had became orse with the newest version of CPUs (20 \% between CPUs ad 15\% for a run-to-run results on a same CPU), 
- the variation of perf and energy consmption on intel newest processors (broadwerlll) has increased 4X, mainly due to hardware enforced constraints
- The variation of processor power effeciency depends on the application
- recommondation to mitigate the variation on Broadwell cpus
 
 },
	file = {Marathe et al. - 2017 - An empirical survey of performance and energy effi.pdf:/Users/chakibbelgaid/Zotero newone/storage/MVNM8QII/Marathe et al. - 2017 - An empirical survey of performance and energy effi.pdf:application/pdf},
}

@inproceedings{rahman_studying_2012,
	address = {Cagliari, Italy},
	title = {Studying the impact of application-level optimizations on the power consumption of multi-core architectures},
	isbn = {978-1-4503-1215-8},
	url = {http://dl.acm.org/citation.cfm?doid=2212908.2212927},
	doi = {10.1145/2212908.2212927},
	abstract = {This paper studies the overall system power variations of two multi-core architectures, an 8-core Intel and a 32-core AMD workstation, while using these machines to execute a wide variety of sequential and multi-threaded benchmarks using varying compiler optimization settings and runtime conﬁgurations. Our extensive experimental study provides insights for answering two questions: 1) what degrees of impact can application level optimizations have on reducing the overall system power consumption of modern CMP architectures; and 2) what strategies can compilers and application developers adopt to achieve a balanced performance and power eﬃciency for applications from a variety of science and embedded systems domains.},
	language = {en},
	urldate = {2019-03-18},
	booktitle = {Proceedings of the 9th conference on {Computing} {Frontiers} - {CF} '12},
	publisher = {ACM Press},
	author = {Rahman, Shah Mohammad Faizur and Guo, Jichi and Bhat, Akshatha and Garcia, Carlos and Sujon, Majedul Haque and Yi, Qing and Liao, Chunhua and Quinlan, Daniel},
	year = {2012},
	pages = {123},
	file = {Rahman et al. - 2012 - Studying the impact of application-level optimizat.pdf:/Users/chakibbelgaid/Zotero newone/storage/F9JGCY6A/Rahman et al. - 2012 - Studying the impact of application-level optimizat.pdf:application/pdf},
}

@article{6148200,
	title = {Power-{Management} {Architecture} of the {Intel} {Microarchitecture} {Code}-{Named} {Sandy} {Bridge}},
	volume = {32},
	issn = {0272-1732},
	doi = {10.1109/MM.2012.12},
	number = {2},
	journal = {IEEE Micro},
	author = {Rotem, E. and Naveh, A. and Ananthakrishnan, A. and Weissmann, E. and Rajwan, D.},
	month = mar,
	year = {2012},
	keywords = {Bridge circuits, Bridges, Computer architecture, energy management, Graphics, integration levels, Intel microarchitecture, Intel sandy bridge microprocessor, microcomputers, Microprocessors, power management, power management architecture, power management innovations, Sandy Bridge, system on a chip designs, System-on-a-chip, system-on-chip, Turbo Boost, Voltage control},
	pages = {20--27},
}

@inproceedings{sarimbekov_characteristics_2013,
	address = {Indianapolis, Indiana, USA},
	title = {Characteristics of dynamic {JVM} languages},
	isbn = {978-1-4503-2601-8},
	url = {http://dl.acm.org/citation.cfm?doid=2542142.2542144},
	doi = {10.1145/2542142.2542144},
	abstract = {The Java Virtual Machine (JVM) has become an execution platform targeted by many programming languages. However, unlike with Java, a statically-typed language, the performance of the JVM and its Just-In-Time (JIT) compiler with dynamically-typed languages lags behind purpose-built language-speciﬁc JIT compilers. In this paper, we aim to contribute to the understanding of the workloads imposed on the JVM by dynamic languages. We use various metrics to characterize the dynamic behavior of a variety of programs written in three dynamic languages (Clojure, Python, and Ruby) executing on the JVM. We identify the differences with respect to Java, and brieﬂy discuss their implications.},
	language = {en},
	urldate = {2018-12-14},
	booktitle = {Proceedings of the 7th {ACM} workshop on {Virtual} machines and intermediate languages - {VMIL} '13},
	publisher = {ACM Press},
	author = {Sarimbekov, Aibek and Podzimek, Andrej and Bulej, Lubomir and Zheng, Yudi and Ricci, Nathan and Binder, Walter},
	year = {2013},
	pages = {11--20},
	file = {Sarimbekov et al. - 2013 - Characteristics of dynamic JVM languages.pdf:/Users/chakibbelgaid/Zotero newone/storage/2RFFRFR3/Sarimbekov et al. - 2013 - Characteristics of dynamic JVM languages.pdf:application/pdf},
}

@article{dufour_dynamic_nodate,
	title = {Dynamic {Metrics} for {Java}},
	abstract = {In order to perform meaningful experiments in optimizing compilation and run-time system design, researchers usually rely on a suite of benchmark programs of interest to the optimization technique under consideration. Programs are described as numeric, memoryintensive, concurrent, or object-oriented, based on a qualitative appraisal, in some cases with little justiﬁcation. We believe it is beneﬁcial to quantify the behaviour of programs with a concise and precisely deﬁned set of metrics, in order to make these intuitive notions of program behaviour more concrete and subject to experimental validation. We therefore deﬁne and measure a set of unambiguous, dynamic, robust and architecture-independent metrics that can be used to categorize programs according to their dynamic behaviour in ﬁve areas: size, data structure, memory use, concurrency, and polymorphism. A framework computing some of these metrics for Java programs is presented along with speciﬁc results demonstrating how to use metric data to understand a program’s behaviour, and both guide and evaluate compiler optimizations.},
	language = {en},
	author = {Dufour, Bruno and Driesen, Karel and Hendren, Laurie and Verbrugge, Clark},
	pages = {20},
	file = {Dufour et al. - Dynamic Metrics for Java.pdf:/Users/chakibbelgaid/Zotero newone/storage/2YV9DR6J/Dufour et al. - Dynamic Metrics for Java.pdf:application/pdf},
}

@phdthesis{sarimbekov_workload_2014,
	title = {Workload characterization of {JVM} languages: {WORKLOAD} {CHARACTERIZATION} {OF} {JVM} {LANGUAGES}},
	shorttitle = {Workload characterization of {JVM} languages},
	url = {http://doi.wiley.com/10.1002/spe.2337},
	language = {en},
	urldate = {2018-12-14},
	author = {Sarimbekov, Aibek and Stadler, Lukas and Bulej, Lubomír and Sewe, Andreas and Podzimek, Andrej and Zheng, Yudi and Binder, Walter},
	year = {2014},
	annote = {Not energy-related, but if we want to look at JVM-based languages, especially at a bytecode level, it might be very interesting.
Six JVM languages: Java, Scala, Clojure, Jython, JRuby, and JavaScript. 
 
There is a chapter on workload characterization :

maybe we could reuse this to find a correlation between workload metrics (AFAIK not the same thing as language level metrics) and energy consumption.
Useful discussion about dynamic metrics (see related paper)

 
 
 },
	file = {Sarimbekov et al. - 2016 - Workload characterization of JVM languages WORKLO.pdf:/Users/chakibbelgaid/Zotero newone/storage/LARKD6WG/Sarimbekov et al. - 2016 - Workload characterization of JVM languages WORKLO.pdf:application/pdf},
}

@inproceedings{li_jvm-hosted_2013,
	address = {Stuttgart, Germany},
	title = {{JVM}-hosted languages: they talk the talk, but do they walk the walk?},
	isbn = {978-1-4503-2111-2},
	shorttitle = {{JVM}-hosted languages},
	url = {http://dl.acm.org/citation.cfm?doid=2500828.2500838},
	doi = {10.1145/2500828.2500838},
	abstract = {The rapid adoption of non-Java JVM languages is impressive: major international corporations are staking critical parts of their software infrastructure on components built from languages such as Scala and Clojure. However with the possible exception of Scala, there has been little academic consideration and characterization of these languages to date. In this paper, we examine four nonJava JVM languages and use exploratory data analysis techniques to investigate differences in their dynamic behavior compared to Java. We analyse a variety of programs and levels of behavior to draw distinctions between the different programming languages. We brieﬂy discuss the implications of our ﬁndings for improving the performance of JIT compilation and garbage collection on the JVM platform.},
	language = {en},
	urldate = {2018-12-14},
	booktitle = {Proceedings of the 2013 {International} {Conference} on {Principles} and {Practices} of {Programming} on the {Java} {Platform} {Virtual} {Machines}, {Languages}, and {Tools} - {PPPJ} '13},
	publisher = {ACM Press},
	author = {Li, Wing Hang and White, David R. and Singer, Jeremy},
	year = {2013},
	pages = {101},
	annote = {Companion web page:
http://www.dcs.gla.ac.uk/{\textasciitilde}wingli/jvm\_language\_study/},
	file = {JVM_Languages_Presentation.pdf:/Users/chakibbelgaid/Zotero newone/storage/2THVMA2J/JVM_Languages_Presentation.pdf:application/pdf;Li et al. - 2013 - JVM-hosted languages they talk the talk, but do t.pdf:/Users/chakibbelgaid/Zotero newone/storage/PJINASND/Li et al. - 2013 - JVM-hosted languages they talk the talk, but do t.pdf:application/pdf},
}

@inproceedings{park_investigation_2014,
	title = {Investigation for {Software} {Power} {Consumption} of {Code} {Refactoring} {Techniques}},
	booktitle = {{SEKE}},
	author = {Park, Jae Jin and Hong, Jang-Eui and Lee, Sang-Ho},
	year = {2014},
}

@inproceedings{gutierrez_seeds:_2014,
	title = {{SEEDS}: a software engineer's energy-optimization decision support framework},
	booktitle = {{ICSE}},
	publisher = {ACM},
	author = {Gutiérrez, Irene Lizeth Manotas and Pollock, Lori L. and Clause, James},
	year = {2014},
	pages = {503--514},
}

@inproceedings{hasan_energy_2016,
	title = {Energy {Profiles} of {Java} {Collections} {Classes}},
	doi = {10.1145/2884781.2884869},
	booktitle = {2016 {IEEE}/{ACM} 38th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Hasan, S. and King, Z. and Hafiz, M. and Sayagh, M. and Adams, B. and Hindle, A.},
	month = may,
	year = {2016},
	keywords = {Java, API, ArrayList, Collections, Encoding, Energy consumption, Energy measurement, Energy Profile, energy profiles, Java collections classes, Java List, LinkedList, Semiconductor device measurement, Set abstractions, Software, Software engineering},
	pages = {225--236},
}

@inproceedings{ribic_aequitas:_2016,
	address = {New York, NY, USA},
	series = {{ICS} '16},
	title = {{AEQUITAS}: {Coordinated} {Energy} {Management} {Across} {Parallel} {Applications}},
	isbn = {978-1-4503-4361-9},
	url = {http://doi.acm.org/10.1145/2925426.2926260},
	doi = {10.1145/2925426.2926260},
	booktitle = {Proceedings of the 2016 {International} {Conference} on {Supercomputing}},
	publisher = {ACM},
	author = {Ribic, Haris and Liu, Yu David},
	year = {2016},
	keywords = {DVFS, Energy Management, Parallelism, Work Stealing},
	pages = {4:1--4:12},
}

@inproceedings{corral_method_2014,
	address = {New York, NY, USA},
	series = {{SAC} '14},
	title = {Method {Reallocation} to {Reduce} {Energy} {Consumption}: {An} {Implementation} in {Android} {OS}},
	isbn = {978-1-4503-2469-4},
	url = {http://doi.acm.org/10.1145/2554850.2555064},
	doi = {10.1145/2554850.2555064},
	booktitle = {Proceedings of the 29th {Annual} {ACM} {Symposium} on {Applied} {Computing}},
	publisher = {ACM},
	author = {Corral, Luis and Georgiev, Anton B. and Sillitti, Alberto and Succi, Giancarlo},
	year = {2014},
	keywords = {Android, energy consumption, execution time, green, mobile},
	pages = {1213--1218},
}

@inproceedings{banerjee_automated_2016,
	title = {Automated {Re}-factoring of {Android} {Apps} to {Enhance} {Energy}-{Efficiency}},
	doi = {10.1109/MobileSoft.2016.038},
	booktitle = {2016 {IEEE}/{ACM} {International} {Conference} on {Mobile} {Software} {Engineering} and {Systems} ({MOBILESoft})},
	author = {Banerjee, A. and Roychoudhury, A.},
	month = may,
	year = {2016},
	keywords = {Energy consumption, energy consumption, Androids, automated refactoring, defect-expressions, design-expression, energy conservation, energy constrained, energy efficiency guidelines, energy-aware app development, Energy-efficiency, energy-intensive resource usages, event-handlers, Graphical user interfaces, Guidelines, Humanoid robots, Mobile Apps, Mobile communication, mobile computing, mobile devices, Mobile handsets, open-source Android apps, power aware computing, Re-factoring, smart phones, smartphones, software maintenance, tablets},
	pages = {139--150},
}

@inproceedings{cruz_leafactor:_2017,
	title = {Leafactor: {Improving} {Energy} {Efficiency} of {Android} {Apps} via {Automatic} {Refactoring}},
	doi = {10.1109/MOBILESoft.2017.21},
	booktitle = {2017 {IEEE}/{ACM} 4th {International} {Conference} on {Mobile} {Software} {Engineering} and {Systems} ({MOBILESoft})},
	author = {Cruz, L. and Abreu, R. and Rouvignac, J.},
	month = may,
	year = {2017},
	keywords = {Java, energy consumption, Androids, Humanoid robots, power aware computing, software maintenance, Android (operating system), Android apps, automatic refactoring, energy efficiency, Engines, Green Computing, Leafactor, Mobile Computing, Optimization, Refactoring, source code (software), source code refactoring, Tools, XML},
	pages = {205--206},
	file = {Cruz et al. - 2017 - Leafactor Improving Energy Efficiency of Android .pdf:/Users/chakibbelgaid/Zotero newone/storage/ZB9DYWJA/Cruz et al. - 2017 - Leafactor Improving Energy Efficiency of Android .pdf:application/pdf},
}

@article{othman_power_1998,
	title = {Power {Conservation} {Strategy} for {Mobile} {Computers} {Using} {Load} {Sharing}},
	volume = {2},
	issn = {1559-1662},
	url = {http://doi.acm.org/10.1145/584007.584011},
	doi = {10.1145/584007.584011},
	number = {1},
	journal = {SIGMOBILE Mob. Comput. Commun. Rev.},
	author = {Othman, Mazliza and Hailes, Stephen},
	month = jan,
	year = {1998},
	pages = {44--51},
}

@inproceedings{balasubramanian_energy_2009,
	address = {New York, NY, USA},
	series = {{IMC} '09},
	title = {Energy {Consumption} in {Mobile} {Phones}: {A} {Measurement} {Study} and {Implications} for {Network} {Applications}},
	isbn = {978-1-60558-771-4},
	url = {http://doi.acm.org/10.1145/1644893.1644927},
	doi = {10.1145/1644893.1644927},
	booktitle = {Proceedings of the 9th {ACM} {SIGCOMM} {Conference} on {Internet} {Measurement}},
	publisher = {ACM},
	author = {Balasubramanian, Niranjan and Balasubramanian, Aruna and Venkataramani, Arun},
	year = {2009},
	keywords = {cellular networks, energy savings, mobile applications, power measurement, wifi},
	pages = {280--293},
}

@inproceedings{nedevschi_reducing_2008,
	title = {Reducing {Network} {Energy} {Consumption} via {Sleeping} and {Rate}-{Adaptation}},
	booktitle = {{NSDI}},
	publisher = {USENIX Association},
	author = {Nedevschi, Sergiu and Popa, Lucian and Iannaccone, Gianluca and Ratnasamy, Sylvia and Wetherall, David},
	year = {2008},
	pages = {323--336},
	file = {Nedevschi et al. - 2008 - Reducing Network Energy Consumption via Sleeping a.pdf:/Users/chakibbelgaid/Zotero newone/storage/VXIJ79SZ/Nedevschi et al. - 2008 - Reducing Network Energy Consumption via Sleeping a.pdf:application/pdf},
}

@article{avgerinou_trends_2017,
	title = {Trends in {Data} {Centre} {Energy} {Consumption} under the {European} {Code} of {Conduct} for {Data} {Centre} {Energy} {Efficiency}},
	volume = {10},
	copyright = {http://creativecommons.org/licenses/by/3.0/},
	url = {https://www.mdpi.com/1996-1073/10/10/1470},
	doi = {10.3390/en10101470},
	abstract = {Climate change is recognised as one of the key challenges humankind is facing. The Information and Communication Technology (ICT) sector including data centres generates up to 2\% of the global CO2 emissions, a number on par to the aviation sector contribution, and data centres are estimated to have the fastest growing carbon footprint from across the whole ICT sector, mainly due to technological advances such as the cloud computing and the rapid growth of the use of Internet services. There are no recent estimations of the total energy consumption of the European data centre and of their energy efficiency. The aim of this paper is to evaluate, analyse and present the current trends in energy consumption and efficiency in data centres in the European Union using the data submitted by companies participating in the European Code of Conduct for Data Centre Energy Efficiency programme, a voluntary initiative created in 2008 in response to the increasing energy consumption in data centres and the need to reduce the related environmental, economic and energy supply security impacts. The analysis shows that the average Power Usage Effectiveness (PUE) of the facilities participating in the programme is declining year after year. This confirms that voluntary approaches could be effective in addressing climate and energy issue.},
	language = {en},
	number = {10},
	urldate = {2018-11-19},
	journal = {Energies},
	author = {Avgerinou, Maria and Bertoldi, Paolo and Castellazzi, Luca},
	month = sep,
	year = {2017},
	keywords = {Data Centre Energy Efficiency, energy efficiency policies, PUE, voluntary agreements},
	pages = {1470},
	file = {Snapshot:/Users/chakibbelgaid/Zotero newone/storage/A4CNN786/1470.html:text/html;Full Text PDF:/Users/chakibbelgaid/Zotero newone/storage/7DN2MQ4S/Avgerinou et al. - 2017 - Trends in Data Centre Energy Consumption under the.pdf:application/pdf},
}

@inproceedings{maria_avgerinou_trends_2017,
	title = {Trends in {Data} {Centre} {Energy} {Consumption} under the {European} {Code} of {Conduct} for {Data} {Centre} {Energy} {Efficiency}},
	abstract = {Climate change is recognised as one of the key challenges humankind is facing.
The Information and Communication Technology (ICT) sector including data centres generates
up to 2\% of the global CO2 emissions, a number on par to the aviation sector contribution, and data
centres are estimated to have the fastest growing carbon footprint from across the whole ICT sector,
mainly due to technological advances such as the cloud computing and the rapid growth of the use
of Internet services. There are no recent estimations of the total energy consumption of the European
data centre and of their energy efficiency. The aim of this paper is to evaluate, analyse and present the
current trends in energy consumption and efficiency in data centres in the European Union using the
data submitted by companies participating in the European Code of Conduct for Data Centre Energy
Efficiency programme, a voluntary initiative created in 2008 in response to the increasing energy
consumption in data centres and the need to reduce the related environmental, economic and energy
supply security impacts. The analysis shows that the average Power Usage Effectiveness (PUE) of
the facilities participating in the programme is declining year after year. This confirms that voluntary
approaches could be effective in addressing climate and energy issue.},
	publisher = {MDPI},
	author = {{Maria Avgerinou} and {Paolo Bertoldi} and {Luca Catellazzi}},
	month = sep,
	year = {2017},
}

@inproceedings{yao_applying_2013,
	address = {Zhangjiajie, China},
	title = {Applying {Graph} theory to the {Internet} of {Things}},
	isbn = {978-0-7695-5088-6},
	url = {http://ieeexplore.ieee.org/document/6832222/},
	doi = {10.1109/HPCC.and.EUC.2013.339},
	abstract = {In the Internet of Things (IoT), we all are “things”. Graph theory, a branch of discrete mathematics, has been proven to be useful and powerful in understanding complex networks in history. By means of graph theory, we deﬁne new concepts and terminology, and explore the deﬁnition of IoT, and then show that IoT is the union of a topological network, a data-functional network and a domi-functional network.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2013 {IEEE} 10th {International} {Conference} on {High} {Performance} {Computing} and {Communications} \& 2013 {IEEE} {International} {Conference} on {Embedded} and {Ubiquitous} {Computing}},
	publisher = {IEEE},
	author = {Yao, Bing and Liu, Xia and Zhang, Wan-Jia and Chen, Xiang-En and Zhang, Xiao-Min and Yao, Ming and Zhao, Zheng-Xue},
	month = nov,
	year = {2013},
	keywords = {SEEN},
	pages = {2354--2361},
	file = {Yao et al. - 2013 - Applying Graph theory to the Internet of Things.pdf:/Users/chakibbelgaid/Zotero newone/storage/7AMG9T3Z/Yao et al. - 2013 - Applying Graph theory to the Internet of Things.pdf:application/pdf},
}

@article{noureddine_review_2013,
	title = {A review of energy measurement approaches},
	volume = {47},
	issn = {01635980},
	url = {http://dl.acm.org/citation.cfm?doid=2553070.2553077},
	doi = {10.1145/2553070.2553077},
	abstract = {Reducing the energy footprint of digital devices and software is a task challenging the research in Green IT. Researches have proposed approaches for energy management, ranging from reducing usage of software and hardware, compilators optimization, to server consolidation and software migration. However, optimizing the energy consumption requires knowledge of that said consumption. In particular, measuring the energy consumption of hardware and software is an important requirement for efﬁcient energy strategies. In this review, we outline the different categories of approaches in energy measurements, and provide insights into example of each category. We draw recommendations from our review on requirements on how to efﬁciently measure energy consumption of devices and software.},
	language = {en},
	number = {3},
	urldate = {2018-11-07},
	journal = {ACM SIGOPS Operating Systems Review},
	author = {Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
	month = nov,
	year = {2013},
	keywords = {Read},
	pages = {42--49},
	file = {Noureddine et al. - 2013 - A review of energy measurement approaches.pdf:/Users/chakibbelgaid/Zotero newone/storage/525NIT5P/Noureddine et al. - 2013 - A review of energy measurement approaches.pdf:application/pdf},
}

@inproceedings{noureddine_preliminary_2012,
	address = {Zurich, Switzerland},
	title = {A preliminary study of the impact of software engineering on {GreenIT}},
	isbn = {978-1-4673-1832-7 978-1-4673-1833-4},
	url = {http://ieeexplore.ieee.org/document/6224251/},
	doi = {10.1109/GREENS.2012.6224251},
	abstract = {GreenIT has emerged as a discipline concerned with the optimization of software solutions with regards to their energy consumption. In this domain, most of state-of-the-art solutions offer limited or constraining approaches to monitor the energy consumption of a device or a process. In this paper, we therefore report on a runtime energy monitoring framework we developed to easily report on the energy consumption of system processes. Concretely, our approach adopts an OSlevel library, called POWERAPI, which estimates the power consumption of processes according to different dimensions (CPU, network, etc.). In order to better understand potential energy leaks of legacy software, we use this library to study the impact of programming languages and algorithmic choices on the energy consumption. This preliminary study is based on an empirical evaluation of a eight implementations of the Towers of Hanoi problem.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2012 {First} {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	publisher = {IEEE},
	author = {Noureddine, Adel and Bourdon, Aurelien and Rouvoy, Romain and Seinturier, Lionel},
	month = jun,
	year = {2012},
	keywords = {Seen},
	pages = {21--27},
	file = {Noureddine et al. - 2012 - A preliminary study of the impact of software engi.pdf:/Users/chakibbelgaid/Zotero newone/storage/GR565JIM/Noureddine et al. - 2012 - A preliminary study of the impact of software engi.pdf:application/pdf},
}

@inproceedings{penzenstadler_towards_2013,
	address = {Coimbra, Portugal},
	title = {Towards a definition of sustainability \textit{in} and \textit{for} software engineering},
	isbn = {978-1-4503-1656-9},
	url = {http://dl.acm.org/citation.cfm?doid=2480362.2480585},
	doi = {10.1145/2480362.2480585},
	abstract = {Sustainability is not supported by traditional software engineering methods. This lack of support leads to ineﬃcient eﬀorts to address sustainability or complete omission of this important concept. Deﬁning and developing adequate support requires a commonly accepted deﬁnition of what sustainability means in and for software engineering.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 28th {Annual} {ACM} {Symposium} on {Applied} {Computing} - {SAC} '13},
	publisher = {ACM Press},
	author = {Penzenstadler, Birgit},
	year = {2013},
	keywords = {Read},
	pages = {1183},
	file = {Penzenstadler - 2013 - Towards a definition of sustainability iini a.pdf:/Users/chakibbelgaid/Zotero newone/storage/HFWKSQZW/Penzenstadler - 2013 - Towards a definition of sustainability iini a.pdf:application/pdf},
}

@inproceedings{adel_noureddine_monitoring_2015,
	title = {Monitoring {Energy} {Hotspots} in {Software}},
	abstract = {Green IT has emerged as a discipline concerned with the optimiza-
tion of software solutions with regards to their energy consumption. In this
domain, most of the state-of-the-art solutions concentrate on coarse-grained
approaches  to  monitor  the  energy  consumption  of  a  device  or  a  process.  In
this paper, we report on a fine-grained runtime energy monitoring framework
we  developed  to  help  developers  to  diagnose  energy  hotspots  with  a  better
accuracy.
Concretely, our approach adopts a 2-layer architecture including OS-level
and  process-level  energy  monitoring.  OS-level  energy  monitoring  estimates
the energy consumption of processes according to different hardware devices
(CPU, network card). Process-level energy monitoring focuses on Java-based
applications and builds on OS-level energy monitoring to provide an estimation
of energy consumption at the granularity of classes and methods. We argue
that this per-method analysis of energy consumption provides better insights
to the application in order to identify potential energy hotspots. In particular,
our preliminary validation demonstrates that we can monitor energy hotspots
of
Jetty
web servers and monitor their variations under stress scenarios.},
	author = {{Adel Noureddine} and {Romain Rouvoy} and {Lionel Sienturier}},
	year = {2015},
	keywords = {Read},
}

@inproceedings{jae-jin_park_investigation_2014,
	title = {Investigation for {Software} {Power} {Consumption} of  {Code} {Refactoring} {Techniques}},
	abstract = {Code  refactoring  technique 
focuses  on
  enhancing
  the 
maintainability
 of software to extend its lifetime. However, 
there 
are  other  efforts  to  improve  software  qualities  like  performance  
or reliability a
s  well  as  maintainability  by  using  code  refactoring  
techniques.  Recently,  as  low
-power  software  has  become  one  of  
the 
critical  issues  in  mobile  environment
s,  developing  energy
-
efficient software through code refactoring becomes an important 
one.   This   paper
   aims
   to   investigate   whether   the   existing   
refactoring   techniques   can   support   energy
-efficient   software   
generation or not
. The refactored codes generated 
by the existing 
techniques can consume more power than original codes 
because 
they did not consider the
 power consumption in their refactoring 
processes
. 
This   paper   analyzes   the 
power   consumption   to   
investigate   the   energy   efficiency   of   M.   Fowler’s   refactoring   
techniques
.   Our  analysis  result  can  provide  
useful
  information 
about    energy
-efficient    refactoring    t
echniques
to    software    
engineers
, and support the development of software that has high 
maintainability and good energy efficiency},
	author = {{Jae-Jin Park} and {Jang-Eui Hong} and {Sang-Ho Lee}},
	year = {2014},
	keywords = {Read},
	file = {Jae-Jin Park et al. - 2014 - Investigation for Software Power Consumption of  C.pdf:/Users/chakibbelgaid/Zotero newone/storage/XT6Z64S3/Jae-Jin Park et al. - 2014 - Investigation for Software Power Consumption of  C.pdf:application/pdf},
}

@article{eddie_antonio_santos_how_nodate,
	title = {How does docker affect energy consumption? {Evaluating} workloads in and out of {Docker} containers},
	abstract = {Context: Virtual machines provide isolation of services at the cost of hypervisors and more resource usage. This
spurred the growth of systems like Docker that enable single hosts to isolate several applications, similar to VMs,
within a low-overhead abstraction called containers.
Motivation: Although containers tout low overhead performance, how much do they increase energy use?
Methodology: This work statistically compares the energy consumption of three application workloads in
Docker and on bare-metal Linux.
Results: In all cases, there was a statistically significant (t-test and Wilcoxon p {\textless} .05) increase in energy
consumption when running tests in Docker, mostly due to the performance of I/O system calls. Developers
worried about I/O overhead could consider baremetal deployments over Docker container deployments.},
	journal = {The journal of systems \& Software},
	author = {{Eddie Antonio Santos} and {Carson McLean} and {Christophr Solinas} and {Abram Hindle}},
	keywords = {Read},
	file = {Eddie Antonio Santos et al. - How does docker affect energy consumption Evaluat.pdf:/Users/chakibbelgaid/Zotero newone/storage/ADGAXM3Q/Eddie Antonio Santos et al. - How does docker affect energy consumption Evaluat.pdf:application/pdf},
}

@inproceedings{chowdhury_greenoracle:_2016,
	title = {{GreenOracle}: estimating software energy consumption with energy measurement corpora},
	isbn = {978-1-4503-4186-8},
	shorttitle = {{GreenOracle}},
	url = {http://dl.acm.org/citation.cfm?doid=2901739.2901763},
	doi = {10.1145/2901739.2901763},
	abstract = {Software energy consumption is a relatively new concern for mobile application developers. Poor energy performance can harm adoption and sales of applications. Unfortunately for the developers, the measurement of software energy consumption is expensive in terms of hardware and diﬃcult in terms of expertise. Many prior models of software energy consumption assume that developers can use hardware instrumentation and thus cannot evaluate software running within emulators or virtual machines. Some prior models require actual energy measurements from the previous versions of applications in order to model the energy consumption of later versions of the same application.},
	language = {en},
	urldate = {2018-07-24},
	publisher = {ACM Press},
	author = {Chowdhury, Shaiful Alam and Hindle, Abram},
	year = {2016},
	keywords = {Read},
	pages = {49--60},
	file = {Chowdhury and Hindle - 2016 - GreenOracle estimating software energy consumptio.pdf:/Users/chakibbelgaid/Zotero newone/storage/XMDU2YUI/Chowdhury and Hindle - 2016 - GreenOracle estimating software energy consumptio.pdf:application/pdf},
}

@inproceedings{samir_hasan_energy_2016,
	title = {Energy {Profiles} of {Java} {Collections} {Classes}},
	abstract = {We created detailed profiles of the energy consumed by com-
mon operations done on Java List,  Map,  and Set abstrac-
tions.  The results show that the alternative data types for
these abstractions differ significantly in terms of energy con-
sumption depending on the operations.  For example, an Ar-
rayList consumes less energy than a LinkedList if items are
inserted  at  the  middle  or  at  the  end,  but  consumes  more
energy than a LinkedList if items are inserted at the start
of the list.  To explain the results, we explored the memory
usage and the bytecode executed during an operation.  Ex-
pensive computation tasks in the analyzed bytecode traces
appeared to have an energy impact, but memory usage did
not contribute.  We evaluated our profiles by using them to
selectively replace Collections types used in six applications
and  libraries.   We  found  that  choosing  the  wrong  Collec-
tions type, as indicated by our profiles, can cost even 300\%
more energy than the most efficient choice.  Our work shows
that the usage context of a data structure and our measured
energy  profiles  can  be  used  to  decide  between  alternative
Collections implementations.},
	author = {{Samir Hasan} and {Rachary King} and {Munawar Hafiz}},
	year = {2016},
	keywords = {Read},
	file = {Samir Hasan et al. - 2016 - Energy Profiles of Java Collections Classes.pdf:/Users/chakibbelgaid/Zotero newone/storage/ABWMLZIN/Samir Hasan et al. - 2016 - Energy Profiles of Java Collections Classes.pdf:application/pdf},
}

@article{pinto_energy_2017,
	title = {Energy efficiency: a new concern for application software developers},
	volume = {60},
	issn = {00010782},
	shorttitle = {Energy efficiency},
	url = {http://dl.acm.org/citation.cfm?doid=3167461.3154384},
	doi = {10.1145/3154384},
	language = {en},
	number = {12},
	urldate = {2018-11-06},
	journal = {Communications of the ACM},
	author = {Pinto, Gustavo and Castor, Fernando},
	month = nov,
	year = {2017},
	keywords = {Read},
	pages = {68--75},
	file = {Pinto and Castor - 2017 - Energy efficiency a new concern for application s.pdf:/Users/chakibbelgaid/Zotero newone/storage/94PJ4FDI/Pinto and Castor - 2017 - Energy efficiency a new concern for application s.pdf:application/pdf},
}

@article{jagroep_energy_2017,
	title = {Energy efficiency on the product roadmap: {An} empirical study across releases of a software product: {Energy} efficiency on the product roadmap},
	volume = {29},
	issn = {20477473},
	shorttitle = {Energy efficiency on the product roadmap},
	url = {http://doi.wiley.com/10.1002/smr.1852},
	doi = {10.1002/smr.1852},
	abstract = {In the quest for energy efficient Information and Communication Technology, research has mostly focused on the role of hardware. However, the impact of software on energy consumption has been acknowledged as significant by researchers in software engineering. In spite of that, due to cost and time constraints, many software producing organizations are unable to effectively measure software energy consumption preventing them to include energy efficiency in the product roadmap.},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Journal of Software: Evolution and Process},
	author = {Jagroep, Erik and Procaccianti, Giuseppe and van der Werf, Jan Martijn and Brinkkemper, Sjaak and Blom, Leen and van Vliet, Rob},
	month = feb,
	year = {2017},
	keywords = {Read},
	pages = {e1852},
	file = {Jagroep et al. - 2017 - Energy efficiency on the product roadmap An empir.pdf:/Users/chakibbelgaid/Zotero newone/storage/LVYUXDJF/Jagroep et al. - 2017 - Energy efficiency on the product roadmap An empir.pdf:application/pdf},
}

@inproceedings{stephen_romansky_deep_2017,
	title = {Deep {Green}: modelling time-series of software energy consumption},
	author = {{Stephen Romansky} and {Neil C Borle} and {Shaiful Chowdhury} and {Abram Hindle} and {Russ Greiner}},
	year = {2017},
	keywords = {Read},
	file = {Romansky et al. - 2017 - Deep Green Modelling Time-Series of Software Ener.pdf:/Users/chakibbelgaid/Zotero newone/storage/C7IE6U4V/Romansky et al. - 2017 - Deep Green Modelling Time-Series of Software Ener.pdf:application/pdf},
}

@misc{erik_jagroep_awakening_nodate,
	title = {Awakening {Awareness} on {Energy} {Consumption} in {Software} {Engineering}},
	url = {https://ieeexplore.ieee.org/abstract/document/7961670},
	abstract = {Software  producing  organizations  have  the  ability
to  address  the  energy  impact  of  their  ICT  solutions  during  the
development process. However, while industry is convinced of the
energy impact of hardware, the role of software has mostly been
acknowledged by researchers in software engineering. Strength-
ened  by  the  limited  practical  knowledge  to  reduce  the  energy
consumption,  organizations  have  less  control  over  the  energy
impact  of  their  products  and  lose  the  contribution  of  software
towards  energy  related  strategies.  Consequently,  industry  risks
not  being  able  to  meet  customer  requirements  or  even  fulfill
corporate  sustainability  goals.
In  this  paper  we  perform  an  exploratory  case  study  on  how
to  create  and  maintain  awareness  on  an  energy  consumption
perspective  for  software  among  stakeholders  involved  with  the
development of software products. During the study, we followed
the  development  process  of  two  commercial  software  products
and  provided  direct  feedback  to  the  stakeholders  on  the  effects
of their development efforts, specifically concerning energy con-
sumption and performance, using an energy dashboard. Multiple
awareness  measurements  allowed  us  to  keep  track  of  changes
over  time  on  specific  aspects  affecting  software  development.
Our  results  show  that,  despite  a  mixed  sentiment  towards  the
dashboard,  changed  awareness  has  triggered  discussion  on  the
energy  consumption  of  software.},
	publisher = {IEEE},
	author = {{Erik Jagroep} and {Jordy Broekman} and {Jan Martijn} and {E.M. van der Werf} and {Sjaak Brinkkemper} and {Patricia Lago} and {Leen Blom} and {Rob van Vliet}},
	keywords = {Read},
	file = {_.pdf:/Users/chakibbelgaid/Zotero newone/storage/G2E27DV9/_.pdf:application/pdf},
}

@inproceedings{irene_manotas_software_2014,
	title = {A software engineer’s energy-optimization decision support framework},
	author = {{Irene Manotas} and {Lori Pollock} and {James Clause}},
	year = {2014},
	keywords = {Read},
	file = {grumpy-0.2.2.zip:/Users/chakibbelgaid/Zotero newone/storage/HAUUQX33/grumpy-0.2.2.zip:application/zip;Irene Manotas et al. - 2014 - A software engineer’s energy-optimization decision.pdf:/Users/chakibbelgaid/Zotero newone/storage/BL9M8VHI/Irene Manotas et al. - 2014 - A software engineer’s energy-optimization decision.pdf:application/pdf},
}

@inproceedings{pinto_comprehensive_2016,
	address = {Raleigh, NC, USA},
	title = {A {Comprehensive} {Study} on the {Energy} {Efficiency} of {Java}’s {Thread}-{Safe} {Collections}},
	isbn = {978-1-5090-3806-0},
	url = {http://ieeexplore.ieee.org/document/7816451/},
	doi = {10.1109/ICSME.2016.34},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2016 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	publisher = {IEEE},
	author = {Pinto, Gustavo and Liu, Kenan and Castor, Fernando and Liu, Yu David},
	month = oct,
	year = {2016},
	keywords = {Read},
	pages = {20--31},
	file = {Pinto et al. - 2016 - A Comprehensive Study on the Energy Efficiency of .pdf:/Users/chakibbelgaid/Zotero newone/storage/PZGJMJ8S/Pinto et al. - 2016 - A Comprehensive Study on the Energy Efficiency of .pdf:application/pdf},
}

@misc{noauthor_guide_2012,
	title = {Guide pour le bilan des émissions de {Gaz} à {Effet} de {Serre} des organisations du secteur des {TNIC}.pdf},
	language = {fr},
	year = {2012},
	file = {ADEME - 2012 - Guide pour le bilan des émissions de Gaz à Effet de Serre des organisations du secteur des TNIC.pdf:/Users/chakibbelgaid/Zotero newone/storage/S7XK9EM7/ADEME - 2012 - Guide pour le bilan des Žmissions de Gaz ˆ Effet de Serre des organisations du secteur des TNIC.pdf:application/pdf},
}

@inproceedings{pinto_understanding_2014,
	address = {Portland, Oregon, USA},
	title = {Understanding energy behaviors of thread management constructs},
	isbn = {978-1-4503-2585-1},
	url = {http://dl.acm.org/citation.cfm?doid=2660193.2660235},
	doi = {10.1145/2660193.2660235},
	abstract = {Java programmers are faced with numerous choices in managing concurrent execution on multicore platforms. These choices often have different trade-offs (e.g., performance, scalability, and correctness guarantees). This paper analyzes an additional dimension, energy consumption. It presents an empirical study aiming to illuminate the relationship between the choices and settings of thread management constructs and energy consumption. We consider three important thread management constructs in concurrent programming: explicit thread creation, ﬁxed-size thread pooling, and work stealing. We further shed light on the energy/performance trade-off of three “tuning knobs” of these constructs: the number of threads, the task division strategy, and the characteristics of processed data. Through an extensive experimental space exploration over real-world Java programs, we produce a list of ﬁndings about the energy behaviors of concurrent programs, which are not always obvious. The study serves as a ﬁrst step toward improving energy efﬁciency of concurrent programs on parallel architectures.},
	language = {en},
	urldate = {2018-11-06},
	booktitle = {Proceedings of the 2014 {ACM} {International} {Conference} on {Object} {Oriented} {Programming} {Systems} {Languages} \& {Applications} - {OOPSLA} '14},
	publisher = {ACM Press},
	author = {Pinto, Gustavo and Castor, Fernando and Liu, Yu David},
	year = {2014},
	pages = {345--360},
	file = {Pinto et al. - 2014 - Understanding energy behaviors of thread managemen.pdf:/Users/chakibbelgaid/Zotero newone/storage/7IPXLUUG/Pinto et al. - 2014 - Understanding energy behaviors of thread managemen.pdf:application/pdf;Pinto et al. - 2014 - Understanding energy behaviors of thread managemen.pdf:/Users/chakibbelgaid/Zotero newone/storage/RR59UBV4/Pinto et al. - 2014 - Understanding energy behaviors of thread managemen.pdf:application/pdf},
}

@article{noureddine_towards_nodate,
	title = {Towards a {Better} {Understanding} of the {Energy} {Consumption} of {Software} {Systems}},
	language = {en},
	author = {Noureddine, Adel},
	pages = {158},
	file = {Noureddine - Towards a Better Understanding of the Energy Consu.pdf:/Users/chakibbelgaid/Zotero newone/storage/UE3UK6I7/Noureddine - Towards a Better Understanding of the Energy Consu.pdf:application/pdf},
}

@inproceedings{jagroep_software_2016,
	address = {Austin, Texas},
	title = {Software energy profiling: comparing releases of a software product},
	isbn = {978-1-4503-4205-6},
	shorttitle = {Software energy profiling},
	url = {http://dl.acm.org/citation.cfm?doid=2889160.2889216},
	doi = {10.1145/2889160.2889216},
	abstract = {In the quest for energy eﬃciency of Information and Communication Technology, so far research has mostly focused on the role of hardware. However, as hardware technology becomes more sophisticated, the role of software becomes crucial. Recently, the impact of software on energy consumption has been acknowledged as signiﬁcant by researchers in software engineering. In spite of that, measuring the energy consumption of software has proven to be a challenge, due to the large number of variables that need to be controlled to obtain reliable measurements. Due to cost and time constraints, many software product organizations are unable to eﬀectively measure the energy consumption of software. This prevents them to be in control over the energy eﬃciency of their products.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} {Companion} - {ICSE} '16},
	publisher = {ACM Press},
	author = {Jagroep, Erik A. and van der Werf, Jan Martijn and Brinkkemper, Sjaak and Procaccianti, Giuseppe and Lago, Patricia and Blom, Leen and van Vliet, Rob},
	year = {2016},
	pages = {523--532},
	file = {Jagroep et al. - 2016 - Software energy profiling comparing releases of a.pdf:/Users/chakibbelgaid/Zotero newone/storage/GY6KP5LI/Jagroep et al. - 2016 - Software energy profiling comparing releases of a.pdf:application/pdf},
}

@incollection{fagas_energy-aware_2017,
	title = {Energy-{Aware} {Software} {Engineering}},
	isbn = {978-953-51-3011-6 978-953-51-3012-3},
	url = {http://www.intechopen.com/books/ict-energy-concepts-for-energy-efficiency-and-sustainability/energy-aware-software-engineering},
	abstract = {A great deal of energy in Information and Communication Technology (ICT) systems can be wasted by software, regardless of how energy-efficient the underlying hardware is. To avoid such waste, programmers need to understand the energy consumption of programs during the development process rather than waiting to measure energy after deployment. Such understanding is hindered by the large conceptual gap from hardware, where energy is consumed, to high-level languages and programming abstractions. The approaches described in this chapter involve two main topics: energy modelling and energy analysis. The purpose of modelling is to attribute energy values to programming constructs, whether at the level of machine instructions, intermediate code or source code. Energy analysis involves inferring the energy consumption of a program from the program semantics along with an energy model. Finally, the chapter discusses how energy analysis and modelling techniques can be incorporated in software engineering tools, including existing compilers, to assist the energy-aware programmer to optimise the energy consumption of code.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {{ICT} - {Energy} {Concepts} for {Energy} {Efficiency} and {Sustainability}},
	publisher = {InTech},
	author = {Eder, Kerstin and Gallagher, John P.},
	editor = {Fagas, Giorgos and Gammaitoni, Luca and Gallagher, John P. and Paul, Douglas J.},
	month = mar,
	year = {2017},
	doi = {10.5772/65985},
	file = {Eder and Gallagher - 2017 - Energy-Aware Software Engineering.pdf:/Users/chakibbelgaid/Zotero newone/storage/U59QDWZ8/Eder and Gallagher - 2017 - Energy-Aware Software Engineering.pdf:application/pdf},
}

@article{ardito_understanding_2015,
	title = {Understanding {Green} {Software} {Development}: {A} {Conceptual} {Framework}},
	volume = {17},
	issn = {1520-9202},
	shorttitle = {Understanding {Green} {Software} {Development}},
	url = {http://ieeexplore.ieee.org/document/7030252/},
	doi = {10.1109/MITP.2015.16},
	language = {en},
	number = {1},
	urldate = {2018-11-07},
	journal = {IT Professional},
	author = {Ardito, Luca and Procaccianti, Giuseppe and Torchiano, Marco and Vetro, Antonio},
	month = jan,
	year = {2015},
	pages = {44--50},
	file = {Ardito et al. - 2015 - Understanding Green Software Development A Concep.pdf:/Users/chakibbelgaid/Zotero newone/storage/EHBDAYKW/Ardito et al. - 2015 - Understanding Green Software Development A Concep.pdf:application/pdf},
}

@article{pahl_cloud_2017,
	title = {Cloud architecture continuity: {Change} models and change rules for sustainable cloud software architectures: {Cloud} {Architecture} {Continuity}},
	volume = {29},
	issn = {20477473},
	shorttitle = {Cloud architecture continuity},
	url = {http://doi.wiley.com/10.1002/smr.1849},
	doi = {10.1002/smr.1849},
	abstract = {Cloud systems provide elastic execution environments of resources that link application and infrastructure/platform components, which are both exposed to uncertainties and change. Change appears in 2 forms: the evolution of architectural components under changing requirements and the adaptation of the infrastructure running applications. Cloud architecture continuity refers to the ability of a cloud system to change its architecture and maintain the validity of the goals that determine the architecture. Goal validity implies the satisfaction of goals in adapting or evolving systems. Architecture continuity aids technical sustainability, that is, the longevity of information, systems, and infrastructure and their adequate evolution with changing conditions. In a cloud setting that requires both steady alignment with technological evolution and availability, architecture continuity directly impacts economic sustainability. We investigate change models and change rules for managing change to support cloud architecture continuity. These models and rules define transformations of architectures to maintain system goals: Evolution is about unanticipated change of structural aspects of architectures, and adaptation is about anticipated change of architecture configurations. Both are driven by quality and cost, and both represent multidimensional decision problems under uncertainty. We have applied the models and rules for adaptation and evolution in research and industry consultancy projects.},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Journal of Software: Evolution and Process},
	author = {Pahl, Claus and Jamshidi, Pooyan and Weyns, Danny},
	month = feb,
	year = {2017},
	pages = {e1849},
	file = {Pahl et al. - 2017 - Cloud architecture continuity Change models and c.pdf:/Users/chakibbelgaid/Zotero newone/storage/2RN8BNF6/Pahl et al. - 2017 - Cloud architecture continuity Change models and c.pdf:application/pdf},
}

@article{chinenyeze_beftigre:_2017,
	title = {{BEFTIGRE}: {Behaviour}-driven full-tier green evaluation of mobile cloud applications},
	volume = {29},
	issn = {20477473},
	shorttitle = {{BEFTIGRE}},
	url = {http://doi.wiley.com/10.1002/smr.1848},
	doi = {10.1002/smr.1848},
	abstract = {With the resource‐constrained nature of mobile devices and the resource‐abundant offerings of the cloud, several promising optimisation techniques have been proposed by the green computing research community. Prominent techniques and unique methods have been developed to offload resource intensive tasks from mobile devices to the cloud. Although these schemes address similar questions within the same domain of mobile cloud application (MCA) optimisation, evaluation is tailored to the scheme and also solely mobile focused, thus making it difficult to clearly compare with other existing counterparts. In this work, we first analyse the existing/commonly adopted evaluation technique, then with the aim to fill the above gap, we propose the behaviour‐driven full‐tier green evaluation approach, which adopts the behaviour‐driven concept for evaluating MCA performance and energy usage—ie, green metrics. To automate the evaluation process, we also present and evaluate the effectiveness of a resultant application program interface and tool driven by the behaviour‐driven full‐tier green evaluation approach. The application program interface is based on Android and has been validated with Elastic Compute Cloud instance. Experiments show that Beftigre is capable of providing a more distinctive, comparable, and reliable green test results for MCAs.},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Journal of Software: Evolution and Process},
	author = {Chinenyeze, Samuel J. and Liu, Xiaodong and Al-Dubai, Ahmed},
	month = feb,
	year = {2017},
	pages = {e1848},
	file = {Chinenyeze et al. - 2017 - BEFTIGRE Behaviour-driven full-tier green evaluat.pdf:/Users/chakibbelgaid/Zotero newone/storage/42DF8EMC/Chinenyeze et al. - 2017 - BEFTIGRE Behaviour-driven full-tier green evaluat.pdf:application/pdf},
}

@article{feitosa_investigating_2017,
	title = {Investigating the effect of design patterns on energy consumption: {The} energy consumption of design patterns},
	volume = {29},
	issn = {20477473},
	shorttitle = {Investigating the effect of design patterns on energy consumption},
	url = {http://doi.wiley.com/10.1002/smr.1851},
	doi = {10.1002/smr.1851},
	abstract = {Gang of Four (GoF) patterns are well‐known best practices for the design of object‐oriented systems. In this paper, we aim at empirically assessing their relationship to energy consumption, ie, a performance indicator that has recently attracted the attention of both researchers and practitioners. To achieve this goal, we investigate pattern‐participating methods (ie, those that play a role within the pattern) and compare their energy consumption to the consumption of functionally equivalent alternative (nonpattern) solutions. We obtained the alternative solution by refactoring the pattern instances using well‐known transformations (eg, replace polymorphism with conditional statements). The comparison is performed on 169 methods of 2 GoF patterns (namely, State/Strategy and Template Method), retrieved from 2 well‐known open source projects. The results suggest that for the majority of cases the alternative design excels in terms of energy consumption. However, in some cases (eg, when the method is large in size or invokes many methods) the pattern solution presents similar or lower energy consumption. The outcome of our study can be useful to both researchers and practitioners, because we: (1) provide evidence on a possible negative effect of GoF patterns, and (2) can provide guidance on which cases the use of the pattern is not hurting energy consumption.},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Journal of Software: Evolution and Process},
	author = {Feitosa, Daniel and Alders, Rutger and Ampatzoglou, Apostolos and Avgeriou, Paris and Nakagawa, Elisa Yumi},
	month = feb,
	year = {2017},
	pages = {e1851},
	file = {Feitosa et al. - 2017 - Investigating the effect of design patterns on ene.pdf:/Users/chakibbelgaid/Zotero newone/storage/JNBP2UAP/Feitosa et al. - 2017 - Investigating the effect of design patterns on ene.pdf:application/pdf},
}

@article{lago_editorial:_2017,
	title = {Editorial: {Reality} check for software engineering for sustainability-pragmatism required: {Editorial}},
	volume = {29},
	issn = {20477473},
	shorttitle = {Editorial},
	url = {http://doi.wiley.com/10.1002/smr.1856},
	doi = {10.1002/smr.1856},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Journal of Software: Evolution and Process},
	author = {Lago, Patricia and Penzenstadler, Birgit},
	month = feb,
	year = {2017},
	pages = {e1856},
	file = {Lago and Penzenstadler - 2017 - Editorial Reality check for software engineering .pdf:/Users/chakibbelgaid/Zotero newone/storage/K8KRP6KW/Lago and Penzenstadler - 2017 - Editorial Reality check for software engineering .pdf:application/pdf},
}

@inproceedings{manotas_seeds:_2014,
	address = {Hyderabad, India},
	title = {{SEEDS}: a software engineer's energy-optimization decision support framework},
	isbn = {978-1-4503-2756-5},
	shorttitle = {{SEEDS}},
	url = {http://dl.acm.org/citation.cfm?doid=2568225.2568297},
	doi = {10.1145/2568225.2568297},
	abstract = {Reducing the energy usage of software is becoming more important in many environments, in particular, batterypowered mobile devices, embedded systems and data centers. Recent empirical studies indicate that software engineers can support the goal of reducing energy usage by making design and implementation decisions in ways that take into consideration how such decisions impact the energy usage of an application. However, the large number of possible choices and the lack of feedback and information available to software engineers necessitates some form of automated decision-making support.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering} - {ICSE} 2014},
	publisher = {ACM Press},
	author = {Manotas, Irene and Pollock, Lori and Clause, James},
	year = {2014},
	pages = {503--514},
	file = {Manotas et al. - 2014 - SEEDS a software engineer's energy-optimization d.pdf:/Users/chakibbelgaid/Zotero newone/storage/F4CPJLU9/Manotas et al. - 2014 - SEEDS a software engineer's energy-optimization d.pdf:application/pdf},
}

@article{chitchyan_uncovering_2017,
	title = {Uncovering sustainability concerns in software product lines: {Uncovering} sustainability concerns in software product lines},
	volume = {29},
	issn = {20477473},
	shorttitle = {Uncovering sustainability concerns in software product lines},
	url = {http://doi.wiley.com/10.1002/smr.1853},
	doi = {10.1002/smr.1853},
	abstract = {Sustainable living, ie, living within the bounds of the available environmental, social, and economic resources, is the focus of many present-day social and scientific discussions. But what does sustainability mean within the context of software engineering? In this paper, we undertake a comprehensive analysis of 8 case studies to address this question within the context of a specific software engineering approach, software product line engineering (SPLE). We identify the sustainability-related characteristics that arise in present-day studies that apply SPLE. We conclude that technical and economic sustainability are in prime focus on the present SPLE practice, with social sustainability issues, where they relate to organisations, also addressed to a good degree. On the other hand, the issues related to the personal sustainability are less prominent, and environmental considerations are nearly completely amiss. We present feature models and cross-relations that result from our analysis as a starting point for sustainability engineering through SPLE, suggesting that any new development should consider how these models would be instantiated and expanded for the intended sociotechnical system. The good representation of sustainability features in these models is also validated with 2 additional case studies.},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Journal of Software: Evolution and Process},
	author = {Chitchyan, Ruzanna and Groher, Iris and Noppen, Joost},
	month = feb,
	year = {2017},
	pages = {e1853},
	file = {Chitchyan et al. - 2017 - Uncovering sustainability concerns in software pro.pdf:/Users/chakibbelgaid/Zotero newone/storage/ETXJJTI3/Chitchyan et al. - 2017 - Uncovering sustainability concerns in software pro.pdf:application/pdf},
}

@inproceedings{hindle_greenminer:_2014,
	address = {Hyderabad, India},
	title = {{GreenMiner}: a hardware based mining software repositories software energy consumption framework},
	isbn = {978-1-4503-2863-0},
	shorttitle = {{GreenMiner}},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597097},
	doi = {10.1145/2597073.2597097},
	abstract = {Green Mining is a ﬁeld of MSR that studies software energy consumption and relies on software performance data. Unfortunately there is a severe lack of publicly available software power use performance data. This means that green mining researchers must generate this data themselves by writing tests, building multiple revisions of a product, and then running these tests multiple times (10+) for each software revision while measuring power use. Then, they must aggregate these measurements to estimate the energy consumed by the tests for each software revision. This is time consuming and is made more diﬃcult by the constraints of mobile devices and their OSes. In this paper we propose, implement, and demonstrate Green Miner: the ﬁrst dedicated hardware mining software repositories testbed. The Green Miner physically measures the energy consumption of mobile devices (Android phones) and automates the testing of applications, and the reporting of measurements back to developers and researchers. The Green Miner has already produced valuable results for commercial Android application developers, and has been shown to replicate other power studies’ results.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories} - {MSR} 2014},
	publisher = {ACM Press},
	author = {Hindle, Abram and Wilson, Alex and Rasmussen, Kent and Barlow, E. Jed and Campbell, Joshua Charles and Romansky, Stephen},
	year = {2014},
	pages = {12--21},
	file = {Hindle et al. - 2014 - GreenMiner a hardware based mining software repos.pdf:/Users/chakibbelgaid/Zotero newone/storage/GDMPXJID/Hindle et al. - 2014 - GreenMiner a hardware based mining software repos.pdf:application/pdf},
}

@article{colmant_multi-dimensional_nodate,
	title = {Multi-{Dimensional} {Analysis} of {Software} {Power} {Consumptions} in {Multi}-{Core} {Architectures}},
	language = {en},
	author = {Colmant, Maxime},
	pages = {141},
	file = {Colmant - Multi-Dimensional Analysis of Software Power Consu.pdf:/Users/chakibbelgaid/Zotero newone/storage/PHFSCN27/Colmant - Multi-Dimensional Analysis of Software Power Consu.pdf:application/pdf},
}

@inproceedings{jebraeil_guml:_2017,
	address = {Honolulu, HI, USA},
	title = {{gUML}: {Reasoning} about {Energy} at {Design} {Time} by {Extending} {UML} {Deployment} {Diagrams} with {Data} {Centre} {Contextual} {Information}},
	isbn = {978-1-5386-2002-1},
	shorttitle = {{gUML}},
	url = {http://ieeexplore.ieee.org/document/8036722/},
	doi = {10.1109/SERVICES.2017.19},
	abstract = {With the rising energy demand in ICT services and its associated environmental impact, the need for energy efﬁcient Enterprise ICT solutions is growing. As data centres account for a large part of energy consumption in ICT, data centre operators strive to create opportunities to put more emphasis on reducing energy consumption. However, creating ICT Systems that are energy efﬁcient by design remains a key challenge. In this paper, we identify and map contextual energy information about data centre operations in order to model their power related components. This contextual modelling is then mapped to deployment diagram where we introduce greenUML (gUML), an extension to UML diagrams to improve energy efﬁciency through energy analysis at design time. gUML will allow system architects to reason about the energy footprint of their applications at design time.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2017 {IEEE} {World} {Congress} on {Services} ({SERVICES})},
	publisher = {IEEE},
	author = {Jebraeil, Nigar and Noureddine, Adel and Doyle, Joseph and Islam, Syed and Bashroush, Rabih},
	month = jun,
	year = {2017},
	pages = {59--66},
	file = {Jebraeil et al. - 2017 - gUML Reasoning about Energy at Design Time by Ext.pdf:/Users/chakibbelgaid/Zotero newone/storage/93KVI8JT/Jebraeil et al. - 2017 - gUML Reasoning about Energy at Design Time by Ext.pdf:application/pdf},
}

@article{noureddine_monitoring_2015,
	title = {Monitoring energy hotspots in software: {Energy} profiling of software code},
	volume = {22},
	issn = {0928-8910, 1573-7535},
	shorttitle = {Monitoring energy hotspots in software},
	url = {http://link.springer.com/10.1007/s10515-014-0171-1},
	doi = {10.1007/s10515-014-0171-1},
	abstract = {Green IT has emerged as a discipline concerned with the optimization of software solutions with regards to their energy consumption. In this domain, most of the state-of-the-art solutions concentrate on coarse-grained approaches to monitor the energy consumption of a device or a process. In this paper, we report on a ﬁnegrained runtime energy monitoring framework we developed to help developers to diagnose energy hotspots with a better accuracy. Concretely, our approach adopts a two-layer architecture including OS-level and process-level energy monitoring. OSlevel energy monitoring estimates the energy consumption of processes according to different hardware devices (CPU, network card). Process-level energy monitoring focuses on Java-based applications and builds on OS-level energy monitoring to provide an estimation of energy consumption at the granularity of classes and methods. We argue that this per-method analysis of energy consumption provides better insights to the application in order to identify potential energy hotspots. In particular, our preliminary validation demonstrates that we can monitor energy hotspots of Jetty web servers and monitor their variations under stress scenarios.},
	language = {en},
	number = {3},
	urldate = {2018-11-07},
	journal = {Automated Software Engineering},
	author = {Noureddine, Adel and Rouvoy, Romain and Seinturier, Lionel},
	month = sep,
	year = {2015},
	pages = {291--332},
	file = {Noureddine et al. - 2015 - Monitoring energy hotspots in software Energy pro.pdf:/Users/chakibbelgaid/Zotero newone/storage/M72IVD3F/Noureddine et al. - 2015 - Monitoring energy hotspots in software Energy pro.pdf:application/pdf},
}

@inproceedings{sahin_how_2014,
	address = {Torino, Italy},
	title = {How do code refactorings affect energy usage?},
	isbn = {978-1-4503-2774-9},
	url = {http://dl.acm.org/citation.cfm?doid=2652524.2652538},
	doi = {10.1145/2652524.2652538},
	abstract = {Method: We conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly-used refactorings.
Results: We found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application. In addition, we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring.
Conclusion: The results from this and similar studies could be used to augment IDEs to help software developers build more energy eﬃcient software.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 8th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement} - {ESEM} '14},
	publisher = {ACM Press},
	author = {Sahin, Cagri and Pollock, Lori and Clause, James},
	year = {2014},
	pages = {1--10},
	file = {Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf:/Users/chakibbelgaid/Zotero newone/storage/9X2B5HGJ/Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf:application/pdf},
}

@inproceedings{schulte_post-compiler_2014,
	address = {Salt Lake City, Utah, USA},
	title = {Post-compiler software optimization for reducing energy},
	isbn = {978-1-4503-2305-5},
	url = {http://dl.acm.org/citation.cfm?doid=2541940.2541980},
	doi = {10.1145/2541940.2541980},
	abstract = {Modern compilers typically optimize for executable size and speed, rarely exploring non-functional properties such as power efﬁciency. These properties are often hardwarespeciﬁc, time-intensive to optimize, and may not be amenable to standard dataﬂow optimizations. We present a general post-compilation approach called Genetic Optimization Algorithm (GOA), which targets measurable non-functional aspects of software execution in programs that compile to x86 assembly. GOA combines insights from proﬁle-guided optimization, superoptimization, evolutionary computation and mutational robustness. GOA searches for program variants that retain required functional behavior while improving non-functional behavior, using characteristic workloads and predictive modeling to guide the search. The resulting optimizations are validated using physical performance measurements and a larger held-out test suite. Our experimental results on PARSEC benchmark programs show average energy reductions of 20\%, both for a large AMD system and a small Intel system, while maintaining program functionality on target workloads.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 19th international conference on {Architectural} support for programming languages and operating systems - {ASPLOS} '14},
	publisher = {ACM Press},
	author = {Schulte, Eric and Dorn, Jonathan and Harding, Stephen and Forrest, Stephanie and Weimer, Westley},
	year = {2014},
	pages = {639--652},
	file = {Schulte et al. - 2014 - Post-compiler software optimization for reducing e.pdf:/Users/chakibbelgaid/Zotero newone/storage/AU5DFXZF/Schulte et al. - 2014 - Post-compiler software optimization for reducing e.pdf:application/pdf},
}

@inproceedings{pereira_influence_2016,
	address = {Austin, Texas},
	title = {The influence of the {Java} collection framework on overall energy consumption},
	isbn = {978-1-4503-4161-5},
	url = {http://dl.acm.org/citation.cfm?doid=2896967.2896968},
	doi = {10.1145/2896967.2896968},
	abstract = {This paper presents a detailed study of the energy consumption of the diﬀerent Java Collection Framework (JFC) implementations. For each method of an implementation in this framework, we present its energy consumption when handling diﬀerent amounts of data. Knowing the greenest methods for each implementation, we present an energy optimization approach for Java programs: based on calls to JFC methods in the source code of a program, we select the greenest implementation. Finally, we present preliminary results of optimizing a set of Java programs where we obtained 6.2\% energy savings.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 5th {International} {Workshop} on {Green} and {Sustainable} {Software} - {GREENS} '16},
	publisher = {ACM Press},
	author = {Pereira, Rui and Couto, Marco and Saraiva, João and Cunha, Jácome and Fernandes, João Paulo},
	year = {2016},
	pages = {15--21},
	file = {Pereira et al. - 2016 - The influence of the Java collection framework on .pdf:/Users/chakibbelgaid/Zotero newone/storage/SZYDE7MP/Pereira et al. - 2016 - The influence of the Java collection framework on .pdf:application/pdf},
}

@article{pang_what_2016,
	title = {What {Do} {Programmers} {Know} about {Software} {Energy} {Consumption}?},
	volume = {33},
	issn = {0740-7459},
	url = {http://ieeexplore.ieee.org/document/7155416/},
	doi = {10.1109/MS.2015.83},
	abstract = {Traditionally, programmers have received a wide range of training on programming languages and methodologies, but rarely about software energy consumption. Yet, the popularity of mobile devices and cloud computing require increased awareness about software energy consumption. On a mobile device, computation is often limited by the battery life. Under the demands of cloud computing, data centers struggle to reduce energy consumption through virtualization and data center infrastructure management (DCIM) systems. Efﬁcient energy consumption of software is increasingly becoming an important non-functional requirement for programmers. However, are programmers knowledgeable enough about software energy consumption? Do programmers base their implementation decision on popular beliefs? In this article, we survey over 100 programmers for their knowledge of software energy consumption. We ﬁnd that programmers have limited knowledge about energy efﬁciency, lack knowledge about the best practices to reduce energy consumption of software, and are often unsure about how software consumes energy. Education about the importance of energy effective software will beneﬁt the programmers. Our results highlight the need for training about energy consumption and efﬁciency.},
	language = {en},
	number = {3},
	urldate = {2018-11-07},
	journal = {IEEE Software},
	author = {Pang, Candy and Hindle, Abram and Adams, Bram and Hassan, Ahmed E.},
	month = may,
	year = {2016},
	pages = {83--89},
	file = {Pang et al. - 2016 - What Do Programmers Know about Software Energy Con.pdf:/Users/chakibbelgaid/Zotero newone/storage/HZRJZZKS/Pang et al. - 2016 - What Do Programmers Know about Software Energy Con.pdf:application/pdf},
}

@book{noauthor_green_2014,
	address = {New York, NY},
	title = {Green in software engineering},
	isbn = {978-3-319-08580-7},
	language = {en},
	publisher = {Springer Berlin Heidelberg},
	year = {2014},
	file = {2014 - Green in software engineering.pdf:/Users/chakibbelgaid/Zotero newone/storage/JBGJ74KU/2014 - Green in software engineering.pdf:application/pdf},
}

@article{hindle_green_2015,
	title = {Green mining: a methodology of relating software change and configuration to power consumption},
	volume = {20},
	issn = {1382-3256, 1573-7616},
	shorttitle = {Green mining},
	url = {http://link.springer.com/10.1007/s10664-013-9276-6},
	doi = {10.1007/s10664-013-9276-6},
	abstract = {Power consumption is becoming more and more important with the increased popularity of smart-phones, tablets and laptops. The threat of reducing a customer’s battery-life now hangs over the software developer, who now asks, “will this next change be the one that causes my software to drain a customer’s battery?” One solution is to detect power consumption regressions by measuring the power usage of tests, but this is time-consuming and often noisy. An alternative is to rely on software metrics that allow us to estimate the impact that a change might have on power consumption thus relieving the developer from expensive testing. This paper presents a general methodology for investigating the impact of software change on power consumption, we relate power consumption to software changes, and then investigate the impact of OO software metrics and churn metrics on power consumption. We demonstrated that software change can effect power consumption using the Firefox web-browser and the Azureus/Vuze BitTorrent client. We found evidence of a potential relationship between some software metrics and power consumption. We also investigate the effect of library versioning on the power consumption of rTorrent. In conclusion, we investigate the effect of software change on power consumption on two projects; and we provide an initial investigation on the impact of software metrics on power consumption.},
	language = {en},
	number = {2},
	urldate = {2018-11-07},
	journal = {Empirical Software Engineering},
	author = {Hindle, Abram},
	month = apr,
	year = {2015},
	pages = {374--409},
	file = {Hindle - 2015 - Green mining a methodology of relating software c.pdf:/Users/chakibbelgaid/Zotero newone/storage/PLEIQQGB/Hindle - 2015 - Green mining a methodology of relating software c.pdf:application/pdf},
}

@inproceedings{yunsi_fei_energy-optimizing_2004,
	address = {Mumbai, India},
	title = {Energy-optimizing source code transformations for {OS}-driven embedded software},
	isbn = {978-0-7695-2072-8},
	url = {http://ieeexplore.ieee.org/document/1260934/},
	doi = {10.1109/ICVD.2004.1260934},
	abstract = {The increasing software content of battery-powered embedded systems has fueled much interest in techniques for developing energyefﬁcient embedded software. Source code transformations have previously been considered for application software to reduce its energy consumption. For complex embedded software applications, which consist of multiple concurrent processes running with the support of an embedded operating system (OS), it is known that the OS and the application-OS interaction signiﬁcantly affect energy consumption. However, source code transformations explicitly targeting these effects have not been sufﬁciently studied.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {17th {International} {Conference} on {VLSI} {Design}. {Proceedings}.},
	publisher = {IEEE Comput. Soc},
	author = {{Yunsi Fei} and Ravi, S. and Raghunathan, A. and Jha, N.K.},
	year = {2004},
	pages = {261--266},
	file = {Yunsi Fei et al. - 2004 - Energy-optimizing source code transformations for .pdf:/Users/chakibbelgaid/Zotero newone/storage/6SK5CHLE/Yunsi Fei et al. - 2004 - Energy-optimizing source code transformations for .pdf:application/pdf},
}

@article{tiwari_instruction_nodate,
	title = {Instruction level power analysis and optimization of software},
	abstract = {The increasing popularity of power constrained mobile computers and embedded computing applications drives the need for analyzing and optimizing power in all the components of a system. Software constitutes a major component of today's systems, and its role is projected to grow even further. Thus, an ever increasing portion of the functionality of today's systems is in the form of instructions, as opposed to gates. This motivates the need for analyzing power consumption from the point of view of instructions--something that traditional circuit and gate level power analysis tools are inadequate for. This paper describes an alternative, measurement based instruction level power analysis approach that provides an accurate and practical way of quantifying the power cost of software. This technique has been applied to three commercial, architecturally different processors. The salient results of these analyses are summarized. Instruction level analysis of a processor helps in the development of models for power consumption of software executing on that processor. The power models for the subject processors are described and interesting observations resulting from the comparison of these models are highlighted. The ability to evaluate software in terms of power consumption makes it feasible to search for low power implementations of given programs. In addition, it can guide the development of general tools and techniques for low power software. Several ideas in this regard as motivated by the power analysis of the subject processors are also described.},
	language = {en},
	author = {Tiwari, Vivek and Malik, Sharad and Wolfe, Andrew and Lee, Mike Tien-Chien},
	pages = {16},
	file = {Tiwari et al. - Instruction level power analysis and optimization .pdf:/Users/chakibbelgaid/Zotero newone/storage/KMTP2JZ2/Tiwari et al. - Instruction level power analysis and optimization .pdf:application/pdf},
}

@article{selby_unconventional_nodate,
	title = {Unconventional {Applications} of {Compiler} {Analysis}},
	language = {en},
	author = {Selby, Jason},
	pages = {213},
	file = {Selby - Unconventional Applications of Compiler Analysis.pdf:/Users/chakibbelgaid/Zotero newone/storage/PHSX7RUH/Selby - Unconventional Applications of Compiler Analysis.pdf:application/pdf},
}

@inproceedings{penzenstadler_who_2013,
	address = {San Francisco, CA, USA},
	title = {Who is the advocate? {Stakeholders} for sustainability},
	isbn = {978-1-4673-6267-2},
	shorttitle = {Who is the advocate?},
	url = {http://ieeexplore.ieee.org/document/6606424/},
	doi = {10.1109/GREENS.2013.6606424},
	abstract = {While the research community has started working on sustainable software engineering recently, one question that is often asked still remains unanswered: who are the stakeholders? Who are the people who actually have an interest in improving the sustainability of a speciﬁc software system or of the discipline of software engineering itself? And who are the devil’s advocates? Having no explicit stakeholders is a problem as improvement of sustainability is challenging without a driving force. An objective that has no stakeholder is not likely to receive sufﬁcient attention to be realized and will eventually disappear.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2013 2nd {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	publisher = {IEEE},
	author = {Penzenstadler, Birgit and Femmer, Henning and Richardson, Debra},
	month = may,
	year = {2013},
	pages = {70--77},
	file = {Penzenstadler et al. - 2013 - Who is the advocate Stakeholders for sustainabili.pdf:/Users/chakibbelgaid/Zotero newone/storage/I4VIFH8J/Penzenstadler et al. - 2013 - Who is the advocate Stakeholders for sustainabili.pdf:application/pdf},
}

@incollection{chaudron_component-level_2008,
	address = {Berlin, Heidelberg},
	title = {Component-{Level} {Energy} {Consumption} {Estimation} for {Distributed} {Java}-{Based} {Software} {Systems}},
	volume = {5282},
	isbn = {978-3-540-87890-2 978-3-540-87891-9},
	url = {http://link.springer.com/10.1007/978-3-540-87891-9_7},
	abstract = {Efficiency with respect to energy consumption has increasingly been recognized as an important quality attribute for distributed software systems in embedded and pervasive environments. In this paper we present a framework for estimating the energy consumption of distributed software systems implemented in Java. Our primary objective in devising the framework is to enable an engineer to make informed decisions when adapting a system’s architecture, such that the energy consumption on hardware devices with a finite battery life is reduced, and the lifetime of the system’s key software services increases. Our framework explicitly takes a component-based perspective, which renders it well suited for a large class of today’s distributed, embedded, and pervasive applications. The framework allows the engineer to estimate the distributed system’s energy consumption at system construction-time and refine it at runtime. In a large number of distributed application scenarios, the framework showed very good precision on the whole, giving results that were within 5\% (and often less) of the actual energy consumption incurred by executing the software. Our work to date has also highlighted the framework’s practical applications and a number of possible enhancements.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Component-{Based} {Software} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Seo, Chiyoung and Malek, Sam and Medvidovic, Nenad},
	editor = {Chaudron, Michel R. V. and Szyperski, Clemens and Reussner, Ralf},
	year = {2008},
	doi = {10.1007/978-3-540-87891-9_7},
	pages = {97--113},
	file = {Seo et al. - 2008 - Component-Level Energy Consumption Estimation for .pdf:/Users/chakibbelgaid/Zotero newone/storage/AKE8A5BW/Seo et al. - 2008 - Component-Level Energy Consumption Estimation for .pdf:application/pdf},
}

@article{aggarwal_power_nodate,
	title = {The {Power} of {System} {Call} {Traces}: {Predicting} the {Software} {Energy} {Consumption} {Impact} of {Changes}},
	abstract = {Battery is a critical resource for smartphones. Software developers as the builders and maintainers of applications, are responsible for updating and deploying energy efﬁcient applications to end users. Unfortunately, the impact of software change on energy consumption is still unclear. Estimation based on software metrics has proved difﬁcult. As energy consumption proﬁling requires special infrastructure, developers have difﬁculty assessing the impact of their actions on energy consumption. System calls are the interface between applications and the OS kernel and provide insight into how software utilizes hardware and software resources. As proﬁling system calls requires no specialized infrastructure, unlike energy consumption, it is much easier for the developers to track changes to system calls. Thus we relate software change to energy consumption by tracing the changes in an application’s pattern of system call invocations. We ﬁnd that signiﬁcant changes to system call proﬁles often induce signiﬁcant changes in energy consumption.},
	language = {en},
	author = {Aggarwal, Karan and Zhang, Chenlei and Campbell, Joshua Charles and Hindle, Abram and Stroulia, Eleni},
	pages = {15},
	file = {Aggarwal et al. - The Power of System Call Traces Predicting the So.pdf:/Users/chakibbelgaid/Zotero newone/storage/2B4PN3ZD/Aggarwal et al. - The Power of System Call Traces Predicting the So.pdf:application/pdf},
}

@article{vetro_nition_2013,
	title = {Deﬁnition, {Implementation} and {Validation} of {Energy} {Code} {Smells}: an {Exploratory} {Study} on an {Embedded} {System}},
	abstract = {Optimizing software in terms of energy efﬁciency is one of the challenges that both research and industry will have to face in the next few years. We consider energy efﬁciency as a software product quality characteristic, to be improved through the refactoring of appropriate code pattern: the aim of this work is identifying those code patterns, hereby deﬁned as Energy Code Smells, that might increase the impact of software over power consumption. For our purposes, we perform an experiment consisting in the execution of several code patterns on an embedded system. These code patterns are executed in two versions: the ﬁrst one contains a code issue that could negatively impact power consumption, the other one is refactored removing the issue. We measure the power consumption of the embedded device during the execution of each code pattern. We also track the execution time to investigate whether Energy Code Smells are also Performance Smells. Our results show that some Energy Code Smells actually have an impact over power consumption in the magnitude order of micro Watts. Moreover, those Smells did not introduce a performance decrease.},
	language = {en},
	author = {Vetro’, Antonio and Ardito, Luca and Procaccianti, Giuseppe and Morisio, Maurizio},
	year = {2013},
	pages = {7},
	file = {Vetro’ et al. - 2013 - Deﬁnition, Implementation and Validation of Energy.pdf:/Users/chakibbelgaid/Zotero newone/storage/23JUPLST/Vetro’ et al. - 2013 - Deﬁnition, Implementation and Validation of Energy.pdf:application/pdf},
}

@article{katz_report_2018,
	title = {Report on the {Fourth} {Workshop} on {Sustainable} {Software} for {Science}: {Practice} and {Experiences} ({WSSSPE4})},
	volume = {6},
	issn = {2049-9647},
	shorttitle = {Report on the {Fourth} {Workshop} on {Sustainable} {Software} for {Science}},
	url = {http://arxiv.org/abs/1705.02607},
	doi = {10.5334/jors.184},
	abstract = {This report records and discusses the Fourth Workshop on Sustainable Software for Science: Practice and Experiences (WSSSPE4). The report includes a description of the keynote presentation of the workshop, the mission and vision statements that were drafted at the workshop and finalized shortly after it, a set of idea papers, position papers, experience papers, demos, and lightning talks, and a panel discussion. The main part of the report covers the set of working groups that formed during the meeting, and for each, discusses the participants, the objective and goal, and how the objective can be reached, along with contact information for readers who may want to join the group. Finally, we present results from a survey of the workshop attendees.},
	language = {en},
	urldate = {2018-11-07},
	journal = {Journal of Open Research Software},
	author = {Katz, Daniel S. and Niemeyer, Kyle E. and Gesing, Sandra and Hwang, Lorraine and Bangerth, Wolfgang and Hettrick, Simon and Idaszak, Ray and Salac, Jean and Hong, Neil Chue and Corrales, Santiago Núñez and Allen, Alice and Geiger, R. Stuart and Miller, Jonah and Chen, Emily and Dubey, Anshu and Lago, Patricia},
	month = feb,
	year = {2018},
	note = {arXiv: 1705.02607},
	keywords = {Computer Science - Software Engineering},
	file = {Katz et al. - 2018 - Report on the Fourth Workshop on Sustainable Softw.pdf:/Users/chakibbelgaid/Zotero newone/storage/NH6GL3GE/Katz et al. - 2018 - Report on the Fourth Workshop on Sustainable Softw.pdf:application/pdf},
}

@inproceedings{goudarzi_energy-efficient_2012,
	address = {Honolulu, HI, USA},
	title = {Energy-{Efficient} {Virtual} {Machine} {Replication} and {Placement} in a {Cloud} {Computing} {System}},
	isbn = {978-1-4673-2892-0 978-0-7695-4755-8},
	url = {http://ieeexplore.ieee.org/document/6253575/},
	doi = {10.1109/CLOUD.2012.107},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2012 {IEEE} {Fifth} {International} {Conference} on {Cloud} {Computing}},
	publisher = {IEEE},
	author = {Goudarzi, Hadi and Pedram, Massoud},
	month = jun,
	year = {2012},
	pages = {750--757},
	file = {Goudarzi and Pedram - 2012 - Energy-Efficient Virtual Machine Replication and P.pdf:/Users/chakibbelgaid/Zotero newone/storage/6EPDFCIY/Goudarzi and Pedram - 2012 - Energy-Efficient Virtual Machine Replication and P.pdf:application/pdf},
}

@inproceedings{ardito_energy_2013,
	address = {San Francisco, CA, USA},
	title = {Energy aware self-adaptation in mobile systems},
	isbn = {978-1-4673-3076-3 978-1-4673-3073-2},
	url = {http://ieeexplore.ieee.org/document/6606736/},
	doi = {10.1109/ICSE.2013.6606736},
	abstract = {The increasing proliferation of mobile handsets, and the migration of the information access paradigm to mobile platforms, leads researchers to study the energy consumption of this class of devices. The literature still lacks metrics and tools that allow software developers to easily measure and optimize the energy efficiency of their code. Energy efficiency can definitely improve user experience increasing battery life. This paper aims to describe a technique to adapt the execution of a mobile application, based on the actual energy consumption of the device, without using external equipment.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2013 35th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Ardito, Luca},
	month = may,
	year = {2013},
	pages = {1435--1437},
	file = {Ardito - 2013 - Energy aware self-adaptation in mobile systems.pdf:/Users/chakibbelgaid/Zotero newone/storage/AWM6UBNH/Ardito - 2013 - Energy aware self-adaptation in mobile systems.pdf:application/pdf},
}

@article{hsu_design_nodate,
	title = {The {Design}, {Implementation}, and {Evaluation} of a {Compiler} {Algorithm} for {CPU} {Energy} {Reduction}},
	abstract = {This paper presents the design and implementation of a compiler algorithm that eﬀectively optimizes programs for energy usage using dynamic voltage scaling (DVS). The algorithm identiﬁes program regions where the CPU can be slowed down with negligible performance loss. It is implemented as a source-to-source level transformation using the SUIF2 compiler infrastructure. Physical measurements on a high-performance laptop show that total system (i.e., laptop) energy savings of up to 28\% can be achieved with performance degradation of less than 5\% for the SPECfp95 benchmarks. On average, the system energy and energydelay product are reduced by 11\% and 9\%, respectively, with a performance slowdown of 2\%. It was also discovered that the energy usage of the programs using our DVS algorithm is within 6\% from the theoretical lower bound. To the best of our knowledge, this is one of the ﬁrst work that evaluates DVS algorithms by physical measurements.},
	language = {en},
	author = {Hsu, Chung-Hsing and Kremer, Ulrich},
	pages = {11},
	file = {Hsu and Kremer - The Design, Implementation, and Evaluation of a Co.pdf:/Users/chakibbelgaid/Zotero newone/storage/Q24UWZ7Q/Hsu and Kremer - The Design, Implementation, and Evaluation of a Co.pdf:application/pdf},
}

@inproceedings{islam_measuring_2016,
	address = {Austin, TX, USA},
	title = {Measuring energy footprint of software features},
	isbn = {978-1-5090-1428-6},
	url = {http://ieeexplore.ieee.org/document/7503726/},
	doi = {10.1109/ICPC.2016.7503726},
	abstract = {With the proliferation of Software systems and the rise of paradigms such the Internet of Things, CyberPhysical Systems and Smart Cities to name a few, the energy consumed by software applications is emerging as a major concern. Hence, it has become vital that software engineers have a better understanding of the energy consumed by the code they write. At software level, work so far has focused on measuring the energy consumption at function and application level. In this paper, we propose a novel approach to measure energy consumption at a feature level, cross-cutting multiple functions, classes and systems. We argue the importance of such measurement and the new insight it provides to non-traditional stakeholders such as service providers. We then demonstrate, using an experiment, how the measurement can be done with a combination of tools, namely our program slicing tool (PORBS) and energy measurement tool (Jolinar).},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2016 {IEEE} 24th {International} {Conference} on {Program} {Comprehension} ({ICPC})},
	publisher = {IEEE},
	author = {Islam, Syed and Noureddine, Adel and Bashroush, Rabih},
	month = may,
	year = {2016},
	pages = {1--4},
	file = {Islam et al. - 2016 - Measuring energy footprint of software features.pdf:/Users/chakibbelgaid/Zotero newone/storage/TLBIV5UY/Islam et al. - 2016 - Measuring energy footprint of software features.pdf:application/pdf},
}

@inproceedings{bruce_reducing_2015,
	address = {Madrid, Spain},
	title = {Reducing {Energy} {Consumption} {Using} {Genetic} {Improvement}},
	isbn = {978-1-4503-3472-3},
	url = {http://dl.acm.org/citation.cfm?doid=2739480.2754752},
	doi = {10.1145/2739480.2754752},
	abstract = {Genetic Improvement (GI) is an area of Search Based Software Engineering which seeks to improve software’s nonfunctional properties by treating program code as if it were genetic material which is then evolved to produce more optimal solutions. Hitherto, the majority of focus has been on optimising program’s execution time which, though important, is only one of many non-functional targets. The growth in mobile computing, cloud computing infrastructure, and ecological concerns are forcing developers to focus on the energy their software consumes. We report on investigations into using GI to automatically ﬁnd more energy eﬃcient versions of the MiniSAT Boolean satisﬁability solver when specialising for three downstream applications. Our results ﬁnd that GI can successfully be used to reduce energy consumption by up to 25\%.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the 2015 on {Genetic} and {Evolutionary} {Computation} {Conference} - {GECCO} '15},
	publisher = {ACM Press},
	author = {Bruce, Bobby R. and Petke, Justyna and Harman, Mark},
	year = {2015},
	pages = {1327--1334},
	file = {Bruce et al. - 2015 - Reducing Energy Consumption Using Genetic Improvem.pdf:/Users/chakibbelgaid/Zotero newone/storage/BVSYH7FX/Bruce et al. - 2015 - Reducing Energy Consumption Using Genetic Improvem.pdf:application/pdf},
}

@inproceedings{wickremasinghe_cloudanalyst:_2010,
	address = {Perth, Australia},
	title = {{CloudAnalyst}: {A} {CloudSim}-{Based} {Visual} {Modeller} for {Analysing} {Cloud} {Computing} {Environments} and {Applications}},
	isbn = {978-1-4244-6695-5},
	shorttitle = {{CloudAnalyst}},
	url = {http://ieeexplore.ieee.org/document/5474733/},
	doi = {10.1109/AINA.2010.32},
	abstract = {Advances in Cloud computing opens up many new possibilities for Internet applications developers. Previously, a main concern of Internet applications developers was deployment and hosting of applications, because it required acquisition of a server with a fixed capacity able to handle the expected application peak demand and the installation and maintenance of the whole software infrastructure of the platform supporting the application. Furthermore, server was underutilized because peak traffic happens only at specific times. With the advent of the Cloud, deployment and hosting became cheaper and easier with the use of pay-peruse flexible elastic infrastructure services offered by Cloud providers. Because several Cloud providers are available, each one offering different pricing models and located in different geographic regions, a new concern of application developers is selecting providers and data center locations for applications. However, there is a lack of tools that enable developers to evaluate requirements of large-scale Cloud applications in terms of geographic distribution of both computing servers and user workloads. To fill this gap in tools for evaluation and modeling of Cloud environments and applications, we propose CloudAnalyst. It was developed to simulate large-scale Cloud applications with the purpose of studying the behavior of such applications under various deployment configurations. CloudAnalyst helps developers with insights in how to distribute applications among Cloud infrastructures and value added services such as optimization of applications performance and providers incoming with the use of Service Brokers.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {2010 24th {IEEE} {International} {Conference} on {Advanced} {Information} {Networking} and {Applications}},
	publisher = {IEEE},
	author = {Wickremasinghe, Bhathiya and Calheiros, Rodrigo N. and Buyya, Rajkumar},
	year = {2010},
	pages = {446--452},
	file = {Wickremasinghe et al. - 2010 - CloudAnalyst A CloudSim-Based Visual Modeller for.pdf:/Users/chakibbelgaid/Zotero newone/storage/E2GQKU32/Wickremasinghe et al. - 2010 - CloudAnalyst A CloudSim-Based Visual Modeller for.pdf:application/pdf},
}

@inproceedings{hsu_smoothoperator:_2018,
	address = {Williamsburg, VA, USA},
	title = {{SmoothOperator}: {Reducing} {Power} {Fragmentation} and {Improving} {Power} {Utilization} in {Large}-scale {Datacenters}},
	isbn = {978-1-4503-4911-6},
	shorttitle = {{SmoothOperator}},
	url = {http://dl.acm.org/citation.cfm?doid=3173162.3173190},
	doi = {10.1145/3173162.3173190},
	abstract = {With the ever growing popularity of cloud computing and web services, Internet companies are in need of increased computing capacity to serve the demand. However, power has become a major limiting factor prohibiting the growth in industry: it is often the case that no more servers can be added to datacenters without surpassing the capacity of the existing power infrastructure.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the {Twenty}-{Third} {International} {Conference} on {Architectural} {Support} for {Programming} {Languages} and {Operating} {Systems}  - {ASPLOS} '18},
	publisher = {ACM Press},
	author = {Hsu, Chang-Hong and Deng, Qingyuan and Mars, Jason and Tang, Lingjia},
	year = {2018},
	pages = {535--548},
	file = {Hsu et al. - 2018 - SmoothOperator Reducing Power Fragmentation and I.pdf:/Users/chakibbelgaid/Zotero newone/storage/26G3I45L/Hsu et al. - 2018 - SmoothOperator Reducing Power Fragmentation and I.pdf:application/pdf},
}

@inproceedings{wen_watching_2018,
	address = {Williamsburg, VA, USA},
	title = {Watching for {Software} {Inefficiencies} with {Witch}},
	isbn = {978-1-4503-4911-6},
	url = {http://dl.acm.org/citation.cfm?doid=3173162.3177159},
	doi = {10.1145/3173162.3177159},
	abstract = {Inefficiencies abound in complex, layered software. A variety of inefficiencies show up as wasteful memory operations. Many existing tools instrument every load and store instruction to monitor memory, which significantly slows execution and consumes enormously extra memory. Our lightweight framework, Witch, samples consecutive accesses to the same memory location by exploiting two ubiquitous hardware features: the performance monitoring units (PMU) and debug registers. Witch performs no instrumentation. Hence, witchcraft—tools built atop Witch—can detect a variety of software inefficiencies while introducing negligible slowdown and insignificant memory consumption and yet maintaining accuracy comparable to exhaustive instrumentation tools. Witch allowed us to scale our analysis to a large number of code bases. Guided by witchcraft, we detected several performance problems in important code bases; eliminating these inefficiencies resulted in significant speedups.},
	language = {en},
	urldate = {2018-11-07},
	booktitle = {Proceedings of the {Twenty}-{Third} {International} {Conference} on {Architectural} {Support} for {Programming} {Languages} and {Operating} {Systems}  - {ASPLOS} '18},
	publisher = {ACM Press},
	author = {Wen, Shasha and Liu, Xu and Byrne, John and Chabbi, Milind},
	year = {2018},
	pages = {332--347},
	file = {Wen et al. - 2018 - Watching for Software Inefficiencies with Witch.pdf:/Users/chakibbelgaid/Zotero newone/storage/79RUJ5VJ/Wen et al. - 2018 - Watching for Software Inefficiencies with Witch.pdf:application/pdf},
}

@article{moghaddam_energy-efficient_2015,
	title = {Energy-{Efficient} {Networking} {Solutions} in {Cloud}-{Based} {Environments}: {A} {Systematic} {Literature} {Review}},
	volume = {47},
	issn = {03600300},
	shorttitle = {Energy-{Efficient} {Networking} {Solutions} in {Cloud}-{Based} {Environments}},
	url = {http://dl.acm.org/citation.cfm?doid=2775083.2764464},
	doi = {10.1145/2764464},
	language = {en},
	number = {4},
	urldate = {2018-07-23},
	journal = {ACM Computing Surveys},
	author = {Moghaddam, Fahimeh Alizadeh and Lago, Patricia and Grosso, Paola},
	month = may,
	year = {2015},
	pages = {1--32},
	file = {Moghaddam et al. - 2015 - Energy-Efficient Networking Solutions in Cloud-Bas.pdf:/Users/chakibbelgaid/Zotero newone/storage/R9YW3DGM/Moghaddam et al. - 2015 - Energy-Efficient Networking Solutions in Cloud-Bas.pdf:application/pdf},
}

@inproceedings{pinto_mining_2014,
	address = {Hyderabad, India},
	title = {Mining questions about software energy consumption},
	isbn = {978-1-4503-2863-0},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597110},
	doi = {10.1145/2597073.2597110},
	abstract = {A growing number of software solutions have been proposed to address application-level energy consumption problems in the last few years. However, little is known about how much software developers are concerned about energy consumption, what aspects of energy consumption they consider important, and what solutions they have in mind for improving energy eﬃciency. In this paper we present the ﬁrst empirical study on understanding the views of application programmers on software energy consumption problems. Using StackOverflow as our primary data source, we analyze a carefully curated sample of more than 300 questions and 550 answers from more than 800 users. With this data, we observed a number of interesting ﬁndings. Our study shows that practitioners are aware of the energy consumption problems: the questions they ask are not only diverse – we found 5 main themes of questions – but also often more interesting and challenging when compared to the control question set. Even though energy consumption-related questions are popular when considering a number of diﬀerent popularity measures, the same cannot be said about the quality of their answers. In addition, we observed that some of these answers are often ﬂawed or vague. We contrast the advice provided by these answers with the state-of-the-art research on energy consumption. Our summary of software energy consumption problems may help researchers focus on what matters the most to software developers and end users.},
	language = {en},
	urldate = {2018-11-06},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories} - {MSR} 2014},
	publisher = {ACM Press},
	author = {Pinto, Gustavo and Castor, Fernando and Liu, Yu David},
	year = {2014},
	pages = {22--31},
	file = {Pinto et al. - 2014 - Mining questions about software energy consumption.pdf:/Users/chakibbelgaid/Zotero newone/storage/LIUZWNCU/Pinto et al. - 2014 - Mining questions about software energy consumption.pdf:application/pdf},
}

@inproceedings{pinto_artifacts_2016,
	address = {Raleigh, NC, USA},
	title = {Artifacts for “{A} {Comprehensive} {Study} on the {Energy} {Efficiency} of {Java}’s {Thread}-{Safe} {Collections}”},
	isbn = {978-1-5090-3806-0},
	url = {http://ieeexplore.ieee.org/document/7816523/},
	doi = {10.1109/ICSME.2016.86},
	language = {en},
	urldate = {2018-11-06},
	booktitle = {2016 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	publisher = {IEEE},
	author = {Pinto, Gustavo and Liu, Kenan and Castor, Fernando and Liu, Yu David},
	month = oct,
	year = {2016},
	pages = {614--615},
	file = {Pinto et al. - 2016 - Artifacts for “A Comprehensive Study on the Energy.pdf:/Users/chakibbelgaid/Zotero newone/storage/XHFS8A23/Pinto et al. - 2016 - Artifacts for “A Comprehensive Study on the Energy.pdf:application/pdf},
}

@inproceedings{kurpicz_how_2016,
	address = {Heraklion},
	title = {How {Much} {Does} a {VM} {Cost}? {Energy}-{Proportional} {Accounting} in {VM}-{Based} {Environments}},
	isbn = {978-1-4673-8776-7},
	shorttitle = {How {Much} {Does} a {VM} {Cost}?},
	url = {http://ieeexplore.ieee.org/document/7445404/},
	doi = {10.1109/PDP.2016.70},
	abstract = {The costs of current data centers are mostly driven by their energy consumption (speciﬁcally by the air conditioning, computing and networking infrastructure). Yet, current pricing models are usually static and rarely consider the facilities’ energy consumption per user. The challenge is to provide a fair and predictable model to attribute the overall energy costs per virtual machine (VM). Current pay-as-you-go models of Cloud providers allow users to easily know how much their computing will cost. However, this model is not fully transparent as to where the costs come from (e.g., energy). In this paper we introduce EPAVE, a model for Energy-Proportional Accounting in VMbased Environments. EPAVE allows transparent, reproducible and predictive cost calculation for users and for Cloud providers. We show these characteristics of EPAVE by a number of use cases in heterogeneous data centers and discuss the applicability of EPAVE.},
	language = {en},
	urldate = {2021-06-28},
	booktitle = {2016 24th {Euromicro} {International} {Conference} on {Parallel}, {Distributed}, and {Network}-{Based} {Processing} ({PDP})},
	publisher = {IEEE},
	author = {Kurpicz, Mascha and Orgerie, Anne-Cecile and Sobe, Anita},
	month = feb,
	year = {2016},
	pages = {651--658},
	file = {Kurpicz et al. - 2016 - How Much Does a VM Cost Energy-Proportional Accou.pdf:/Users/chakibbelgaid/Zotero newone/storage/KP6W8Q7Z/Kurpicz et al. - 2016 - How Much Does a VM Cost Energy-Proportional Accou.pdf:application/pdf},
}

@article{schuler_mining_2021,
	title = {Mining {API} {Interactions} to {Analyze} {Software} {Revisions} for the {Evolution} of {Energy} {Consumption}},
	url = {http://arxiv.org/abs/2103.11377},
	abstract = {With the widespread use and adoption of mobile platforms like Android a new software quality concern has emerged – energy consumption. However, developing energyefﬁcient software and applications requires knowledge and likewise proper tooling to support mobile developers. To this aim, we present an approach to examine the energy evolution of software revisions based on their API interactions. The approach stems from the assumption that the utilization of an API has direct implications on the energy being consumed during runtime. Based on an empirical evaluation, we show initial results that API interactions serve as a ﬂexible, lightweight, and effective way to compare software revisions regarding their energy evolution. Given our initial results we envision that in future using our approach mobile developers will be able to gain insights on the energy implications of changes in source code in the course of the software development life-cycle.},
	language = {en},
	urldate = {2021-06-25},
	journal = {arXiv:2103.11377 [cs]},
	author = {Schuler, Andreas and Kotsis, Gabriele},
	month = mar,
	year = {2021},
	note = {arXiv: 2103.11377},
	keywords = {Computer Science - Software Engineering},
	file = {Schuler and Kotsis - 2021 - Mining API Interactions to Analyze Software Revisi.pdf:/Users/chakibbelgaid/Zotero newone/storage/F7S59VH8/Schuler and Kotsis - 2021 - Mining API Interactions to Analyze Software Revisi.pdf:application/pdf},
}

@article{mancebo_does_2021,
	title = {Does maintainability relate to the energy consumption of software? {A} case study},
	volume = {29},
	issn = {0963-9314, 1573-1367},
	shorttitle = {Does maintainability relate to the energy consumption of software?},
	url = {http://link.springer.com/10.1007/s11219-020-09536-9},
	doi = {10.1007/s11219-020-09536-9},
	abstract = {Energy consumption of software has been becoming increasingly significant, since it can vary according to how the software has been developed. In recent years, developers and researchers have been interested in analyzing, among other things, how energy consumption evolves when changes occur from one version to another in any given software. Thus far, the only studies available are theoretical papers that reinforce the idea that maintainability may have an influence on energy use, but this needs to be proven empirically, which is the goal of this article. This work presents an empirical study carried out to test whether there is a relationship between the energy consumption and the maintainability of several versions of Redmine. Maintainability has been assessed by means of different measures, such as the number of lines of code, or the complexity of the software, calculated using SonarCloud, and the energy consumption measurements have been captured using the EET device. The results obtained show that the number of lines of code affects both the energy consumption of the processor and the total consumption of the computer where the software is run. It is intended that the results from this work should serve as a basis for the undertaking of new empirical studies which will enable the relationship between the software maintainability and the energy efficiency of that software to be better understood.},
	language = {en},
	number = {1},
	urldate = {2021-06-25},
	journal = {Software Quality Journal},
	author = {Mancebo, Javier and Calero, Coral and García, Félix},
	month = mar,
	year = {2021},
	pages = {101--127},
	file = {Mancebo et al. - 2021 - Does maintainability relate to the energy consumpt.pdf:/Users/chakibbelgaid/Zotero newone/storage/ZTZCAEC7/Mancebo et al. - 2021 - Does maintainability relate to the energy consumpt.pdf:application/pdf},
}

@article{mishra_energy-efficient_2018,
	title = {Energy-efficient {VM}-placement in cloud data center},
	volume = {20},
	issn = {22105379},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S2210537917302536},
	doi = {10.1016/j.suscom.2018.01.002},
	language = {en},
	urldate = {2021-06-25},
	journal = {Sustainable Computing: Informatics and Systems},
	author = {Mishra, Sambit Kumar and Puthal, Deepak and Sahoo, Bibhudatta and Jayaraman, Prem Prakash and Jun, Song and Zomaya, Albert Y. and Ranjan, Rajiv},
	month = dec,
	year = {2018},
	pages = {48--55},
	file = {Mishra et al. - 2018 - Energy-efficient VM-placement in cloud data center.pdf:/Users/chakibbelgaid/Zotero newone/storage/8MY6WLPU/Mishra et al. - 2018 - Energy-efficient VM-placement in cloud data center.pdf:application/pdf},
}

@article{kansal_joulemeter_2009,
	title = {Joulemeter: {Virtual} {Machine} {Power} {Measurement} and {Management}},
	abstract = {The importance of power management has led to most new servers providing power usage measurement in hardware and alternate solutions exist for older servers using circuit and outlet level measurements. However, the power measurement and management capability is severely handicapped when the servers are virtualized because virtual machine (VM) power cannot be measured purely in hardware. We present a solution for VM power metering. We use low-overhead power models to infer power consumption from resource usage at runtime and identify the challenges that arise when applying such models for VM power metering. We show how existing instrumentation in server hardware and hypervisors can be used to build the required power models on real platforms with low error. The entire metering approach is designed to operate with extremely low runtime overhead while providing practically useful accuracy. We illustrate the use of the proposed metering capability for VM power capping leading to signiﬁcant savings in power provisioning costs that constitute a large fraction of data center power costs. Experiments are performed on server traces from several thousand production servers, hosting real-world applications used by millions of users worldwide. The results show that not only the savings that were earlier achieved using physical server power capping can be reclaimed on virtualized platforms, but further savings in provisioning costs are enabled due to virtualization.},
	language = {en},
	author = {Kansal, Aman and Zhao, Feng and Kothari, Nupur and Bhattacharya, Arka},
	year = {2009},
	pages = {12},
	file = {Kansal et al. - Joulemeter Virtual Machine Power Measurement and .pdf:/Users/chakibbelgaid/Zotero newone/storage/DAXKTMJ3/Kansal et al. - Joulemeter Virtual Machine Power Measurement and .pdf:application/pdf},
}

@techreport{bedard_powermon_2009,
	title = {{PowerMon} 2: {Fine}-grained, {Integrated} {Power} {Measurement}},
	abstract = {We describe version 2 of RENCI PowerMon, a device that can be inserted between a computer power supply and the computer’s main board to measure power usage at each of the DC power rails supplying the board. PowerMon 2 provides a capability to collect accurate, frequent, and time-correlated measurements. Since the measurements occur after the AC power supply, this approach eliminates power supply efﬁciency and time-domain ﬁltering perturbations of the power measurements. PowerMon 2 provides detail about the power consumption of the hardware subsystems connected to each of its eight measurement channles. The device ﬁts in an internal 3.5” hard disk drive bay, thus allowing it to be used in a 1U server chassis. It cost less than \$150 per unit to fabricate our small quantity of prototypes.},
	language = {en},
	author = {Bedard, Daniel and Fowler, Robert},
	year = {2009},
	pages = {16},
	file = {Bedard and Fowler - PowerMon 2 Fine-grained, Integrated Power Measure.pdf:/Users/chakibbelgaid/Zotero newone/storage/ZRMTWB2M/Bedard and Fowler - PowerMon 2 Fine-grained, Integrated Power Measure.pdf:application/pdf},
}

@phdthesis{colmant_multi-dimensional_nodate-1,
	title = {Multi-{Dimensional} {Analysis} of {Software} {Power} {Consumptions} in {Multi}-{Core} {Architectures}},
	language = {en},
	author = {Colmant, Maxime},
	file = {Colmant - Multi-Dimensional Analysis of Software Power Consu.pdf:/Users/chakibbelgaid/Zotero newone/storage/QPNG4LET/Colmant - Multi-Dimensional Analysis of Software Power Consu.pdf:application/pdf},
}

@inproceedings{rocha_comprehending_2019,
	address = {Porto de Galinhas, Recife, Brazil},
	title = {Comprehending {Energy} {Behaviors} of {Java} {I}/{O} {APIs}},
	isbn = {978-1-72812-968-6},
	url = {https://ieeexplore.ieee.org/document/8870158/},
	doi = {10.1109/ESEM.2019.8870158},
	abstract = {Background: APIs that implement I/O operations are the building blocks of many well-known, non-trivial software systems. These APIs are used for a great variety of programming tasks, from simple ﬁle management operations, to database communications and implementation of network protocols. Aims: Despite their ubiquity, there are few studies that focus on comprehending their energy behaviors in order to aid developers interested in building energy-conscious software systems. The goal of this work is two-fold. We ﬁrst aim to characterize the landscape of the Java I/O programming APIs. After better comprehending their energy variations, our second goal is to refactor software systems that use energy inefﬁcient I/O APIs to their efﬁcient counterparts. Method: To achieve the ﬁrst goal, we instrumented 22 Java micro-benchmarks that perform I/O operations. To achieve our second goal, we extensively experimented with three benchmarks already optimized for performance and ﬁve macro-benchmarks widely used in both software development practice and in software engineering optimization research. Results: Among the results, we found that the energy behavior of Java I/O APIs is diverse. In particular, popular I/O APIs are not always the most energy efﬁcient ones. Moreover, we were able to create 22 refactored versions of the studied benchmarks, eight of which were more energy efﬁcient than the original version. The (statistically signiﬁcant) energy savings of the refactored versions varied from 0.87\% up to 17.19\%. More importantly, these energy savings stem from very simple refactorings (often touching less than ﬁve lines of code). Conclusions: Our work indicates that there is ample room for studies targeting energy optimization of Java I/O APIs.},
	language = {en},
	urldate = {2021-04-15},
	booktitle = {2019 {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement} ({ESEM})},
	publisher = {IEEE},
	author = {Rocha, Gilson and Castor, Fernando and Pinto, Gustavo},
	month = sep,
	year = {2019},
	pages = {1--12},
	file = {Rocha et al. - 2019 - Comprehending Energy Behaviors of Java IO APIs.pdf:/Users/chakibbelgaid/Zotero newone/storage/RMP3BDH4/Rocha et al. - 2019 - Comprehending Energy Behaviors of Java IO APIs.pdf:application/pdf},
}

@article{karabyn_performance_nodate,
	title = {Performance and scalability analysis of {Java} {IO} and {NIO} based server models, their implementation and comparison},
	abstract = {This thesis focuses on the scalability and performance analysis of the web applications built with the IO packages present in the Java programming language. One of the objectives is to compare the thread-oriented and event-driven models and examine the implications of using them in Java IO and NIO-based systems. Three types of concurrency strategies are proposed for dealing with blocking and non-blocking IO and then applied in practice to build a chat engine. Results of the experiments show that in the case of active long-lived connections the difference in throughput between Java IO and NIO is marginal. However, NIO has an edge when it comes to large amounts of simultaneous connections and offers minimal memory consumption.},
	language = {en},
	author = {Karabyn, Petro},
	pages = {59},
	file = {Karabyn - Performance and scalability analysis of Java IO an.pdf:/Users/chakibbelgaid/Zotero newone/storage/UALTIRXX/Karabyn - Performance and scalability analysis of Java IO an.pdf:application/pdf},
}

@techreport{the_shift_project_lean_2019,
	title = {Lean {ICT} - {Towards} {Digital} {Sobriety}},
	url = {https://theshiftproject.org/wp-content/uploads/2019/03/Lean-ICT-Report_The-Shift-Project_2019.pdf},
	language = {English},
	author = {{The shift Project}},
	month = mar,
	year = {2019},
	pages = {90},
	file = {_.pdf:/Users/chakibbelgaid/Zotero newone/storage/7IRN69U5/_.pdf:application/pdf},
}

@article{alves_experiments_nodate,
	title = {Experiments on {Model}-{Based} {Software} {Energy} {Consumption} {Analysis}},
	abstract = {Although energy has become a concern in software development, little support exists for creating energy-efﬁcient programs. We present the results of some experiments involving collecting energy information, modelling energy consumption, and analysing the costs of executing certain parts of the code. We combine and/or extend some existing free and open-source tools to carry out the experiments. Our experiments consider a comparison of energy consumption of a Java implementation of the Selection Sort algorithm using different data structures, and show how to combine an energy measurement tool and a model analysis tool. Based on this support and on our experiments, we believe developers could take a ﬁrst step to creating more energy-efﬁcient software.},
	language = {en},
	author = {Alves, Danilo S and Duarte, Lucio M and Silva, Davi and Maia, Paulo H M},
	pages = {8},
	file = {Alves et al. - Experiments on Model-Based Software Energy Consump.pdf:/Users/chakibbelgaid/Zotero newone/storage/TZFSV2CI/Alves et al. - Experiments on Model-Based Software Energy Consump.pdf:application/pdf},
}

@phdthesis{pinto_2015-a_refactoring_approach_to_improve_energy_consumption_of_parallel_software_systems.pdf_2015,
	type = {Thesis},
	title = {2015-{A}\_Refactoring\_Approach\_to\_Improve\_Energy\_Consumption\_of\_Parallel\_Software\_Systems.pdf},
	url = {https://repositorio.ufpe.br/handle/123456789/16346},
	school = {Universidade Federal de Pernambuco},
	author = {Pinto, Gustavo},
	month = feb,
	year = {2015},
	keywords = {Read},
	file = {2015-A_Refactoring_Approach_to_Improve_Energy_Consumption_of_Parallel_Software_Systems.pdf:/Users/chakibbelgaid/Zotero newone/storage/5EW9JBNB/2015-A_Refactoring_Approach_to_Improve_Energy_Consumption_of_Parallel_Software_Systems.pdf:application/pdf},
}

@inproceedings{cruz_performance-based_2017,
	address = {Buenos Aires, Argentina},
	title = {Performance-{Based} {Guidelines} for {Energy} {Efficient} {Mobile} {Applications}},
	isbn = {978-1-5386-2669-6},
	url = {http://ieeexplore.ieee.org/document/7972717/},
	doi = {10.1109/MOBILESoft.2017.19},
	abstract = {Mobile and wearable devices are nowadays the de facto personal computers, while desktop computers are becoming less popular. Therefore, it is important for companies to deliver efﬁcient mobile applications. As an example, Google has published a set of best practices to optimize the performance of Android applications. However, these guidelines fall short to address energy consumption. As mobile software applications operate in resource-constrained environments, guidelines to build energy efﬁcient applications are of utmost importance. In this paper, we studied whether or not eight best performance-based practices have an impact on the energy consumed by Android applications. In an experimental study with six popular mobile applications, we observed that the battery of the mobile device can last up to approximately an extra hour if the applications are developed with energy-aware practices. This work paves the way for a set of guidelines for energy-aware automatic refactoring techniques.},
	language = {en},
	urldate = {2020-08-26},
	booktitle = {2017 {IEEE}/{ACM} 4th {International} {Conference} on {Mobile} {Software} {Engineering} and {Systems} ({MOBILESoft})},
	publisher = {IEEE},
	author = {Cruz, Luis and Abreu, Rui},
	month = may,
	year = {2017},
	pages = {46--57},
	file = {Cruz and Abreu - 2017 - Performance-Based Guidelines for Energy Efficient .pdf:/Users/chakibbelgaid/Zotero newone/storage/BMRVSL2B/Cruz and Abreu - 2017 - Performance-Based Guidelines for Energy Efficient .pdf:application/pdf},
}

@inproceedings{cruz_performance-based_2017-1,
	address = {Buenos Aires, Argentina},
	title = {Performance-{Based} {Guidelines} for {Energy} {Efficient} {Mobile} {Applications}},
	isbn = {978-1-5386-2669-6},
	url = {http://ieeexplore.ieee.org/document/7972717/},
	doi = {10.1109/MOBILESoft.2017.19},
	abstract = {Mobile and wearable devices are nowadays the de facto personal computers, while desktop computers are becoming less popular. Therefore, it is important for companies to deliver efﬁcient mobile applications. As an example, Google has published a set of best practices to optimize the performance of Android applications. However, these guidelines fall short to address energy consumption. As mobile software applications operate in resource-constrained environments, guidelines to build energy efﬁcient applications are of utmost importance. In this paper, we studied whether or not eight best performance-based practices have an impact on the energy consumed by Android applications. In an experimental study with six popular mobile applications, we observed that the battery of the mobile device can last up to approximately an extra hour if the applications are developed with energy-aware practices. This work paves the way for a set of guidelines for energy-aware automatic refactoring techniques.},
	language = {en},
	urldate = {2020-08-26},
	booktitle = {2017 {IEEE}/{ACM} 4th {International} {Conference} on {Mobile} {Software} {Engineering} and {Systems} ({MOBILESoft})},
	publisher = {IEEE},
	author = {Cruz, Luis and Abreu, Rui},
	month = may,
	year = {2017},
	pages = {46--57},
	file = {Cruz and Abreu - 2017 - Performance-Based Guidelines for Energy Efficient .pdf:/Users/chakibbelgaid/Zotero newone/storage/LIDQ33LA/Cruz and Abreu - 2017 - Performance-Based Guidelines for Energy Efficient .pdf:application/pdf},
}

@inproceedings{moreira_overviewing_2020,
	address = {Porto Portugal},
	title = {Overviewing the liveness of refactoring for energy efficiency},
	isbn = {978-1-4503-7507-8},
	url = {https://dl.acm.org/doi/10.1145/3397537.3397538},
	doi = {10.1145/3397537.3397538},
	abstract = {Mobile device users have been growing in the last years but the limited battery life of these devices is considered one of the major issues amongst users and programmers. Therefore, there is a need to guide developers in developing mobile applications in the most energy efficient way. One of the ways to improve this is to provide live feedback about the energy efficiency of a program while it’s being programmed. We have analyzed and compared a total of 16 different tools and presented a list of 15 code smells and respective refactorings. From the analyzed tools, Leafactor is the closest to a valid solution to our problem because it’s the only energy-aware tool with the highest liveness level. However, in order to be executed the programmer needs to trigger it on the IDE by selecting the file, instead of automatically being executed without the programmer being noticed and refactor his inefficient code.},
	language = {en},
	urldate = {2020-08-25},
	booktitle = {Conference {Companion} of the 4th {International} {Conference} on {Art}, {Science}, and {Engineering} of {Programming}},
	publisher = {ACM},
	author = {Moreira, Emanuel and Correia, Filipe F. and Bispo, João},
	month = mar,
	year = {2020},
	pages = {211--212},
	file = {Moreira et al. - 2020 - Overviewing the liveness of refactoring for energy.pdf:/Users/chakibbelgaid/Zotero newone/storage/QY53YDZH/Moreira et al. - 2020 - Overviewing the liveness of refactoring for energy.pdf:application/pdf},
}

@inproceedings{rodriguez_reducing_2017,
	address = {Buenos Aires, Argentina},
	title = {Reducing {Energy} {Consumption} of {Resource}-{Intensive} {Scientific} {Mobile} {Applications} via {Code} {Refactoring}},
	isbn = {978-1-5386-1589-8},
	url = {http://ieeexplore.ieee.org/document/7965391/},
	doi = {10.1109/ICSE-C.2017.33},
	abstract = {The advent of new computing paradigms such as Mobile Grids and Mobile-edge Clouds, and the increasing number of mobile devices with ever-growing capabilities makes them attractive to users running scientiﬁc and HPC applications. However, mobile devices still have limited capabilities when compared to non-mobile devices. More importantly, mobile devices rely on batteries for their power supply. To overcome this problem, this PhD research studies how to reduce energy consumption in mobile devices via code refactoring for such kind of applications.},
	language = {en},
	urldate = {2020-08-25},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	publisher = {IEEE},
	author = {Rodriguez, Ana},
	month = may,
	year = {2017},
	pages = {475--476},
	file = {Rodriguez - 2017 - Reducing Energy Consumption of Resource-Intensive .pdf:/Users/chakibbelgaid/Zotero newone/storage/2Y8JGKE9/Rodriguez - 2017 - Reducing Energy Consumption of Resource-Intensive .pdf:application/pdf},
}

@article{gottschalk_energy-efficient_2013,
	title = {Energy-{Efficient} {Code} by {Refactoring}},
	volume = {33},
	issn = {0720-8928},
	url = {http://link.springer.com/10.1007/s40568-013-0030-4},
	doi = {10.1007/s40568-013-0030-4},
	abstract = {The rising number of mobile devices increase the interest in longer battery durations. To increase battery duration, researchers try to improve e.g. diﬀerent hardware components, such as processors and GPS for lower energy consumption. Frequently, software optimization possibilities to save energy are forgotten. Hence, an approach is shown to reduce energy consumption of applications by reengineering. Therefor, energy-wasteful code in applications is searched by code analysis and then restructured to optimize their energy consumption. Energy savings are validated by diﬀerent energy measurements techniques.},
	language = {en},
	number = {2},
	urldate = {2020-08-25},
	journal = {Softwaretechnik-Trends},
	author = {Gottschalk, Marion and Jelschen, Jan and Winter, Andreas},
	month = may,
	year = {2013},
	pages = {23--24},
	file = {Gottschalk et al. - 2013 - Energy-Efficient Code by Refactoring.pdf:/Users/chakibbelgaid/Zotero newone/storage/SVAICHAI/Gottschalk et al. - 2013 - Energy-Efficient Code by Refactoring.pdf:application/pdf},
}

@article{morales_earmo_nodate,
	title = {{EARMO}: {An} {Energy}-{Aware} {Refactoring} {Approach} for {Mobile} {Apps}},
	abstract = {With millions of smartphones sold every year, the development of mobile apps has grown substantially. The battery power limitation of mobile devices has push developers and researchers to search for methods to improve the energy efficiency of mobile apps. We propose a multiobjective refactoring approach to automatically improve the architecture of mobile apps, while controlling for energy efficiency. In this extended abstract we briefly summarize our work.},
	language = {en},
	author = {Morales, Rodrigo and Saborido, Rubén and Khomh, Foutse and Chicano, Francisco and Antoniol, Giuliano},
	pages = {1},
	file = {Morales et al. - EARMO An Energy-Aware Refactoring Approach for Mo.pdf:/Users/chakibbelgaid/Zotero newone/storage/MZFCICXL/Morales et al. - EARMO An Energy-Aware Refactoring Approach for Mo.pdf:application/pdf},
}

@article{longo_reducing_2019,
	title = {Reducing energy usage in resource-intensive {Java}-based scientific applications via micro-benchmark based code refactorings},
	volume = {16},
	issn = {1820-0214, 2406-1018},
	url = {http://www.doiserbia.nb.rs/Article.aspx?ID=1820-02141900009L},
	doi = {10.2298/CSIS180608009L},
	abstract = {In-silico research has grown considerably. Today’s scientific code involves long-running computer simulations and hence powerful computing infrastructures are needed. Traditionally, research in high-performance computing has focused on executing code as fast as possible, while energy has been recently recognized as another goal to consider. Yet, energy-driven research has mostly focused on the hardware and middleware layers, but few efforts target the application level, where many energy-aware optimizations are possible. We revisit a catalog of Java primitives commonly used in OO scientific programming, or micro-benchmarks, to identify energy-friendly versions of the same primitive. We then apply the micro-benchmarks to classical scientific application kernels and machine learning algorithms for both single-thread and multi-thread implementations on a server. Energy usage reductions at the micro-benchmark level are substantial, while for applications obtained reductions range from 3.90\% to 99.18\%.},
	language = {en},
	number = {2},
	urldate = {2020-08-25},
	journal = {Computer Science and Information Systems},
	author = {Longo, Mathias and Rodriguez, Ana and Mateos, Cristian and Zunino, Alejandro},
	year = {2019},
	pages = {541--564},
	file = {Longo et al. - 2019 - Reducing energy usage in resource-intensive Java-b.pdf:/Users/chakibbelgaid/Zotero newone/storage/BMMWPLAD/Longo et al. - 2019 - Reducing energy usage in resource-intensive Java-b.pdf:application/pdf},
}

@inproceedings{verdecchia_estimating_2017,
	address = {Toronto, ON},
	title = {Estimating {Energy} {Impact} of {Software} {Releases} and {Deployment} {Strategies}: {The} {KPMG} {Case} {Study}},
	isbn = {978-1-5090-4039-1},
	shorttitle = {Estimating {Energy} {Impact} of {Software} {Releases} and {Deployment} {Strategies}},
	url = {http://ieeexplore.ieee.org/document/8170112/},
	doi = {10.1109/ESEM.2017.39},
	abstract = {Method. We designed and performed an empirical experiment in a controlled environment. Deployment strategies, releases and use case scenarios of an industrial third-party software product were adopted as experimental factors. The use case scenarios were used as a blocking factor and adopted to dynamically load-test the software product. Power consumption and execution time were selected as response variables to measure the energy consumption.
Results. We observed that both deployment strategies and software releases signiﬁcantly inﬂuence the energy consumption of the hardware infrastructure. A strong interaction between the two factors was identiﬁed. The impact of such interaction highly varied depending on which use case scenario was considered, making the identiﬁcation of the most frequently adopted use case scenario critical for energy optimisation. The collaboration between industry and academia has been productive for both parties, even if some practitioners manifested low interest/awareness on software energy efﬁciency.
Conclusions. For the software product considered there is no absolute preferable release or deployment strategy with respect to energy efﬁciency, as the interaction of these factors has to be considered. The number of machines involved in a software deployment strategy does not simply constitute an additive effect of the energy consumption of the underlying hardware infrastructure.},
	language = {en},
	urldate = {2020-08-10},
	booktitle = {2017 {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement} ({ESEM})},
	publisher = {IEEE},
	author = {Verdecchia, Roberto and Procaccianti, Giuseppe and Malavolta, Ivano and Lago, Patricia and Koedijk, Joost},
	month = nov,
	year = {2017},
	pages = {257--266},
	file = {Verdecchia et al. - 2017 - Estimating Energy Impact of Software Releases and .pdf:/Users/chakibbelgaid/Zotero newone/storage/8G7IBY5X/Verdecchia et al. - 2017 - Estimating Energy Impact of Software Releases and .pdf:application/pdf},
}

@inproceedings{jagroep_software_2016-1,
	address = {Austin, Texas},
	title = {Software energy profiling: comparing releases of a software product},
	isbn = {978-1-4503-4205-6},
	shorttitle = {Software energy profiling},
	url = {http://dl.acm.org/citation.cfm?doid=2889160.2889216},
	doi = {10.1145/2889160.2889216},
	abstract = {In the quest for energy eﬃciency of Information and Communication Technology, so far research has mostly focused on the role of hardware. However, as hardware technology becomes more sophisticated, the role of software becomes crucial. Recently, the impact of software on energy consumption has been acknowledged as signiﬁcant by researchers in software engineering. In spite of that, measuring the energy consumption of software has proven to be a challenge, due to the large number of variables that need to be controlled to obtain reliable measurements. Due to cost and time constraints, many software product organizations are unable to eﬀectively measure the energy consumption of software. This prevents them to be in control over the energy eﬃciency of their products.},
	language = {en},
	urldate = {2020-08-10},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} {Companion} - {ICSE} '16},
	publisher = {ACM Press},
	author = {Jagroep, Erik A. and van der Werf, Jan Martijn and Brinkkemper, Sjaak and Procaccianti, Giuseppe and Lago, Patricia and Blom, Leen and van Vliet, Rob},
	year = {2016},
	pages = {523--532},
	file = {Jagroep et al. - 2016 - Software energy profiling comparing releases of a.pdf:/Users/chakibbelgaid/Zotero newone/storage/QWD6NG6V/Jagroep et al. - 2016 - Software energy profiling comparing releases of a.pdf:application/pdf},
}

@inproceedings{chen_stresscloud_2015,
	address = {Florence, Italy},
	title = {{StressCloud}: {A} {Tool} for {Analysing} {Performance} and {Energy} {Consumption} of {Cloud} {Applications}},
	isbn = {978-1-4799-1934-5},
	shorttitle = {{StressCloud}},
	url = {http://ieeexplore.ieee.org/document/7203052/},
	doi = {10.1109/ICSE.2015.232},
	language = {en},
	urldate = {2020-06-10},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE},
	author = {Chen, Feifei and Grundy, John and Schneider, Jean-Guy and Yang, Yun and He, Qiang},
	month = may,
	year = {2015},
	pages = {721--724},
	annote = {décrire un Modèle de déploiement avec des diagrammes , et test la perf de l outil sur le cloud},
	file = {Chen et al. - 2015 - StressCloud A Tool for Analysing Performance and .pdf:/Users/chakibbelgaid/Zotero newone/storage/DBTRSXWD/Chen et al. - 2015 - StressCloud A Tool for Analysing Performance and .pdf:application/pdf},
}

@inproceedings{cody-kenny_locogp_2015,
	address = {Madrid, Spain},
	title = {{locoGP}: {Improving} {Performance} by {Genetic} {Programming} {Java} {Source} {Code}},
	isbn = {978-1-4503-3488-4},
	shorttitle = {{locoGP}},
	url = {http://dl.acm.org/citation.cfm?doid=2739482.2768419},
	doi = {10.1145/2739482.2768419},
	abstract = {We present locoGP, a Genetic Programming (GP) system written in Java for evolving Java source code. locoGP was designed to improve the performance of programs as measured in the number of operations executed. Variable test cases are used to maintain functional correctness during evolution. The operation of locoGP is demonstrated on a number of typically constructed “oﬀ-the-shelf” hand-written implementations of sort and preﬁx-code programs. locoGP was able to ﬁnd improvement opportunities in all test problems.},
	language = {en},
	urldate = {2020-06-10},
	booktitle = {Proceedings of the {Companion} {Publication} of the 2015 on {Genetic} and {Evolutionary} {Computation} {Conference} - {GECCO} {Companion} '15},
	publisher = {ACM Press},
	author = {Cody-Kenny, Brendan and Galván-López, Edgar and Barrett, Stephen},
	year = {2015},
	pages = {811--818},
	annote = {+Genetic algorithm to enhanace java code quality using AST trees
- " random" AST nodes replacements in cross over ant mutations},
	file = {Cody-Kenny et al. - 2015 - locoGP Improving Performance by Genetic Programmi.pdf:/Users/chakibbelgaid/Zotero newone/storage/P4NXQK5X/Cody-Kenny et al. - 2015 - locoGP Improving Performance by Genetic Programmi.pdf:application/pdf},
}

@inproceedings{cody-kenny_locogp_2015-1,
	address = {Madrid, Spain},
	title = {{locoGP}: {Improving} {Performance} by {Genetic} {Programming} {Java} {Source} {Code}},
	isbn = {978-1-4503-3488-4},
	shorttitle = {{locoGP}},
	url = {http://dl.acm.org/citation.cfm?doid=2739482.2768419},
	doi = {10.1145/2739482.2768419},
	abstract = {We present locoGP, a Genetic Programming (GP) system written in Java for evolving Java source code. locoGP was designed to improve the performance of programs as measured in the number of operations executed. Variable test cases are used to maintain functional correctness during evolution. The operation of locoGP is demonstrated on a number of typically constructed “oﬀ-the-shelf” hand-written implementations of sort and preﬁx-code programs. locoGP was able to ﬁnd improvement opportunities in all test problems.},
	language = {en},
	urldate = {2020-06-09},
	booktitle = {Proceedings of the {Companion} {Publication} of the 2015 on {Genetic} and {Evolutionary} {Computation} {Conference} - {GECCO} {Companion} '15},
	publisher = {ACM Press},
	author = {Cody-Kenny, Brendan and Galván-López, Edgar and Barrett, Stephen},
	year = {2015},
	pages = {811--818},
	file = {Cody-Kenny et al. - 2015 - locoGP Improving Performance by Genetic Programmi.pdf:/Users/chakibbelgaid/Zotero newone/storage/BQ2I85N4/Cody-Kenny et al. - 2015 - locoGP Improving Performance by Genetic Programmi.pdf:application/pdf},
}

@incollection{sarro_improved_2016,
	address = {Cham},
	title = {Improved {Crossover} {Operators} for {Genetic} {Programming} for {Program} {Repair}},
	volume = {9962},
	isbn = {978-3-319-47105-1 978-3-319-47106-8},
	url = {http://link.springer.com/10.1007/978-3-319-47106-8_8},
	abstract = {GenProg is a stochastic method based on genetic programming that presents promising results in automatic software repair via patch evolution. GenProg’s crossover operates on a patch representation composed of high-granularity edits that indivisibly comprise an edit operation, a faulty location, and a ﬁx statement used in replacement or insertions. Recombination of such high-level minimal units limits the technique’s ability to eﬀectively traverse and recombine the repair search spaces. In this work, we propose a reformulation of program repair operators such that they explicitly traverse three subspaces that underlie the search problem: Operator, Fault Space and Fix Space. We leverage this reformulation in the form of new crossover operators that faithfully respect this subspace division, improving search performance. Our experiments on 43 programs validate our insight, and show that the Unif1Space without memorization performed best, improving the ﬁx rate by 34 \%.},
	language = {en},
	urldate = {2020-06-09},
	booktitle = {Search {Based} {Software} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Oliveira, Vinicius Paulo L. and Souza, Eduardo F. D. and Le Goues, Claire and Camilo-Junior, Celso G.},
	editor = {Sarro, Federica and Deb, Kalyanmoy},
	year = {2016},
	doi = {10.1007/978-3-319-47106-8_8},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {112--127},
	file = {Oliveira et al. - 2016 - Improved Crossover Operators for Genetic Programmi.pdf:/Users/chakibbelgaid/Zotero newone/storage/MN6ZT8EZ/Oliveira et al. - 2016 - Improved Crossover Operators for Genetic Programmi.pdf:application/pdf},
}

@inproceedings{schulte_post-compiler_2014-1,
	address = {Salt Lake City, Utah, USA},
	title = {Post-compiler software optimization for reducing energy},
	isbn = {978-1-4503-2305-5},
	url = {http://dl.acm.org/citation.cfm?doid=2541940.2541980},
	doi = {10.1145/2541940.2541980},
	abstract = {Modern compilers typically optimize for executable size and speed, rarely exploring non-functional properties such as power efﬁciency. These properties are often hardwarespeciﬁc, time-intensive to optimize, and may not be amenable to standard dataﬂow optimizations. We present a general post-compilation approach called Genetic Optimization Algorithm (GOA), which targets measurable non-functional aspects of software execution in programs that compile to x86 assembly. GOA combines insights from proﬁle-guided optimization, superoptimization, evolutionary computation and mutational robustness. GOA searches for program variants that retain required functional behavior while improving non-functional behavior, using characteristic workloads and predictive modeling to guide the search. The resulting optimizations are validated using physical performance measurements and a larger held-out test suite. Our experimental results on PARSEC benchmark programs show average energy reductions of 20\%, both for a large AMD system and a small Intel system, while maintaining program functionality on target workloads.},
	language = {en},
	urldate = {2020-06-09},
	booktitle = {Proceedings of the 19th international conference on {Architectural} support for programming languages and operating systems - {ASPLOS} '14},
	publisher = {ACM Press},
	author = {Schulte, Eric and Dorn, Jonathan and Harding, Stephen and Forrest, Stephanie and Weimer, Westley},
	year = {2014},
	pages = {639--652},
	file = {Schulte et al. - 2014 - Post-compiler software optimization for reducing e.pdf:/Users/chakibbelgaid/Zotero newone/storage/SZZTNFG2/Schulte et al. - 2014 - Post-compiler software optimization for reducing e.pdf:application/pdf},
}

@inproceedings{carette_investigating_2017,
	address = {Klagenfurt, Austria},
	title = {Investigating the energy impact of {Android} smells},
	isbn = {978-1-5090-5501-2},
	url = {http://ieeexplore.ieee.org/document/7884614/},
	doi = {10.1109/SANER.2017.7884614},
	abstract = {Android code smells are bad implementation practices within Android applications (or apps) that may lead to poor software quality. These code smells are known to degrade the performance of apps and to have an impact on energy consumption. However, few studies have assessed the positive impact on energy consumption when correcting code smells. In this paper, we therefore propose a tooled and reproducible approach, called HOT-PEPPER, to automatically correct code smells and evaluate their impact on energy consumption. Currently, HOT-PEPPER is able to automatically correct three types of Android-speciﬁc code smells: Internal Getter/Setter, Member Ignoring Method, and HashMap Usage. HOT-PEPPER derives four versions of the apps by correcting each detected smell independently, and all of them at once. HOT-PEPPER is able to report on the energy consumption of each app version with a single user scenario test. Our empirical study on ﬁve open-source Android apps shows that correcting the three aforementioned Android code smells effectively and signiﬁcantly reduces the energy consumption of apps. In particular, we observed a global reduction in energy consumption by 4,83\% in one app when the three code smells are corrected. We also take advantage of the ﬂexibility of HOTPEPPER to investigate the impact of three picture smells (bad picture format, compression, and bitmap format) in sample apps. We observed that the usage of optimised JPG pictures with the Android default bitmap format is the most energy efﬁcient combination in Android apps. We believe that developers can beneﬁt from our approach and results to guide their refactoring, and thus improve the energy consumption of their mobile apps.},
	language = {en},
	urldate = {2020-06-09},
	booktitle = {2017 {IEEE} 24th {International} {Conference} on {Software} {Analysis}, {Evolution} and {Reengineering} ({SANER})},
	publisher = {IEEE},
	author = {Carette, Antonin and Younes, Mehdi Adel Ait and Hecht, Geoffrey and Moha, Naouel and Rouvoy, Romain},
	month = feb,
	year = {2017},
	pages = {115--126},
	file = {Energy Impact of Software Releases and Deployment Strategies.pdf:/Users/chakibbelgaid/Zotero newone/storage/YSHMZBD7/Energy Impact of Software Releases and Deployment Strategies.pdf:application/pdf;Comparing Releases of Software Product.pdf:/Users/chakibbelgaid/Zotero newone/storage/55TTKBWI/Comparing Releases of Software Product.pdf:application/pdf;2739482.2768419.pdf:/Users/chakibbelgaid/Zotero newone/storage/2RP2SLG6/2739482.2768419.pdf:application/pdf;Carette et al. - 2017 - Investigating the energy impact of Android smells.pdf:/Users/chakibbelgaid/Zotero newone/storage/JKBCHS5A/Carette et al. - 2017 - Investigating the energy impact of Android smells.pdf:application/pdf},
}

@inproceedings{moghadam_code-imp_2011,
	address = {Waikiki, Honolulu, HI, USA},
	title = {Code-{Imp}: a tool for automated search-based refactoring},
	isbn = {978-1-4503-0579-2},
	shorttitle = {Code-{Imp}},
	url = {http://portal.acm.org/citation.cfm?doid=1984732.1984742},
	doi = {10.1145/1984732.1984742},
	abstract = {Manual refactoring is tedious and error-prone, so it is natural to try to automate this process as much as possible. Fully automated refactoring usually involves using metaheuristic search to determine which refactorings should be applied to improve the program according to some ﬁtness function, expressed in terms of standard software quality metrics.},
	language = {en},
	urldate = {2020-05-18},
	booktitle = {Proceeding of the 4th workshop on {Refactoring} tools - {WRT} '11},
	publisher = {ACM Press},
	author = {Moghadam, Iman Hemati and Ó Cinnéide, Mel},
	year = {2011},
	pages = {41},
	file = {Moghadam and Ó Cinnéide - 2011 - Code-Imp a tool for automated search-based refact.pdf:/Users/chakibbelgaid/Zotero newone/storage/QDITRTCF/Moghadam and Ó Cinnéide - 2011 - Code-Imp a tool for automated search-based refact.pdf:application/pdf},
}

@article{ouni_multi-criteria_2016,
	title = {Multi-{Criteria} {Code} {Refactoring} {Using} {Search}-{Based} {Software} {Engineering}: {An} {Industrial} {Case} {Study}},
	volume = {25},
	issn = {1049-331X, 1557-7392},
	shorttitle = {Multi-{Criteria} {Code} {Refactoring} {Using} {Search}-{Based} {Software} {Engineering}},
	url = {https://dl.acm.org/doi/10.1145/2932631},
	doi = {10.1145/2932631},
	language = {en},
	number = {3},
	urldate = {2020-05-18},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Ouni, Ali and Kessentini, Marouane and Sahraoui, Houari and Inoue, Katsuro and Deb, Kalyanmoy},
	month = aug,
	year = {2016},
	pages = {1--53},
	file = {2739482.2768419.pdf:/Users/chakibbelgaid/Zotero newone/storage/FKAZ3EGL/2739482.2768419.pdf:application/pdf;Ouni et al. - 2016 - Multi-Criteria Code Refactoring Using Search-Based.pdf:/Users/chakibbelgaid/Zotero newone/storage/J83PSPCU/Ouni et al. - 2016 - Multi-Criteria Code Refactoring Using Search-Based.pdf:application/pdf},
}

@article{kaur_analysis_2016,
	title = {Analysis of {Code} {Refactoring} {Impact} on {Software} {Quality}},
	volume = {57},
	issn = {2261-236X},
	url = {http://www.matec-conferences.org/10.1051/matecconf/20165702012},
	doi = {10.1051/matecconf/20165702012},
	abstract = {Code refactoring is a “Technique used for restructuring an existing source code, improving its internal structure without changing its external behaviour”. It is the process of changing a source code in such a way that it does not alter the external behaviour of the code yet improves its internal structure. It is a way to clean up code that minimizes the chances of introducing bugs. Refactoring is a change made to the internal structure of a software component to make it easier to understand and cheaper to modify, without changing the observable behaviour of that software component. Bad smells indicate that there is something wrong in the code that have to refactor. There are different tools that are available to identify and remove these bad smells. It is a technique that change our source code in a more readable and maintainable form by removing the bad smells from the code. Refactoring is used to improve the quality of software by reducing the complexity. In this paper bad smells are found and perform the refactoring based on these bad smell and then find the complexity of program and compare with initial complexity. This paper shows that when refactoring is performed the complexity of software decrease and easily understandable.},
	language = {en},
	urldate = {2020-05-18},
	journal = {MATEC Web of Conferences},
	author = {Kaur, Amandeep and Kaur, Manpreet},
	editor = {Srivastava, T. and Rani, S. and Kakkar, S.},
	year = {2016},
	pages = {02012},
	file = {Kaur and Kaur - 2016 - Analysis of Code Refactoring Impact on Software Qu.pdf:/Users/chakibbelgaid/Zotero newone/storage/M6YB4M3W/Kaur and Kaur - 2016 - Analysis of Code Refactoring Impact on Software Qu.pdf:application/pdf},
}

@inproceedings{anwar_evaluating_2019,
	address = {Kallithea-Chalkidiki, Greece},
	title = {Evaluating the {Impact} of {Code} {Smell} {Refactoring} on the {Energy} {Consumption} of {Android} {Applications}},
	isbn = {978-1-72813-421-5},
	url = {https://ieeexplore.ieee.org/document/8906734/},
	doi = {10.1109/SEAA.2019.00021},
	abstract = {Energy consumption of mobile apps is receiving a lot of attention from researchers. Recent studies indicate that energy consumption of mobile devices could be lowered by improving the quality of mobile apps. Frequent refactoring is one way of achieving this goal. We explore the performance and energy impact of several common code refactorings in Android apps. Experimental results indicate that some code smell refactorings positively impact the energy consumption of Android apps. Refactoring of the code smells ‘Duplicated code’ and ‘Type checking’ reduce energy consumption by up to 10.8\%. Significant reduction in energy consumption, however, does not seem to be directly related to the increase or decrease of execution time. In addition, the energy impact over permutations of code smell refactorings in the selected Android apps was small. When analyzing the order in which refactorings were made across code smell types, it turned out that some permutations resulted in a reduction and some in an increase of energy consumption for the analyzed apps.},
	language = {en},
	urldate = {2020-05-18},
	booktitle = {2019 45th {Euromicro} {Conference} on {Software} {Engineering} and {Advanced} {Applications} ({SEAA})},
	publisher = {IEEE},
	author = {Anwar, Hina and Pfahl, Dietmar and Srirama, Satish N.},
	month = aug,
	year = {2019},
	pages = {82--86},
	file = {Anwar et al. - 2019 - Evaluating the Impact of Code Smell Refactoring on.pdf:/Users/chakibbelgaid/Zotero newone/storage/NLZ6DYW6/Anwar et al. - 2019 - Evaluating the Impact of Code Smell Refactoring on.pdf:application/pdf},
}

@article{noauthor_deploying_2014,
	title = {Deploying and {Provisioning} {Green} {Software}},
	volume = {31},
	issn = {0740-7459},
	url = {http://ieeexplore.ieee.org/document/6802999/},
	doi = {10.1109/MS.2014.59},
	language = {en},
	number = {3},
	urldate = {2020-05-12},
	journal = {IEEE Software},
	month = may,
	year = {2014},
	pages = {76--78},
	file = {2014 - Deploying and Provisioning Green Software.pdf:/Users/chakibbelgaid/Zotero newone/storage/BLAPLQQA/2014 - Deploying and Provisioning Green Software.pdf:application/pdf},
}

@article{chan-jong-chu_investigating_2020,
	title = {Investigating the correlation between performance scores and energy consumption of mobile web apps},
	abstract = {Method. We design and conduct an empirical experiment where 21 real mobile web apps are (i) analyzed via the Lighthouse performance analysis tool and (ii) measured on an Android device running a software-based energy profiler. Then, we statistically assess how energy consumption correlates with the obtained performance scores and carry out an effect size estimation.
Results. We discover a statistically significant negative correlation between performance scores and the energy consumption of mobile web apps (with medium to large effect sizes), implying that an increase of the performance score tend to lead to a decrease of energy consumption.
Conclusions. We recommend developers to strive to improve the performance level of their mobile web apps, as this can also have a positive impact on their energy consumption on Android devices. ACM Reference Format: Kwame Chan-Jong-Chu†, Tanjina Islam†, Miguel Morales Exposito†, Sanjay Sheombar†, Christian Valladares†, Olivier Philippot∗, Eoin Martino Grua†, Ivano Malavolta†. 2020. Investigating the correlation between performance scores and energy consumption of mobile web apps . In Evaluation and Assessment in Software Engineering (EASE 2020), April 15–17, 2020, Trondheim, Norway. ACM, New York, NY, USA, 10 pages. https://doi.org/10.1145/ 3383219.3383239},
	language = {en},
	author = {Chan-Jong-Chu, Kwame and Islam, Tanjina and Exposito, Miguel Morales and Sheombar, Sanjay and Valladares, Christian and Philippot, Olivier and Grua, Eoin Martino and Malavolta, Ivano},
	year = {2020},
	pages = {10},
	file = {Chan-Jong-Chu et al. - 2020 - Investigating the correlation between performance .pdf:/Users/chakibbelgaid/Zotero newone/storage/WCQVT43X/Chan-Jong-Chu et al. - 2020 - Investigating the correlation between performance .pdf:application/pdf},
}

@inproceedings{latoza_study_2013,
	address = {San Francisco, CA, USA},
	title = {A study of architectural decision practices},
	isbn = {978-1-4673-6290-0},
	url = {http://ieeexplore.ieee.org/document/6614735/},
	doi = {10.1109/CHASE.2013.6614735},
	abstract = {Architectural decisions shape a software architecture and determine its ability to meet its requirements. To better understand architectural decisions in practice, we interviewed developers at two organizations. The results revealed that architectural decisions often become technology decisions, which are in turn influenced by both technical and social factors. Meetings and knowledge repositories help to communicate architectural decisions, but code reviews are ultimately necessary to ensure conformance. Costly changes to architectural decisions are caused by the discovery of an Achilles’ heel, an important scenario that cannot be supported by an architectural decision. These findings suggest an important need for social development tools that help developers more easily and successfully share valuable technology knowledge and more effectively make technology choices.},
	language = {en},
	urldate = {2020-02-27},
	booktitle = {2013 6th {International} {Workshop} on {Cooperative} and {Human} {Aspects} of {Software} {Engineering} ({CHASE})},
	publisher = {IEEE},
	author = {LaToza, Thomas D. and Shabani, Evelina and van der Hoek, Andre},
	month = may,
	year = {2013},
	pages = {77--80},
	file = {LaToza et al. - 2013 - A study of architectural decision practices.pdf:/Users/chakibbelgaid/Zotero newone/storage/CR8JMLBV/LaToza et al. - 2013 - A study of architectural decision practices.pdf:application/pdf},
}

@inproceedings{fritz_determining_2011,
	address = {Vancouver, BC, Canada},
	title = {Determining relevancy: how software developers determine relevant information in feeds},
	isbn = {978-1-4503-0228-9},
	shorttitle = {Determining relevancy},
	url = {http://dl.acm.org/citation.cfm?doid=1978942.1979206},
	doi = {10.1145/1978942.1979206},
	abstract = {Finding relevant information within the vast amount of information exchanged via streams, such as provided by Twitter or Facebook, is difﬁcult. Previous research into this problem has largely focused on recommending relevant information based on topicality. By not considering individual and situational factors that can affect whether information is relevant, these approaches fall short. Through a formative, interviewbased study, we explored how ﬁve software developers from a team determined relevancy of items in two kinds of project news feeds. We identiﬁed four factors that the developers used to help determine relevancy and found that placement of items in source code and team contexts can ease the determination of relevancy.},
	language = {en},
	urldate = {2020-02-27},
	booktitle = {Proceedings of the 2011 annual conference on {Human} factors in computing systems - {CHI} '11},
	publisher = {ACM Press},
	author = {Fritz, Thomas and Murphy, Gail C.},
	year = {2011},
	pages = {1827},
	file = {Fritz and Murphy - 2011 - Determining relevancy how software developers det.pdf:/Users/chakibbelgaid/Zotero newone/storage/AJUWIPYX/Fritz and Murphy - 2011 - Determining relevancy how software developers det.pdf:application/pdf},
}

@inproceedings{sedano_software_2017,
	address = {Buenos Aires},
	title = {Software {Development} {Waste}},
	isbn = {978-1-5386-3868-2},
	url = {http://ieeexplore.ieee.org/document/7985656/},
	doi = {10.1109/ICSE.2017.20},
	abstract = {Objective: The purpose of this paper is to identify and describe different types of waste in software development.
Method: Following Constructivist Grounded Theory, we conducted a two-year ﬁve-month participant-observation study of eight software development projects at Pivotal, a software development consultancy. We also interviewed 33 software engineers, interaction designers, and product managers, and analyzed one year of retrospection topics. We iterated between analysis and theoretical sampling until achieving theoretical saturation.
Results: This paper introduces the ﬁrst empirical waste taxonomy. It identiﬁes nine wastes and explores their causes, underlying tensions, and overall relationship to the waste taxonomy found in Lean Software Development. Limitations: Grounded Theory does not support statistical generalization. While the proposed taxonomy appears widely applicable, organizations with different software development cultures may experience different waste types.
Conclusion: Software development projects manifest nine types of waste: building the wrong feature or product, mismanaging the backlog, rework, unnecessarily complex solutions, extraneous cognitive load, psychological distress, waiting/multitasking, knowledge loss, and ineffective communication.},
	language = {en},
	urldate = {2020-02-27},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Sedano, Todd and Ralph, Paul and Peraire, Cecile},
	month = may,
	year = {2017},
	pages = {130--140},
	file = {Sedano et al. - 2017 - Software Development Waste.pdf:/Users/chakibbelgaid/Zotero newone/storage/VBYG8UQ8/Sedano et al. - 2017 - Software Development Waste.pdf:application/pdf},
}

@inproceedings{berger_what_2015,
	address = {Nashville, Tennessee},
	title = {What is a feature?: a qualitative study of features in industrial software product lines},
	isbn = {978-1-4503-3613-0},
	shorttitle = {What is a feature?},
	url = {http://dl.acm.org/citation.cfm?doid=2791060.2791108},
	doi = {10.1145/2791060.2791108},
	abstract = {The notion of features is commonly used to describe the functional and non-functional characteristics of a system. In software product line engineering, features often become the prime entities of software reuse and are used to distinguish the individual products of a product line. Properly decomposing a product line into features, and correctly using features in all engineering phases, is core to the immediate and longterm success of such a system. Yet, although more than ten diﬀerent deﬁnitions of the term feature exist, it is still a very abstract concept. Deﬁnitions lack concrete guidelines on how to use the notion of features in practice.},
	language = {en},
	urldate = {2020-02-27},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Software} {Product} {Line} - {SPLC} '15},
	publisher = {ACM Press},
	author = {Berger, Thorsten and Lettner, Daniela and Rubin, Julia and Grünbacher, Paul and Silva, Adeline and Becker, Martin and Chechik, Marsha and Czarnecki, Krzysztof},
	year = {2015},
	pages = {16--25},
	file = {Berger et al. - 2015 - What is a feature a qualitative study of feature.pdf:/Users/chakibbelgaid/Zotero newone/storage/V8B3K3IB/Berger et al. - 2015 - What is a feature a qualitative study of feature.pdf:application/pdf},
}

@article{smith_how_2019,
	title = {How {Developers} {Diagnose} {Potential} {Security} {Vulnerabilities} with a {Static} {Analysis} {Tool}},
	volume = {45},
	issn = {0098-5589, 1939-3520, 2326-3881},
	url = {https://ieeexplore.ieee.org/document/8303758/},
	doi = {10.1109/TSE.2018.2810116},
	abstract = {While using security tools to resolve security defects, software developers must apply considerable effort. Success depends on a developer’s ability to interact with tools, ask the right questions, and make strategic decisions. To build better security tools and subsequently help developers resolve defects more accurately and efﬁciently, we studied the defect resolution process — from the questions developers ask to their strategies for answering them. In this paper, we report on an exploratory study with novice and experienced software developers. We equipped them with Find Security Bugs, a security-oriented static analysis tool, and observed their interactions with security vulnerabilities in an open-source system that they had previously contributed to. We found that they asked questions not only about security vulnerabilities, associated attacks, and ﬁxes, but also questions about the software itself, the social ecosystem that built the software, and related resources and tools. We describe the strategic successes and failures we observed and how future tools can leverage our ﬁndings to encourage better strategies.},
	language = {en},
	number = {9},
	urldate = {2020-02-27},
	journal = {IEEE Transactions on Software Engineering},
	author = {Smith, Justin and Johnson, Brittany and Murphy-Hill, Emerson and Chu, Bill and Lipford, Heather Richter},
	month = sep,
	year = {2019},
	pages = {877--897},
	file = {Smith et al. - 2019 - How Developers Diagnose Potential Security Vulnera.pdf:/Users/chakibbelgaid/Zotero newone/storage/KCEWGCDE/Smith et al. - 2019 - How Developers Diagnose Potential Security Vulnera.pdf:application/pdf},
}

@article{khalid_what_2015,
	title = {What {Do} {Mobile} {App} {Users} {Complain} {About}? {A} {Study} on {Free} {iOS} {Apps}},
	abstract = {The quality of mobile apps is becoming an increasingly important issue. These apps are generally delivered through app stores that allow users to post reviews about apps. These user-reviews provide a rich data source that can be leveraged to understand user reported issues. In this study, we qualitatively study 6,390 low star-rating user-reviews for 20 free iOS apps. Our study uncovers 12 types of complaints that users complain about. We ﬁnd that functional errors, feature requests and app crashes are the most frequent complaints. Privacy and ethical issues, and hidden app costs are the complaints with the most negative impact on app ratings. We also ﬁnd that users attributed their complaint to updating the app in 11\% of the reviews. Our study provides developers an insight into the user-raised issues of iOS apps, along with their frequency and impact, which can help developers better prioritize their limited Quality Assurance resources.},
	language = {en},
	author = {Khalid, Hammad and Shihab, Emad and Nagappan, Meiyappan and Hassan, Ahmed E},
	year = {2015},
	pages = {6},
	file = {Khalid et al. - What Do Mobile App Users Complain About A Study o.pdf:/Users/chakibbelgaid/Zotero newone/storage/BWCE5ZGF/Khalid et al. - What Do Mobile App Users Complain About A Study o.pdf:application/pdf},
}

@inproceedings{ford_tech-talk_2017,
	address = {Buenos Aires, Argentina},
	title = {The {Tech}-{Talk} {Balance}: {What} {Technical} {Interviewers} {Expect} from {Technical} {Candidates}},
	isbn = {978-1-5386-4039-5},
	shorttitle = {The {Tech}-{Talk} {Balance}},
	url = {http://ieeexplore.ieee.org/document/7961470/},
	doi = {10.1109/CHASE.2017.8},
	abstract = {Software engineer job candidates are not succeeding at technical interviews. Although candidates are able to answer technical questions, there is a mismatch of what candidates think interviewers assess versus what criteria is used in practice. This mismatch in expectations can cost candidates a job opportunity. To determine what criteria interviewers value, we conducted mock technical interviews with software engineer candidates at a university and collected evaluations from interviewers. We analyzed 70 interview evaluations from 9 software companies. Using a grounded theory approach, we compared interviewer interpretations of criteria including: performing a problem solving walkthrough, applying previous experience to problem solving, and the ability to engaging in conversation beyond writing code. From these ﬁndings, we provide implications on what candidates can expect to be evaluated on during technical interviews across companies, which can sometimes vary signiﬁcantly.},
	language = {en},
	urldate = {2020-02-27},
	booktitle = {2017 {IEEE}/{ACM} 10th {International} {Workshop} on {Cooperative} and {Human} {Aspects} of {Software} {Engineering} ({CHASE})},
	publisher = {IEEE},
	author = {Ford, Denae and Barik, Titus and Rand-Pickett, Leslie and Parnin, Chris},
	month = may,
	year = {2017},
	pages = {43--48},
	file = {Ford et al. - 2017 - The Tech-Talk Balance What Technical Interviewers.pdf:/Users/chakibbelgaid/Zotero newone/storage/KVKS237Z/Ford et al. - 2017 - The Tech-Talk Balance What Technical Interviewers.pdf:application/pdf},
}

@inproceedings{kumar_energy_2017,
	address = {Orlando, FL},
	title = {Energy consumption in {Java}: {An} early experience},
	isbn = {978-1-5386-3470-7},
	shorttitle = {Energy consumption in {Java}},
	url = {http://ieeexplore.ieee.org/document/8323579/},
	doi = {10.1109/IGCC.2017.8323579},
	abstract = {There has been a 10,000-fold increase in performance of supercomputers since 1992 but only 300-fold improvement in performance per watt. Dynamic adaptation of hardware techniques such as ﬁne-grain clock gating, power gating and dynamic voltage/frequency scaling, are used for many years to improve the computer’s energy efﬁciency. However, recent demands of exascale computation, as well as the increasing carbon footprint, require new breakthrough to make ICT systems more energy efﬁcient. Energy efﬁcient software has not been well studied in the last decade. In this paper, we take an early step to investigate the energy efﬁciency of Java which is one of the most common languages used in ICT systems. We evaluate energy consumption of data types, operators, control statements, exception, and object in Java at a granular level. Intel Running Average Power Limit (RAPL) technology is applied to measure the relative power consumption of small code snippets. Several observations are found, and these results will help in standardizing the energy consumption traits of Java which can be leveraged by software developers to generate energy efﬁcient code in future.},
	language = {en},
	urldate = {2020-02-24},
	booktitle = {2017 {Eighth} {International} {Green} and {Sustainable} {Computing} {Conference} ({IGSC})},
	publisher = {IEEE},
	author = {Kumar, Mohit and Li, Youhuizi and Shi, Weisong},
	month = oct,
	year = {2017},
	pages = {1--8},
	file = {Kumar et al. - 2017 - Energy consumption in Java An early experience.pdf:/Users/chakibbelgaid/Zotero newone/storage/PXE9DZB9/Kumar et al. - 2017 - Energy consumption in Java An early experience.pdf:application/pdf},
}

@article{kumar_improving_nodate,
	title = {{IMPROVING} {ENERGY} {CONSUMPTION} {OF} {JAVA} {PROGRAMS}},
	language = {en},
	author = {Kumar, Mohit},
	pages = {24},
	file = {Kumar - IMPROVING ENERGY CONSUMPTION OF JAVA PROGRAMS.pdf:/Users/chakibbelgaid/Zotero newone/storage/28S5FT24/Kumar - IMPROVING ENERGY CONSUMPTION OF JAVA PROGRAMS.pdf:application/pdf},
}

@article{vasileiou_characterising_2018,
	title = {Characterising and justifying sample size sufficiency in interview-based studies: systematic analysis of qualitative health research over a 15-year period},
	volume = {18},
	issn = {1471-2288},
	shorttitle = {Characterising and justifying sample size sufficiency in interview-based studies},
	url = {https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-018-0594-7},
	doi = {10.1186/s12874-018-0594-7},
	abstract = {Background: Choosing a suitable sample size in qualitative research is an area of conceptual debate and practical uncertainty. That sample size principles, guidelines and tools have been developed to enable researchers to set, and justify the acceptability of, their sample size is an indication that the issue constitutes an important marker of the quality of qualitative research. Nevertheless, research shows that sample size sufficiency reporting is often poor, if not absent, across a range of disciplinary fields.
Methods: A systematic analysis of single-interview-per-participant designs within three health-related journals from the disciplines of psychology, sociology and medicine, over a 15-year period, was conducted to examine whether and how sample sizes were justified and how sample size was characterised and discussed by authors. Data pertinent to sample size were extracted and analysed using qualitative and quantitative analytic techniques.
Results: Our findings demonstrate that provision of sample size justifications in qualitative health research is limited; is not contingent on the number of interviews; and relates to the journal of publication. Defence of sample size was most frequently supported across all three journals with reference to the principle of saturation and to pragmatic considerations. Qualitative sample sizes were predominantly – and often without justification – characterised as insufficient (i.e., ‘small’) and discussed in the context of study limitations. Sample size insufficiency was seen to threaten the validity and generalizability of studies’ results, with the latter being frequently conceived in nomothetic terms.
Conclusions: We recommend, firstly, that qualitative health researchers be more transparent about evaluations of their sample size sufficiency, situating these within broader and more encompassing assessments of data adequacy. Secondly, we invite researchers critically to consider how saturation parameters found in prior methodological studies and sample size community norms might best inform, and apply to, their own project and encourage that data adequacy is best appraised with reference to features that are intrinsic to the study at hand. Finally, those reviewing papers have a vital role in supporting and encouraging transparent study-specific reporting.},
	language = {en},
	number = {1},
	urldate = {2020-02-17},
	journal = {BMC Medical Research Methodology},
	author = {Vasileiou, Konstantina and Barnett, Julie and Thorpe, Susan and Young, Terry},
	month = dec,
	year = {2018},
	file = {Vasileiou et al. - 2018 - Characterising and justifying sample size sufficie.pdf:/Users/chakibbelgaid/Zotero newone/storage/8WQULUJW/Vasileiou et al. - 2018 - Characterising and justifying sample size sufficie.pdf:application/pdf},
}

@article{bertram_communication_2009,
	title = {Communication, {Collaboration}, and {Bugs}: {The} {Social} {Nature} of {Issue} {Tracking} in {Software} {Engineering}},
	abstract = {Issue tracking systems help organizations manage issue reporting, assignment, tracking, resolution, and archiving. Traditionally, it is the Software Engineering community that researches issue tracking systems, where software defects are reported and tracked as ‘bug reports’ within an archival database. Yet issue tracking is fundamentally a social process and, as such, it is important to understand the design and use of issue tracking systems from that perspective. Consequently, we conducted a qualitative study of the use of issue tracking systems by small, collocated software development teams. We found that an issue tracker is not just a database for tracking bugs, features, and inquiries, but also a focal point for communication and coordination for many stakeholders within and beyond the software team. Customers, project managers, quality assurance personnel, and programmers all contribute to the shared knowledge and persistent communication that exists within the issue tracking system. We articulate various real-world practices surrounding issue trackers and offer design implications for future systems.},
	language = {en},
	author = {Bertram, Dane and Voida, Amy and Greenberg, Saul and Walker, Robert},
	year = {2009},
	pages = {11},
	file = {Bertram et al. - Communication, Collaboration, and Bugs The Social.pdf:/Users/chakibbelgaid/Zotero newone/storage/93J7AT8G/Bertram et al. - Communication, Collaboration, and Bugs The Social.pdf:application/pdf},
}

@inproceedings{tomasdottir_why_2017,
	address = {Urbana, IL},
	title = {Why and how {JavaScript} developers use linters},
	isbn = {978-1-5386-2684-9},
	url = {http://ieeexplore.ieee.org/document/8115668/},
	doi = {10.1109/ASE.2017.8115668},
	abstract = {Automatic static analysis tools help developers to automatically spot code issues in their software. They can be of extreme value in languages with dynamic characteristics, such as JavaScript, where developers can easily introduce mistakes which can go unnoticed for a long time, e.g. a simple syntactic or spelling mistake. Although research has already shown how developers perceive such tools for strongly-typed languages such as Java, little is known about their perceptions when it comes to dynamic languages. In this paper, we investigate what motivates and how developers make use of such tools in JavaScript projects. To that goal, we apply a qualitative research method to conduct and analyze a series of 15 interviews with developers responsible for the linter conﬁguration in reputable OSS JavaScript projects that apply the most commonly used linter, ESLint. The results describe the beneﬁts that developers obtain when using ESLint, the different ways one can conﬁgure the tool and prioritize its rules, and the existing challenges in applying linters in the real world. These results have direct implications for developers, tool makers, and researchers, such as tool improvements, and a research agenda that aims to increase our knowledge about the usefulness of such analyzers.},
	language = {en},
	urldate = {2020-02-17},
	booktitle = {2017 32nd {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} ({ASE})},
	publisher = {IEEE},
	author = {Tomasdottir, Kristin Fjola and Aniche, Mauricio and van Deursen, Arie},
	month = oct,
	year = {2017},
	pages = {578--589},
	file = {sedano_todd_software_engineering_waste.pdf:/Users/chakibbelgaid/Zotero newone/storage/DHQLBY43/sedano_todd_software_engineering_waste.pdf:application/pdf;Tomasdottir et al. - 2017 - Why and how JavaScript developers use linters.pdf:/Users/chakibbelgaid/Zotero newone/storage/SA4V9NGA/Tomasdottir et al. - 2017 - Why and how JavaScript developers use linters.pdf:application/pdf},
}

@inproceedings{barik_i_2015,
	address = {Bergamo, Italy},
	title = {I heart hacker news: expanding qualitative research findings by analyzing social news websites},
	isbn = {978-1-4503-3675-8},
	shorttitle = {I heart hacker news},
	url = {http://dl.acm.org/citation.cfm?doid=2786805.2803200},
	doi = {10.1145/2786805.2803200},
	abstract = {Grounded theory is an important research method in empirical software engineering, but it is also time consuming, tedious, and complex. This makes it diﬃcult for researchers to assess if threats, such as missing themes or sample bias, have inadvertently materialized. To better assess such threats, our new idea is that we can automatically extract knowledge from social news websites, such as Hacker News, to easily replicate existing grounded theory research — and then compare the results. We conduct a replication study on static analysis tool adoption using Hacker News. We conﬁrm that even a basic replication and analysis using social news websites can oﬀer additional insights to existing themes in studies, while also identifying new themes. For example, we identiﬁed that security was not a theme discovered in the original study on tool adoption. As a long-term vision, we consider techniques from the discipline of knowledge discovery to make this replication process more automatic.},
	language = {en},
	urldate = {2020-02-13},
	booktitle = {Proceedings of the 2015 10th {Joint} {Meeting} on {Foundations} of {Software} {Engineering} - {ESEC}/{FSE} 2015},
	publisher = {ACM Press},
	author = {Barik, Titus and Johnson, Brittany and Murphy-Hill, Emerson},
	year = {2015},
	pages = {882--885},
	file = {Barik et al. - 2015 - I heart hacker news expanding qualitative researc.pdf:/Users/chakibbelgaid/Zotero newone/storage/2GW2B947/Barik et al. - 2015 - I heart hacker news expanding qualitative researc.pdf:application/pdf},
}

@article{oliver_constraints_2005,
	title = {Constraints and {Opportunities} with {Interview} {Transcription}: {Towards} {Reflection} in {Qualitative} {Research}},
	volume = {84},
	issn = {0037-7732, 1534-7605},
	shorttitle = {Constraints and {Opportunities} with {Interview} {Transcription}},
	url = {https://academic.oup.com/sf/article-lookup/doi/10.1353/sof.2006.0023},
	doi = {10.1353/sof.2006.0023},
	abstract = {In this paper we discuss the complexities of interview transcription. While often seen as a behindthe-scenes task, we suggest that transcription is a powerful act of representation. Transcription is practiced in multiple ways, often using naturalism, in which every utterance is captured in as much detail as possible, and/or denaturalism, in which grammar is corrected, interview noise (e.g., stutters, pauses, etc.) is removed and nonstandard accents (i.e., non-majority) are standardized. In this article, we discuss the constraints and opportunities of our transcription decisions and point to an intermediate, reflective step. We suggest that researchers incorporate reflection into their research design by interrogating their transcription decisions and the possible impact these decisions may have on participants and research outcomes.},
	language = {en},
	number = {2},
	urldate = {2020-02-05},
	journal = {Social Forces},
	author = {Oliver, D. G. and Serovich, J. M. and Mason, T. L.},
	month = dec,
	year = {2005},
	pages = {1273--1289},
	file = {Oliver et al. - 2005 - Constraints and Opportunities with Interview Trans.pdf:/Users/chakibbelgaid/Zotero newone/storage/3WVFUEA4/Oliver et al. - 2005 - Constraints and Opportunities with Interview Trans.pdf:application/pdf},
}

@book{patton_michael_quinn_qualitative_1990,
	edition = {2},
	title = {Qualitative evaluation and research methods, 2nd ed.},
	number = {0-8039-3779-2},
	publisher = {Sage Publications, Inc},
	author = {{Patton, Michael Quinn}},
	year = {1990},
	file = {Patton, Michael Quinn - 1990 - Qualitative evaluation and research methods, 2nd e.pdf:/Users/chakibbelgaid/Zotero newone/storage/46KLY5D3/Patton, Michael Quinn - 1990 - Qualitative evaluation and research methods, 2nd e.pdf:application/pdf},
}

@book{handel_sociology_2003,
	address = {Thousand Oaks},
	title = {The sociology of organizations: classic, contemporary, and critical readings},
	isbn = {978-0-7619-8766-6},
	shorttitle = {The sociology of organizations},
	language = {pt},
	publisher = {Sage Publications},
	editor = {Handel, Michael J.},
	year = {2003},
	keywords = {Organizational sociology},
	file = {Handel - 2003 - The sociology of organizations classic, contempor.pdf:/Users/chakibbelgaid/Zotero newone/storage/4GJNGSX3/Handel - 2003 - The sociology of organizations classic, contempor.pdf:application/pdf},
}

@article{adolph_using_2011,
	title = {Using grounded theory to study the experience of software development},
	volume = {16},
	issn = {1382-3256, 1573-7616},
	url = {http://link.springer.com/10.1007/s10664-010-9152-6},
	doi = {10.1007/s10664-010-9152-6},
	abstract = {We are engaged in a qualitative research project to understand how people manage the process of software development. This study uses grounded theory as its method of inquiry and we have learned much about what is and what is not a grounded theory. We, like many researchers have claimed to follow grounded theory methods and even to have produced a grounded theory. In reality, we often only borrow a few grounded theory practices to categorize our data. This paper presents lessons learned about using grounded theory so that both researchers and reviewers can critically evaluate investigators' claims to be producing grounded theory.},
	language = {en},
	number = {4},
	urldate = {2020-01-29},
	journal = {Empirical Software Engineering},
	author = {Adolph, Steve and Hall, Wendy and Kruchten, Philippe},
	month = aug,
	year = {2011},
	pages = {487--513},
	file = {Adolph et al. - 2011 - Using grounded theory to study the experience of s.pdf:/Users/chakibbelgaid/Zotero newone/storage/24KYHGMI/Adolph et al. - 2011 - Using grounded theory to study the experience of s.pdf:application/pdf},
}

@inproceedings{sahin_how_2014-1,
	address = {Torino, Italy},
	title = {How do code refactorings affect energy usage?},
	isbn = {978-1-4503-2774-9},
	url = {http://dl.acm.org/citation.cfm?doid=2652524.2652538},
	doi = {10.1145/2652524.2652538},
	abstract = {Method: We conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly-used refactorings.
Results: We found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application. In addition, we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring.
Conclusion: The results from this and similar studies could be used to augment IDEs to help software developers build more energy eﬃcient software.},
	language = {en},
	urldate = {2020-01-29},
	booktitle = {Proceedings of the 8th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement} - {ESEM} '14},
	publisher = {ACM Press},
	author = {Sahin, Cagri and Pollock, Lori and Clause, James},
	year = {2014},
	pages = {1--10},
	file = {Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf:/Users/chakibbelgaid/Zotero newone/storage/EHDHJVIX/Sahin et al. - 2014 - How do code refactorings affect energy usage.pdf:application/pdf},
}

@inproceedings{sahin_how_2014-2,
	address = {Victoria, BC, Canada},
	title = {How {Does} {Code} {Obfuscation} {Impact} {Energy} {Usage}?},
	isbn = {978-1-4799-6146-7},
	url = {http://ieeexplore.ieee.org/document/6976079/},
	doi = {10.1109/ICSME.2014.35},
	abstract = {Software piracy is an important concern for application developers. Such concerns are especially relevant in mobile application development, where piracy rates can approach 90\%. The most commonly used approach by mobile developers for preventing piracy is code obfuscation. However, the decision to apply such transformations is currently made without regard to the impacts of obfuscations on another area of increasing concern for mobile application developers: energy consumption. Because both software piracy and battery life are important concerns, mobile application developers must strike a balance between protecting their applications and preserving the battery lives of their users’ devices. To help them make such choices, we conducted an empirical study of the effects of 18 code obfuscations on the amount of energy consumed by executing a total of 15 usage scenarios spread across 11 Android applications. The results of the study indicate that, while obfuscations can have a statistically signiﬁcant impact on energy usage and are signiﬁcantly more likely to increase energy usage than to decrease energy usage, the magnitudes of such impacts are unlikely to impact mobile application users.},
	language = {en},
	urldate = {2020-01-29},
	booktitle = {2014 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution}},
	publisher = {IEEE},
	author = {Sahin, Cagri and Tornquist, Philip and Mckenna, Ryan and Pearson, Zachary and Clause, James},
	month = sep,
	year = {2014},
	pages = {131--140},
	file = {Sahin et al. - 2014 - How Does Code Obfuscation Impact Energy Usage.pdf:/Users/chakibbelgaid/Zotero newone/storage/53A3WXYK/Sahin et al. - 2014 - How Does Code Obfuscation Impact Energy Usage.pdf:application/pdf},
}

@article{pathak_bootstrapping_nodate,
	title = {Bootstrapping {Energy} {Debugging} on {Smartphones}: {A} {First} {Look} at {Energy} {Bugs} in {Mobile} {Devices}},
	abstract = {This paper argues that a new class of bugs faced by millions of smartphones, energy bugs or ebugs, have become increasingly prominent that already they have led to significant user frustrations. We take a ﬁrst look at this emerging important technical challenge faced by the smartphones, ebugs, broadly deﬁned as an error in the system (application, OS, hardware, ﬁrmware, external conditions or combination) that causes an unexpected amount of high energy consumption by the system as a whole. We ﬁrst present a taxonomy of the kinds of ebugs based on mining over 39K posts (1.2M before ﬁltering) from 4 online mobile user forum and mobile OS bug repositories. The taxonomy shows the highly diverse nature of smartphone ebugs. We then propose a roadmap towards developing a systematic diagnosing framework for debugging ebugs on smartphones.},
	language = {en},
	author = {Pathak, Abhinav and Hu, Y Charlie and Zhang, Ming},
	pages = {6},
	file = {Pathak et al. - Bootstrapping Energy Debugging on Smartphones A F.pdf:/Users/chakibbelgaid/Zotero newone/storage/7Q6TZA97/Pathak et al. - Bootstrapping Energy Debugging on Smartphones A F.pdf:application/pdf},
}

@inproceedings{manotas_investigating_2013,
	address = {San Francisco, CA, USA},
	title = {Investigating the impacts of web servers on web application energy usage},
	isbn = {978-1-4673-6267-2},
	url = {http://ieeexplore.ieee.org/document/6606417/},
	doi = {10.1109/GREENS.2013.6606417},
	abstract = {Software engineers make decisions about the design of the software they are creating on a daily basis. These decisions may impact the application in terms of efﬁciency, usability, ﬂexibility, etc. Different competing design decisions are therefore often evaluated in terms of their projected impact on quality metrics prior to implementation. Recently energy has become a concern for software systems, ranging from mobile devices to large data centers. Additionally, it has been recognized that the software executing on a computing device can have a signiﬁcant impact on the device’s energy consumption. This raises the obvious question of whether or not it is possible to reduce the energy consumption of a software system by the means of software design decisions.},
	language = {en},
	urldate = {2020-01-29},
	booktitle = {2013 2nd {International} {Workshop} on {Green} and {Sustainable} {Software} ({GREENS})},
	publisher = {IEEE},
	author = {Manotas, Irene and Sahin, Cagri and Clause, James and Pollock, Lori and Winbladh, Kristina},
	month = may,
	year = {2013},
	pages = {16--23},
	file = {TSE_Preprint.pdf:/Users/chakibbelgaid/Zotero newone/storage/TUSFUGUL/TSE_Preprint.pdf:application/pdf;Manotas et al. - 2013 - Investigating the impacts of web servers on web ap.pdf:/Users/chakibbelgaid/Zotero newone/storage/YDCZX827/Manotas et al. - 2013 - Investigating the impacts of web servers on web ap.pdf:application/pdf},
}

@inproceedings{linares-vasquez_mining_2014,
	address = {Hyderabad, India},
	title = {Mining energy-greedy {API} usage patterns in {Android} apps: an empirical study},
	isbn = {978-1-4503-2863-0},
	shorttitle = {Mining energy-greedy {API} usage patterns in {Android} apps},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597085},
	doi = {10.1145/2597073.2597085},
	abstract = {Energy consumption of mobile applications is nowadays a hot topic, given the widespread use of mobile devices. The high demand for features and improved user experience, given the available powerful hardware, tend to increase the apps’ energy consumption. However, excessive energy consumption in mobile apps could also be a consequence of energy greedy hardware, bad programming practices, or particular API usage patterns. We present the largest to date quantitative and qualitative empirical investigation into the categories of API calls and usage patterns that—in the context of the Android development framework—exhibit particularly high energy consumption proﬁles. By using a hardware power monitor, we measure energy consumption of method calls when executing typical usage scenarios in 55 mobile apps from diﬀerent domains. Based on the collected data, we mine and analyze energy-greedy APIs and usage patterns. We zoom in and discuss the cases where either the anomalous energy consumption is unavoidable or where it is due to suboptimal usage or choice of APIs. Finally, we synthesize our ﬁndings into actionable knowledge and recipes for developers on how to reduce energy consumption while using certain categories of Android APIs and patterns.},
	language = {en},
	urldate = {2020-01-29},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories} - {MSR} 2014},
	publisher = {ACM Press},
	author = {Linares-Vásquez, Mario and Bavota, Gabriele and Bernal-Cárdenas, Carlos and Oliveto, Rocco and Di Penta, Massimiliano and Poshyvanyk, Denys},
	year = {2014},
	pages = {2--11},
	file = {Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf:/Users/chakibbelgaid/Zotero newone/storage/HE8YC4SK/Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf:application/pdf},
}

@inproceedings{li_investigation_2014,
	address = {Hyderabad, India},
	title = {An investigation into energy-saving programming practices for {Android} smartphone app development},
	isbn = {978-1-4503-2844-9},
	url = {http://dl.acm.org/citation.cfm?doid=2593743.2593750},
	doi = {10.1145/2593743.2593750},
	abstract = {Developing energy eﬃcient mobile applications is an important goal for software developers as energy usage can directly aﬀect the usability of a mobile device. Unfortunately, developers lack guidance as to how to improve the energy eﬃciency of their implementation and which practices are most useful. In this paper we conducted a small-scale empirical evaluation of commonly suggested energy-saving and performance-enhancing coding practices. In the evaluation we evaluated the degree to which these practices were able to save energy as compared to their unoptimized code counterparts. Our results provide useful guidance for mobile app developers. In particular, we found that bundling network packets up to a certain size and using certain coding practices for reading array length information, accessing class ﬁelds, and performing invocations all led to reduced energy consumption. However, other practices, such as limiting memory usage had a very minimal impact on energy usage. These results serve to inform the developer community about speciﬁc coding practices that can help lower the overall energy consumption and improve the usability of their applications.},
	language = {en},
	urldate = {2020-01-29},
	booktitle = {Proceedings of the 3rd {International} {Workshop} on {Green} and {Sustainable} {Software} - {GREENS} 2014},
	publisher = {ACM Press},
	author = {Li, Ding and Halfond, William G. J.},
	year = {2014},
	pages = {46--53},
	file = {Li and Halfond - 2014 - An investigation into energy-saving programming pr.pdf:/Users/chakibbelgaid/Zotero newone/storage/RBHHQKZ7/Li and Halfond - 2014 - An investigation into energy-saving programming pr.pdf:application/pdf},
}

@inproceedings{johnson_why_2013,
	address = {San Francisco, CA, USA},
	title = {Why don't software developers use static analysis tools to find bugs?},
	isbn = {978-1-4673-3076-3 978-1-4673-3073-2},
	url = {http://ieeexplore.ieee.org/document/6606613/},
	doi = {10.1109/ICSE.2013.6606613},
	abstract = {Using static analysis tools for automating code inspections can be beneﬁcial for software engineers. Such tools can make ﬁnding bugs, or software defects, faster and cheaper than manual inspections. Despite the beneﬁts of using static analysis tools to ﬁnd bugs, research suggests that these tools are underused. In this paper, we investigate why developers are not widely using static analysis tools and how current tools could potentially be improved. We conducted interviews with 20 developers and found that although all of our participants felt that use is beneﬁcial, false positives and the way in which the warnings are presented, among other things, are barriers to use. We discuss several implications of these results, such as the need for an interactive mechanism to help developers ﬁx defects.},
	language = {en},
	urldate = {2020-01-29},
	booktitle = {2013 35th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Johnson, Brittany and Song, Yoonki and Murphy-Hill, Emerson and Bowdidge, Robert},
	month = may,
	year = {2013},
	pages = {672--681},
	file = {Johnson et al. - 2013 - Why don't software developers use static analysis .pdf:/Users/chakibbelgaid/Zotero newone/storage/6IH6HRJR/Johnson et al. - 2013 - Why don't software developers use static analysis .pdf:application/pdf},
}

@inproceedings{pinto_mining_2014-1,
	address = {Hyderabad, India},
	title = {Mining questions about software energy consumption},
	isbn = {978-1-4503-2863-0},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597110},
	doi = {10.1145/2597073.2597110},
	abstract = {A growing number of software solutions have been proposed to address application-level energy consumption problems in the last few years. However, little is known about how much software developers are concerned about energy consumption, what aspects of energy consumption they consider important, and what solutions they have in mind for improving energy eﬃciency. In this paper we present the ﬁrst empirical study on understanding the views of application programmers on software energy consumption problems. Using StackOverflow as our primary data source, we analyze a carefully curated sample of more than 300 questions and 550 answers from more than 800 users. With this data, we observed a number of interesting ﬁndings. Our study shows that practitioners are aware of the energy consumption problems: the questions they ask are not only diverse – we found 5 main themes of questions – but also often more interesting and challenging when compared to the control question set. Even though energy consumption-related questions are popular when considering a number of diﬀerent popularity measures, the same cannot be said about the quality of their answers. In addition, we observed that some of these answers are often ﬂawed or vague. We contrast the advice provided by these answers with the state-of-the-art research on energy consumption. Our summary of software energy consumption problems may help researchers focus on what matters the most to software developers and end users.},
	language = {en},
	urldate = {2020-01-22},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories} - {MSR} 2014},
	publisher = {ACM Press},
	author = {Pinto, Gustavo and Castor, Fernando and Liu, Yu David},
	year = {2014},
	pages = {22--31},
	file = {Pinto et al. - 2014 - Mining questions about software energy consumption.pdf:/Users/chakibbelgaid/Zotero newone/storage/SLL5S5EC/Pinto et al. - 2014 - Mining questions about software energy consumption.pdf:application/pdf},
}

@article{pang_what_2015,
	title = {What do programmers know about the energy consumption of software?},
	abstract = {Traditionally, programmers have received a wide range of training on programming languages and methodologies, but rarely about software energy consumption. Yet, the popularity of mobile devices and cloud computing require increased awareness about software energy consumption. On a mobile device, computation is often limited by the battery life. Under the demands of cloud computing, data centers struggle to reduce energy consumption through virtualization and data center infrastructure management (DCIM) systems. Efﬁcient energy consumption of software is increasingly becoming an important non-functional requirement for programmers. However, are programmers knowledgeable enough about software energy consumption? Do programmers base their implementation decision on popular beliefs? In this article, we survey over 100 programmers for their knowledge of software energy consumption. We ﬁnd that programmers have limited knowledge about energy efﬁciency, lack knowledge about the best practices to reduce energy consumption of software, and are often unsure about how software consumes energy. Education about the importance of energy effective software will beneﬁt the programmers. Our results highlight the need for training about energy consumption and efﬁciency.},
	language = {en},
	author = {Pang, Candy and Hindle, Abram and Adams, Bram and Hassan, Ahmed E},
	year = {2015},
	pages = {11},
	file = {Pang et al. - 2015 - What do programmers know about the energy consumpt.pdf:/Users/chakibbelgaid/Zotero newone/storage/69XSFCC7/Pang et al. - 2015 - What do programmers know about the energy consumpt.pdf:application/pdf},
}

@inproceedings{manotas_empirical_2016,
	address = {Austin, Texas},
	title = {An empirical study of practitioners' perspectives on green software engineering},
	isbn = {978-1-4503-3900-1},
	url = {http://dl.acm.org/citation.cfm?doid=2884781.2884810},
	doi = {10.1145/2884781.2884810},
	abstract = {The energy consumption of software is an increasing concern as the use of mobile applications, embedded systems, and data center-based services expands. While research in green software engineering is correspondingly increasing, little is known about the current practices and perspectives of software engineers in the ﬁeld. This paper describes the ﬁrst empirical study of how practitioners think about energy when they write requirements, design, construct, test, and maintain their software. We report ﬁndings from a quantitative, targeted survey of 464 practitioners from ABB, Google, IBM, and Microsoft, which was motivated by and supported with qualitative data from 18 in-depth interviews with Microsoft employees. The major ﬁndings and implications from the collected data contextualize existing green software engineering research and suggest directions for researchers aiming to develop strategies and tools to help practitioners improve the energy usage of their applications.},
	language = {en},
	urldate = {2020-01-22},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} - {ICSE} '16},
	publisher = {ACM Press},
	author = {Manotas, Irene and Bird, Christian and Zhang, Rui and Shepherd, David and Jaspan, Ciera and Sadowski, Caitlin and Pollock, Lori and Clause, James},
	year = {2016},
	pages = {237--248},
	annote = {Empirical + qual study
related works section *
no defined questions for qual stdy
ref for the fact that mobile devs  are more conserned
 
add values :
sensibilization issues/ tool descrption and technology consideration},
	file = {Manotas et al. - 2016 - An empirical study of practitioners' perspectives .pdf:/Users/chakibbelgaid/Zotero newone/storage/83YQV8PC/Manotas et al. - 2016 - An empirical study of practitioners' perspectives .pdf:application/pdf},
}

@article{pang_what_2015-1,
	title = {What do programmers know about the energy consumption of software?},
	abstract = {Traditionally, programmers have received a wide range of training on programming languages and methodologies, but rarely about software energy consumption. Yet, the popularity of mobile devices and cloud computing require increased awareness about software energy consumption. On a mobile device, computation is often limited by the battery life. Under the demands of cloud computing, data centers struggle to reduce energy consumption through virtualization and data center infrastructure management (DCIM) systems. Efﬁcient energy consumption of software is increasingly becoming an important non-functional requirement for programmers. However, are programmers knowledgeable enough about software energy consumption? Do programmers base their implementation decision on popular beliefs? In this article, we survey over 100 programmers for their knowledge of software energy consumption. We ﬁnd that programmers have limited knowledge about energy efﬁciency, lack knowledge about the best practices to reduce energy consumption of software, and are often unsure about how software consumes energy. Education about the importance of energy effective software will beneﬁt the programmers. Our results highlight the need for training about energy consumption and efﬁciency.},
	language = {en},
	author = {Pang, Candy and Hindle, Abram and Adams, Bram and Hassan, Ahmed E},
	year = {2015},
	pages = {11},
	file = {Pang et al. - 2015 - What do programmers know about the energy consumpt.pdf:/Users/chakibbelgaid/Zotero newone/storage/WF7CCL3I/Pang et al. - 2015 - What do programmers know about the energy consumpt.pdf:application/pdf},
}

@book{flick_companion_2004,
	address = {London ; Thousand Oaks, Calif},
	title = {A companion to qualitative research},
	isbn = {978-0-7619-7374-4},
	language = {en},
	publisher = {Sage Publications},
	editor = {Flick, Uwe and Kardorff, Ernst von and Steinke, Ines},
	year = {2004},
	keywords = {Methodology, Qualitative research, Research, Social sciences},
	file = {Flick et al. - 2004 - A companion to qualitative research.pdf:/Users/chakibbelgaid/Zotero newone/storage/MR2IUEHS/Flick et al. - 2004 - A companion to qualitative research.pdf:application/pdf},
}

@article{oliver_constraints_2005-1,
	title = {Constraints and {Opportunities} with {Interview} {Transcription}: {Towards} {Reflection} in {Qualitative} {Research}},
	volume = {84},
	issn = {0037-7732, 1534-7605},
	shorttitle = {Constraints and {Opportunities} with {Interview} {Transcription}},
	url = {https://academic.oup.com/sf/article-lookup/doi/10.1353/sof.2006.0023},
	doi = {10.1353/sof.2006.0023},
	abstract = {In this paper we discuss the complexities of interview transcription. While often seen as a behind-the-scenes task, we suggest that transcription is a powerful act of representation. Transcription is practiced in multiple ways, often using naturalism, in which every utterance is captured in as much detail as possible, and/or denaturalism, in which grammar is corrected, interview noise (e.g., stutters, pauses, etc.) is removed and nonstandard accents (i.e., non-majority) are standardized. In this article, we discuss the constraints and opportunities of our transcription decisions and point to an intermediate, reflective step. We suggest that researchers incorporate reflection into their research design by interrogating their transcription decisions and the possible impact these decisions may have on participants and research outcomes.},
	language = {en},
	number = {2},
	urldate = {2019-10-17},
	journal = {Social Forces},
	author = {Oliver, D. G. and Serovich, J. M. and Mason, T. L.},
	month = dec,
	year = {2005},
	pages = {1273--1289},
	file = {Oliver et al. - 2005 - Constraints and Opportunities with Interview Trans.pdf:/Users/chakibbelgaid/Zotero newone/storage/CBN3UKTR/Oliver et al. - 2005 - Constraints and Opportunities with Interview Trans.pdf:application/pdf},
}

@misc{noauthor_pdf_nodate,
	title = {({PDF}) {Classic} {Grounded} {Theory}-{The} {Latest} {Version}: {Interpretation} of {Classic} {Grounded} {Theory} as a {Meta}-{Theory} for {Research}: {Classic} {Grounded} {Theory}},
	url = {https://www.researchgate.net/publication/324116729_Classic_Grounded_Theory-The_Latest_Version_Interpretation_of_Classic_Grounded_Theory_as_a_Meta-Theory_for_Research_Classic_Grounded_Theory},
	urldate = {2019-10-17},
	file = {(PDF) Classic Grounded Theory-The Latest Version\: Interpretation of Classic Grounded Theory as a Meta-Theory for Research\: Classic Grounded Theory:/Users/chakibbelgaid/Zotero newone/storage/92GSDHHD/324116729_Classic_Grounded_Theory-The_Latest_Version_Interpretation_of_Classic_Grounded_Theory_.html:text/html},
}

@book{creswell_research_2003,
	address = {Thousand Oaks, Calif},
	edition = {2nd ed},
	title = {Research design: qualitative, quantitative, and mixed method approaches},
	isbn = {978-0-7619-2441-8 978-0-7619-2442-5},
	shorttitle = {Research design},
	language = {en},
	publisher = {Sage Publications},
	author = {Creswell, John W.},
	year = {2003},
	keywords = {Social sciences, Research Methodology, Statistical methods},
	annote = {open-ended semi-structered interviews},
	file = {Creswell - 2003 - Research design qualitative, quantitative, and mi.pdf:/Users/chakibbelgaid/Zotero newone/storage/MAVAFMY7/Creswell - 2003 - Research design qualitative, quantitative, and mi.pdf:application/pdf},
}

@inproceedings{habchi_adopting_2018,
	address = {Montpellier, France},
	title = {On adopting linters to deal with performance concerns in {Android} apps},
	isbn = {978-1-4503-5937-5},
	url = {http://dl.acm.org/citation.cfm?doid=3238147.3238197},
	doi = {10.1145/3238147.3238197},
	abstract = {With millions of applications (apps) distributed through mobile markets, engaging and retaining end-users challenge Android developers to deliver a nearly perfect user experience. As mobile apps run in resource-limited devices, performance is a critical criterion for the quality of experience. Therefore, developers are expected to pay much attention to limit performance bad practices. On the one hand, many studies already identified such performance bad practices and showed that they can heavily impact app performance. Hence, many static analysers, a.k.a. linters, have been proposed to detect and fix these bad practices. On the other hand, other studies have shown that Android developers tend to deal with performance reactively and they rarely build on linters to detect and fix performance bad practices. In this paper, we therefore perform a qualitative study to investigate this gap between research and development community. In particular, we performed interviews with 14 experienced Android developers to identify the perceived benefits and constraints of using linters to identify performance bad practices in Android apps. Our observations can have a direct impact on developers and the research community. Specifically, we describe why and how developers leverage static source code analysers to improve the performance of their apps. On top of that, we bring to light important challenges faced by developers when it comes to adopting static analysis for performance purposes.},
	language = {en},
	urldate = {2019-10-17},
	booktitle = {Proceedings of the 33rd {ACM}/{IEEE} {International} {Conference} on {Automated} {Software} {Engineering}  - {ASE} 2018},
	publisher = {ACM Press},
	author = {Habchi, Sarra and Blanc, Xavier and Rouvoy, Romain},
	year = {2018},
	pages = {6--16},
	file = {Habchi et al. - 2018 - On adopting linters to deal with performance conce.pdf:/Users/chakibbelgaid/Zotero newone/storage/MD6EAHPZ/Habchi et al. - 2018 - On adopting linters to deal with performance conce.pdf:application/pdf},
}

@inproceedings{pinto_comprehensive_2016-1,
	address = {Raleigh, NC, USA},
	title = {A {Comprehensive} {Study} on the {Energy} {Efficiency} of {Java}’s {Thread}-{Safe} {Collections}},
	isbn = {978-1-5090-3806-0},
	url = {http://ieeexplore.ieee.org/document/7816451/},
	doi = {10.1109/ICSME.2016.34},
	language = {en},
	urldate = {2019-09-24},
	booktitle = {2016 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	publisher = {IEEE},
	author = {Pinto, Gustavo and Liu, Kenan and Castor, Fernando and Liu, Yu David},
	month = oct,
	year = {2016},
	pages = {20--31},
	file = {Pinto et al. - 2016 - A Comprehensive Study on the Energy Efficiency of .pdf:/Users/chakibbelgaid/Zotero newone/storage/GZ2VE93R/Pinto et al. - 2016 - A Comprehensive Study on the Energy Efficiency of .pdf:application/pdf},
}

@article{w_g_p_silva_evaluation_2010,
	title = {Evaluation of the impact of code refactoring on embedded software efficiency},
	url = {http://rgdoi.net/10.13140/2.1.1481.8249},
	doi = {10.13140/2.1.1481.8249},
	abstract = {The increasing complexity of embedded software and the hard timeto-market requirements, motivate to the use of object-oriented languages. However, this usage can negatively impact on energy consumption as well as on performance. Code refactoring are techniques that change the code in order to improve the software quality. This paper analyzes how the inline method refactoring, a software optimization technique, can impact on the performance and energy of embedded software written in Java. Three different applications are evaluated in order to discuss this impact.},
	language = {en},
	urldate = {2019-09-20},
	journal = {Unpublished},
	author = {{W G P Silva} and {Lisane Brisolara} and Corrêa, Ulisses Brisolara and Carro, Luigi},
	year = {2010},
	annote = {Enrgic analyses of  methodes inlining of java applications
 
- showed that the inlining methode is efficient for small application but can give tricky resultd for bigger application (MPEG decoder example)
 
no JIT  consideration},
	file = {W G P Silva et al. - 2010 - Evaluation of the impact of code refactoring on em.pdf:/Users/chakibbelgaid/Zotero newone/storage/VDRSNI5F/W G P Silva et al. - 2010 - Evaluation of the impact of code refactoring on em.pdf:application/pdf},
}

@inproceedings{bruce_reducing_2015-1,
	address = {Madrid, Spain},
	title = {Reducing {Energy} {Consumption} {Using} {Genetic} {Improvement}},
	isbn = {978-1-4503-3472-3},
	url = {http://dl.acm.org/citation.cfm?doid=2739480.2754752},
	doi = {10.1145/2739480.2754752},
	abstract = {Genetic Improvement (GI) is an area of Search Based Software Engineering which seeks to improve software’s nonfunctional properties by treating program code as if it were genetic material which is then evolved to produce more optimal solutions. Hitherto, the majority of focus has been on optimising program’s execution time which, though important, is only one of many non-functional targets. The growth in mobile computing, cloud computing infrastructure, and ecological concerns are forcing developers to focus on the energy their software consumes. We report on investigations into using GI to automatically ﬁnd more energy eﬃcient versions of the MiniSAT Boolean satisﬁability solver when specialising for three downstream applications. Our results ﬁnd that GI can successfully be used to reduce energy consumption by up to 25\%.},
	language = {en},
	urldate = {2019-09-20},
	booktitle = {Proceedings of the 2015 on {Genetic} and {Evolutionary} {Computation} {Conference} - {GECCO} '15},
	publisher = {ACM Press},
	author = {Bruce, Bobby R. and Petke, Justyna and Harman, Mark},
	year = {2015},
	pages = {1327--1334},
	annote = {MINISAT genetic implementation with energy efficiecy consideration
- mostly related to Minisat
 },
	file = {Bruce et al. - 2015 - Reducing Energy Consumption Using Genetic Improvem.pdf:/Users/chakibbelgaid/Zotero newone/storage/W52BBN5J/Bruce et al. - 2015 - Reducing Energy Consumption Using Genetic Improvem.pdf:application/pdf},
}

@incollection{meyer_search_2012,
	address = {Berlin, Heidelberg},
	title = {Search {Based} {Software} {Engineering}: {Techniques}, {Taxonomy}, {Tutorial}},
	volume = {7007},
	isbn = {978-3-642-25230-3 978-3-642-25231-0},
	shorttitle = {Search {Based} {Software} {Engineering}},
	url = {http://link.springer.com/10.1007/978-3-642-25231-0_1},
	abstract = {The aim of Search Based Software Engineering (SBSE) research is to move software engineering problems from human-based search to machine-based search, using a variety of techniques from the metaheuristic search, operations research and evolutionary computation paradigms. The idea is to exploit humans’ creativity and machines’ tenacity and reliability, rather than requiring humans to perform the more tedious, error prone and thereby costly aspects of the engineering process. SBSE can also provide insights and decision support. This tutorial will present the reader with a step-by-step guide to the application of SBSE techniques to Software Engineering. It assumes neither previous knowledge nor experience with Search Based Optimisation. The intention is that the tutorial will cover suﬃcient material to allow the reader to become productive in successfully applying search based optimisation to a chosen Software Engineering problem of interest.},
	language = {en},
	urldate = {2019-09-20},
	booktitle = {Empirical {Software} {Engineering} and {Verification}},
	publisher = {Springer Berlin Heidelberg},
	author = {Harman, Mark and McMinn, Phil and de Souza, Jerffeson Teixeira and Yoo, Shin},
	editor = {Meyer, Bertrand and Nordio, Martin},
	year = {2012},
	doi = {10.1007/978-3-642-25231-0_1},
	pages = {1--59},
	annote = {SBSE methods SOTA and explanations},
	file = {Harman et al. - 2012 - Search Based Software Engineering Techniques, Tax.pdf:/Users/chakibbelgaid/Zotero newone/storage/3KNRIR5P/Harman et al. - 2012 - Search Based Software Engineering Techniques, Tax.pdf:application/pdf},
}

@incollection{grass_energy_2006,
	address = {Berlin, Heidelberg},
	title = {An {Energy} {Consumption} {Model} for an {Embedded} {Java} {Virtual} {Machine}},
	volume = {3894},
	isbn = {978-3-540-32765-3 978-3-540-32766-0},
	url = {http://link.springer.com/10.1007/11682127_22},
	abstract = {In recent years we have seen an explosion of markets for portable electronic devices such as PDAs, personal communicators and mobile phones. The size and complexity of applications, but also development constraints like getting the product to market on time make the use of high-level languages like Java necessary. Java 2 Micro Edition (J2ME) has emerged as a good solution for developing applications on those platforms. The main goal of Java language is to allow applications development with an abstraction of the target platform, making the concept “write once, run it anywhere” possible. The Java Virtual machine (JVM) is an abstract machine, making the interface between platform independent applications and the hardware, through a possible operating system. Thus the use of Java language can be seen as adding one more layer, the Java virtual machine, between the hardware and software layers. In this paper we establish a general framework for estimating the energy consumption of an embedded Java virtual machine. We have designed a number of experiments to ﬁnd the constants overhead of the Virtual Machine and establish energy consumption cost for individual Java Opcodes. The results show that there is a basic constant overhead that is equal for every Java program, and a that a subset of Java opcodes have an almost constant energy cost. We also show that memory access is a crucial energy consumption component.},
	language = {en},
	urldate = {2019-09-19},
	booktitle = {Architecture of {Computing} {Systems} - {ARCS} 2006},
	publisher = {Springer Berlin Heidelberg},
	author = {Lafond, Sébastien and Lilius, Johan},
	editor = {Grass, Werner and Sick, Bernhard and Waldschmidt, Klaus},
	year = {2006},
	doi = {10.1007/11682127_22},
	pages = {311--325},
	annote = {Per- bytecode instruction energy measurment.
using a KVM environnement tand ARMulator to  emulate the JVM
 
the distribution between the processor and memories is constant over thM execution with 70\% of the energy consumed through memory access},
	file = {Lafond and Lilius - 2006 - An Energy Consumption Model for an Embedded Java V.pdf:/Users/chakibbelgaid/Zotero newone/storage/4CEWSS2C/Lafond and Lilius - 2006 - An Energy Consumption Model for an Embedded Java V.pdf:application/pdf},
}

@article{navas_safe_nodate,
	title = {Safe {Upper}-bounds {Inference} of {Energy} {Consumption} for {Java} {Bytecode} {Applications} ({Extended} {Abstract})},
	language = {en},
	author = {Navas, Jorge and Mendez-Lojo, Mario and Hermenegildo, Manuel V},
	pages = {3},
	file = {Navas et al. - Safe Upper-bounds Inference of Energy Consumption .pdf:/Users/chakibbelgaid/Zotero newone/storage/J4F8WSG2/Navas et al. - Safe Upper-bounds Inference of Energy Consumption .pdf:application/pdf},
}

@article{wilke_aspects_nodate,
	title = {Aspects of {Software}’s {Energy} {Consumption}},
	abstract = {The CoolSoftware project focuses on optimizing software’s energy consumption due to energy auto-tuning at runtime. A prerequisite for software’s energy consumption optimization was to identify the diﬀerent aspects that inﬂuence the energy consumption. This report summarizes the results of a literature study w.r.t. energy consumption investigations on software applications. Furthermore, it outlines the diﬀerent identiﬁed aspects that have to be considered when optimizing software w.r.t. its energy consumption.},
	language = {en},
	author = {Wilke, Claas and Gotz, Sebastian and Cech, Sebastian and Waltsgott, Johannes and Fritzsche, Ronny},
	pages = {13},
	annote = {Good SOTA about  energy efficiency in hardware, mobile and software
 
aspects qui affetent  la cnoso :
1.HW resources as CPU and hard drives,2.HW infrastructure as power supply and fans,3.Middleware as the operating system (OS),4.Communication as network devices,5.Users’ workloads and expected utility,6.Software itself (i.e., code).
 
10},
	file = {Wilke et al. - Aspects of Software’s Energy Consumption.pdf:/Users/chakibbelgaid/Zotero newone/storage/LP6D8SID/Wilke et al. - Aspects of Software’s Energy Consumption.pdf:application/pdf},
}

@inproceedings{pinto_refactoring_2015,
	address = {Florence, Italy},
	title = {Refactoring for {Energy} {Efficiency}: {A} {Reflection} on the {State} of the {Art}},
	isbn = {978-1-4673-7049-3},
	shorttitle = {Refactoring for {Energy} {Efficiency}},
	url = {http://ieeexplore.ieee.org/document/7168335/},
	doi = {10.1109/GREENS.2015.12},
	abstract = {Recent refactoring research introduced several innovations addressing diverse goals, such code extensibility, reusability, and testability. However, energy consumption, a critical property of any software system, remains unaddressed by refactoring research. In this paper, we provide an accounting of some of the recent and successful state-of-the-art research on software energy consumption. Through an investigation on premiere software engineering venues, we identify and discuss 12 contributions that can be further instantiated in refactoring tools used to improve software energy efﬁciency — and the challenges behind this process. These opportunities span a wide range of software characteristics, such as mobile applications and concurrent programming. Mobile applications is the topic with the greatest number of opportunities (6 out of 11). The study serves as a call to action for refactoring researchers interested in software energy consumption issues.},
	language = {en},
	urldate = {2019-09-11},
	booktitle = {2015 {IEEE}/{ACM} 4th {International} {Workshop} on {Green} and {Sustainable} {Software}},
	publisher = {IEEE},
	author = {Pinto, Gustavo and Soares-Neto, Francisco and Castor, Fernando},
	month = may,
	year = {2015},
	pages = {29--35},
	file = {Pinto et al. - 2015 - Refactoring for Energy Efficiency A Reflection on.pdf:/Users/chakibbelgaid/Zotero newone/storage/PIZ86ET3/Pinto et al. - 2015 - Refactoring for Energy Efficiency A Reflection on.pdf:application/pdf},
}

@article{liu_energy_2018,
	title = {Energy {Consumption} {Fuzzy} {Estimation} for {Object}-{Oriented} {Code}},
	volume = {6},
	issn = {2169-3536},
	url = {https://ieeexplore.ieee.org/document/8502122/},
	doi = {10.1109/ACCESS.2018.2877082},
	abstract = {The energy consumption (EC) estimation of a computing system is a primitive approach for evaluating its energy efﬁciency and for further optimization. Existing studies adopt the runtime-dependent approach to measure the EC of software; however, in this paper, the source-level and fuzzy estimation approach are employed to measure the EC of software code, especially object-oriented code, before it is executed. This approach is beneﬁcial to source code quality improvement and EC static optimization. For runtime independence, a fuzzy energy consumption (FEC) model is proposed, in which the code and the EC model, as well as the mappings between them, are ﬁrst deﬁned; then, the process for estimating the FEC of an arbitrary statement is described, including the statement features, data preparation, fuzzy comprehensive evaluation, and fuzzy pattern matching. Finally, experiments are performed, including the regularities veriﬁcation, the statement features analysis, the EC and FEC comparison, and the FEC application. The experimental results show that the mean values of EC/FEC for the selected test cases are stable, their standard deviation is approximately 0.00064, and their mean is approximately 0.0059. By FEC, it is feasible to compare the ECs of code statically with reasonable accuracy.},
	language = {en},
	urldate = {2019-09-10},
	journal = {IEEE Access},
	author = {Liu, Hui and Yan, Fusheng and Jiang, Jingqing and Song, Jie},
	year = {2018},
	pages = {62664--62674},
	file = {Liu et al. - 2018 - Energy Consumption Fuzzy Estimation for Object-Ori.pdf:/Users/chakibbelgaid/Zotero newone/storage/P34XNAQM/Liu et al. - 2018 - Energy Consumption Fuzzy Estimation for Object-Ori.pdf:application/pdf},
}

@article{brownlee_search-based_2017,
	title = {Search-{Based} {Energy} {Optimization} of {Some} {Ubiquitous} {Algorithms}},
	volume = {1},
	issn = {2471-285X},
	url = {http://ieeexplore.ieee.org/document/7935484/},
	doi = {10.1109/TETCI.2017.2699193},
	abstract = {Reducing computational energy consumption is of growing importance, particularly at the extremes (i.e., mobile devices and datacentres). Despite the ubiquity of the Java virtual machine (JVM), very little work has been done to apply search-based software engineering (SBSE) to minimize the energy consumption of programs that run on it. We describe OPACITOR, a tool for measuring the energy consumption of JVM programs using a bytecode level model of energy cost. This has several advantages over timebased energy approximations or hardware measurements. It is 1) deterministic, 2) unaffected by the rest of the computational environment, 3) able to detect small changes in execution proﬁle, making it highly amenable to metaheuristic search, which requires locality of representation. We show how generic SBSE approaches coupled with OPACITOR achieve substantial energy savings for three widely used software components. Multilayer perceptron implementations minimizing both energy and error were found, and energy reductions of up to 70\% and 39.85\% were obtained over the original code for Quicksort and object-oriented container classes, respectively. These highlight three important considerations for automatically reducing computational energy: tuning software to particular distributions of data; trading off energy use against functional properties; and handling internal dependencies that can exist within software that render simple sweeps over program variants sub-optimal. Against these, global search greatly simpliﬁes the developer’s job, freeing development time for other tasks.},
	language = {en},
	number = {3},
	urldate = {2019-09-10},
	journal = {IEEE Transactions on Emerging Topics in Computational Intelligence},
	author = {Brownlee, Alexander Edward Ian and Burles, Nathan and Swan, Jerry},
	month = jun,
	year = {2017},
	pages = {188--201},
	annote = {- not general purpose, only for 3 use cases.
- Opacitor tool measuring the EC by the determination of the EC of each JAva OPcode instruction and summing
- disabling jit and GC for most tests
Search based approches to reduce the EC.},
	file = {Brownlee et al. - 2017 - Search-Based Energy Optimization of Some Ubiquitou.pdf:/Users/chakibbelgaid/Zotero newone/storage/329M4SV5/Brownlee et al. - 2017 - Search-Based Energy Optimization of Some Ubiquitou.pdf:application/pdf},
}

@article{rocheteau_how_nodate,
	title = {How {Green} {Are} {Java} {Best} {Coding} {Practices}?},
	language = {en},
	author = {Rocheteau, Jerome and Gaillard, Virginie and Belhaj, Lamya},
	pages = {12},
	annote = {Interessting measurment strategy (hardware tool)
numerous measurement checks, results cleaning ...
study of java 20 best practices (Loop, primitives types, string initialization...) energy saving
luck of informations about benchmarks. many  benchmarking faults
interessting (but redudant) references
 },
	file = {Rocheteau et al. - How Green Are Java Best Coding Practices.pdf:/Users/chakibbelgaid/Zotero newone/storage/8UXNRM7Z/Rocheteau et al. - How Green Are Java Best Coding Practices.pdf:application/pdf},
}

@article{colmant_next_2018,
	title = {The next 700 {CPU} power models},
	volume = {144},
	issn = {01641212},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0164121218301377},
	doi = {10.1016/j.jss.2018.07.001},
	abstract = {Software power estimation of CPUs is a central concern for energy eﬃciency and resource management in data centers. Over the last few years, a dozen of ad hoc power models have been proposed to cope with the wide diversity and the growing complexity of modern CPU architectures. However, most of these CPU power models rely on a thorough expertise of the targeted architectures, thus leading to the design of hardware-speciﬁc solutions that can hardly be ported beyond the initial settings. In this article, we rather propose a novel toolkit that uses a conﬁgurable/interchangeable learning technique to automatically learn the power model of a CPU, independently of the features and the complexity it exhibits. In particular, our learning approach automatically explores the space of hardware performance counters made available by a given CPU to isolate the ones that are best correlated to the power consumption of the host, and then infers a power model from the selected counters. Based on a middleware toolkit devoted to the implementation of software-deﬁned power meters, we implement the proposed approach to generate CPU power models for a wide diversity of CPU architectures (including Intel, ARM, and AMD processors), and using a large variety of both CPU and memoryintensive workloads. We show that the CPU power models generated by our middleware toolkit estimate the power consumption of the whole CPU or individual processes with an accuracy of 98.5\% on average, thus competing with the state-of-the-art power models.},
	language = {en},
	urldate = {2019-09-02},
	journal = {Journal of Systems and Software},
	author = {Colmant, Maxime and Rouvoy, Romain and Kurpicz, Mascha and Sobe, Anita and Felber, Pascal and Seinturier, Lionel},
	month = oct,
	year = {2018},
	pages = {382--396},
	file = {Colmant et al. - 2018 - The next 700 CPU power models.pdf:/Users/chakibbelgaid/Zotero newone/storage/XUCZDZ9C/Colmant et al. - 2018 - The next 700 CPU power models.pdf:application/pdf},
}

@incollection{noauthor_notitle_nodate,
}

@misc{noauthor_notitle_nodate-1,
}


@article{heinrich_predicting_nodate,
	title = {Predicting the {Performance} and the {Power} {Consumption} of {MPI} {Applications} {With} {SimGrid}},
	abstract = {The past decade witnessed a rapid development of powerful but energy-hungry parallel and distributed systems, making energy eﬃciency of large data centers an important optimization goal. Simulation is a popular approach for studying the behavior of HPC applications in a variety of scenarios. However, simulators are infrequently able to provide faithful performance predictions of applications and typically lack the capability of providing details about the energy consumption of the simulated platforms, especially when comprised of multi-core architectures. Furthermore, studying the impact of diﬀerent application conﬁgurations on energy consumption is a diﬃcult task as only few platforms are equipped with proper power measurement devices. In this paper, we present an extension of the SimGrid simulation toolkit that addresses these challenges. We ﬁrstly introduce a model for application energy consumption that supports dynamic voltage/frequency scaling (DVFS) of simulated processors. Secondly, we discuss means to account for coarse-grain memory eﬀects in multi-core architectures. The advantages of our approach, compared to cycle-level simulators, are faster simulation run times and enhanced scalability with, provided the target platform is correctly modeled, a retained excellent accuracy. We discuss our model in detail and demonstrate how it can be instantiated by proﬁling different applications during the calibration phase. Finally, the proposed simulator is validated through an extensive set of experiments with common HPC benchmarks.},
	language = {en},
	author = {Heinrich, Franz and Carpen-Amarie, Alexandra and Degomme, Augustin and Hunold, Sascha and Legrand, Arnaud and Orgerie, Anne-Cécile and Quinson, Martin},
	pages = {13},
	file = {Heinrich et al. - Predicting the Performance and the Power Consumpti.pdf:/Users/chakibbelgaid/Zotero newone/storage/W8CGXIHS/Heinrich et al. - Predicting the Performance and the Power Consumpti.pdf:application/pdf},
}

@article{heinrich_predicting_nodate-1,
	title = {Predicting the {Performance} and the {Power} {Consumption} of {MPI} {Applications} {With} {SimGrid}},
	abstract = {The past decade witnessed a rapid development of powerful but energy-hungry parallel and distributed systems, making energy eﬃciency of large data centers an important optimization goal. Simulation is a popular approach for studying the behavior of HPC applications in a variety of scenarios. However, simulators are infrequently able to provide faithful performance predictions of applications and typically lack the capability of providing details about the energy consumption of the simulated platforms, especially when comprised of multi-core architectures. Furthermore, studying the impact of diﬀerent application conﬁgurations on energy consumption is a diﬃcult task as only few platforms are equipped with proper power measurement devices. In this paper, we present an extension of the SimGrid simulation toolkit that addresses these challenges. We ﬁrstly introduce a model for application energy consumption that supports dynamic voltage/frequency scaling (DVFS) of simulated processors. Secondly, we discuss means to account for coarse-grain memory eﬀects in multi-core architectures. The advantages of our approach, compared to cycle-level simulators, are faster simulation run times and enhanced scalability with, provided the target platform is correctly modeled, a retained excellent accuracy. We discuss our model in detail and demonstrate how it can be instantiated by proﬁling different applications during the calibration phase. Finally, the proposed simulator is validated through an extensive set of experiments with common HPC benchmarks.},
	language = {en},
	author = {Heinrich, Franz and Carpen-Amarie, Alexandra and Degomme, Augustin and Hunold, Sascha and Legrand, Arnaud and Orgerie, Anne-Cécile and Quinson, Martin},
	pages = {13},
	file = {Heinrich et al. - Predicting the Performance and the Power Consumpti.pdf:/Users/chakibbelgaid/Zotero newone/storage/3BR2CIUM/Heinrich et al. - Predicting the Performance and the Power Consumpti.pdf:application/pdf},
}

@techreport{coles_comparing_2014,
	title = {Comparing {Server} {Energy} {Use} and {Efficiency} {Using} {Small} {Sample} {Sizes}},
	url = {http://www.osti.gov/servlets/purl/1163229/},
	language = {en},
	number = {LBNL-6831E, 1163229},
	urldate = {2019-04-08},
	author = {Coles, Henry and Qin, Yong and Price, Phillip},
	month = nov,
	year = {2014},
	doi = {10.2172/1163229},
	file = {Coles et al. - 2014 - Comparing Server Energy Use and Efficiency Using S.pdf:/Users/chakibbelgaid/Zotero newone/storage/B645DAB3/Coles et al. - 2014 - Comparing Server Energy Use and Efficiency Using S.pdf:application/pdf},
}

@article{tschanz_adaptive_2002,
	title = {Adaptive body bias for reducing impacts of die-to-die and within-die parameter variations on microprocessor frequency and leakage},
	volume = {37},
	issn = {0018-9200},
	url = {http://ieeexplore.ieee.org/document/1046081/},
	doi = {10.1109/JSSC.2002.803949},
	abstract = {Bidirectional adaptive body bias (ABB) is used to compensate for die-to-die parameter variations by applying an optimum pMOS and nMOS body bias voltage to each die which maximizes the die frequency subject to a power constraint. Measurements on a 150-nm CMOS testchip which incorporates on-chip ABB, show that ABB reduces variation in die frequency by a factor of seven, while improving the die acceptance rate. An enhancement of this technique, that compensates for within-die parameter variations as well, increases the number of dies accepted in the highest frequency bin. ABB is therefore shown to provide bin split improvement in the presence of increasing process parameter variations.},
	language = {en},
	number = {11},
	urldate = {2019-04-08},
	journal = {IEEE Journal of Solid-State Circuits},
	author = {Tschanz, J.W. and Kao, J.T. and Narendra, S.G. and Nair, R. and Antoniadis, D.A. and Chandrakasan, A.P. and De, V.},
	month = nov,
	year = {2002},
	pages = {1396--1402},
	file = {Tschanz et al. - 2002 - Adaptive body bias for reducing impacts of die-to-.pdf:/Users/chakibbelgaid/Zotero newone/storage/PTS8ELCC/Tschanz et al. - 2002 - Adaptive body bias for reducing impacts of die-to-.pdf:application/pdf;Lean-ICT-Report_The-Shift-Project_2019.pdf:/Users/chakibbelgaid/Zotero newone/storage/TMLRN2UT/Lean-ICT-Report_The-Shift-Project_2019.pdf:application/pdf},
}

@article{borkar_designing_2005,
	title = {Designing {Reliable} {Systems} from {Unreliable} {Components}: {The} {Challenges} of {Transistor} {Variability} and {Degradation}},
	volume = {25},
	issn = {0272-1732},
	shorttitle = {Designing {Reliable} {Systems} from {Unreliable} {Components}},
	url = {http://ieeexplore.ieee.org/document/1566551/},
	doi = {10.1109/MM.2005.110},
	language = {en},
	number = {6},
	urldate = {2019-04-08},
	journal = {IEEE Micro},
	author = {Borkar, S.},
	month = nov,
	year = {2005},
	pages = {10--16},
	file = {Borkar - 2005 - Designing Reliable Systems from Unreliable Compone.pdf:/Users/chakibbelgaid/Zotero newone/storage/ZJJVGDWV/Borkar - 2005 - Designing Reliable Systems from Unreliable Compone.pdf:application/pdf},
}

@article{peng2011reproducible,
  title={Reproducible research in computational science},
  author={Peng, Roger D},
  journal={Science},
  volume={334},
  number={6060},
  pages={1226--1227},
  year={2011},
  publisher={American Association for the Advancement of Science}
}

@article{goodman2016does,
  title={What does research reproducibility mean?},
  author={Goodman, Steven N and Fanelli, Daniele and Ioannidis, John PA},
  journal={Science translational medicine},
  volume={8},
  number={341},
  pages={341ps12--341ps12},
  year={2016},
  publisher={American Association for the Advancement of Science}
}

@inproceedings{echtler2018open,
  title={Open source, open science, and the replication crisis in HCI},
  author={Echtler, Florian and H{\"a}u{\ss}ler, Maximilian},
  booktitle={Extended Abstracts of the 2018 CHI Conference on Human Factors in Computing Systems},
  pages={1--8},
  year={2018}
}
